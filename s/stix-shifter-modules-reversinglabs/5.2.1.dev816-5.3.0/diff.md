# Comparing `tmp/stix_shifter_modules_reversinglabs-5.2.1.dev816-py2.py3-none-any.whl.zip` & `tmp/stix_shifter_modules_reversinglabs-5.3.0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,28 @@
-Zip file size: 32915 bytes, number of entries: 26
--rw-rw-r--  2.0 unx        0 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/__init__.py
--rw-rw-r--  2.0 unx     2166 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/entry_point.py
--rw-rw-r--  2.0 unx     5773 b- defN 23-May-12 16:36 stix_shifter_modules/reversinglabs/configuration/config.json
--rw-rw-r--  2.0 unx       78 b- defN 23-May-12 16:36 stix_shifter_modules/reversinglabs/configuration/dialects.json
--rw-rw-r--  2.0 unx     3026 b- defN 23-May-12 16:36 stix_shifter_modules/reversinglabs/configuration/lang_en.json
--rw-rw-r--  2.0 unx        0 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/__init__.py
--rw-rw-r--  2.0 unx    21567 b- defN 23-May-12 16:36 stix_shifter_modules/reversinglabs/stix_translation/json_to_stix_translator.py
--rw-rw-r--  2.0 unx    11237 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/query_constructor.py
--rw-rw-r--  2.0 unx     1029 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/query_translator.py
--rw-rw-r--  2.0 unx    13838 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/results_translator.py
--rw-rw-r--  2.0 unx      130 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/sdo_translator.py
--rw-rw-r--  2.0 unx      498 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/json/from_stix_map.json
--rw-rw-r--  2.0 unx      598 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/json/operators.json
--rw-rw-r--  2.0 unx        6 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_translation/json/to_stix_map.json
--rw-rw-r--  2.0 unx        0 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_transmission/__init__.py
--rw-rw-r--  2.0 unx     5615 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_transmission/api_client.py
--rw-rw-r--  2.0 unx     1012 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_transmission/delete_connector.py
--rw-rw-r--  2.0 unx     1845 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_transmission/error_mapper.py
--rw-rw-r--  2.0 unx     1307 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_transmission/ping_connector.py
--rw-rw-r--  2.0 unx     2752 b- defN 23-May-12 16:33 stix_shifter_modules/reversinglabs/stix_transmission/results_connector.py
--rw-rw-r--  2.0 unx    12786 b- defN 23-May-12 16:36 stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/LICENSE.md
--rw-rw-r--  2.0 unx     7128 b- defN 23-May-12 16:36 stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/METADATA
--rw-rw-r--  2.0 unx     1418 b- defN 23-May-12 16:36 stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/NOTICE
--rw-rw-r--  2.0 unx      110 b- defN 23-May-12 16:36 stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/WHEEL
--rw-rw-r--  2.0 unx       21 b- defN 23-May-12 16:36 stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3144 b- defN 23-May-12 16:36 stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/RECORD
-26 files, 97084 bytes uncompressed, 27453 bytes compressed:  71.7%
+Zip file size: 35196 bytes, number of entries: 26
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/__init__.py
+-rw-rw-r--  2.0 unx     1952 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/entry_point.py
+-rw-rw-r--  2.0 unx     7629 b- defN 23-May-16 14:08 stix_shifter_modules/reversinglabs/configuration/config.json
+-rw-rw-r--  2.0 unx       78 b- defN 23-May-16 14:08 stix_shifter_modules/reversinglabs/configuration/dialects.json
+-rw-rw-r--  2.0 unx     4575 b- defN 23-May-16 14:08 stix_shifter_modules/reversinglabs/configuration/lang_en.json
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/__init__.py
+-rw-rw-r--  2.0 unx    22536 b- defN 23-May-16 14:08 stix_shifter_modules/reversinglabs/stix_translation/json_to_stix_translator.py
+-rw-rw-r--  2.0 unx    11237 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/query_constructor.py
+-rw-rw-r--  2.0 unx     1029 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/query_translator.py
+-rw-rw-r--  2.0 unx    18762 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/results_translator.py
+-rw-rw-r--  2.0 unx     1354 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/sdo_translator.py
+-rw-rw-r--  2.0 unx      498 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/json/from_stix_map.json
+-rw-rw-r--  2.0 unx      598 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/json/operators.json
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_translation/json/to_stix_map.json
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_transmission/__init__.py
+-rw-rw-r--  2.0 unx     5539 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_transmission/api_client.py
+-rw-rw-r--  2.0 unx     1012 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_transmission/delete_connector.py
+-rw-rw-r--  2.0 unx     1845 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_transmission/error_mapper.py
+-rw-rw-r--  2.0 unx     1126 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_transmission/ping_connector.py
+-rw-rw-r--  2.0 unx     2578 b- defN 23-May-16 14:04 stix_shifter_modules/reversinglabs/stix_transmission/results_connector.py
+-rw-rw-r--  2.0 unx    12786 b- defN 23-May-16 14:08 stix_shifter_modules_reversinglabs-5.3.0.dist-info/LICENSE.md
+-rw-rw-r--  2.0 unx     8043 b- defN 23-May-16 14:08 stix_shifter_modules_reversinglabs-5.3.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx     1418 b- defN 23-May-16 14:08 stix_shifter_modules_reversinglabs-5.3.0.dist-info/NOTICE
+-rw-rw-r--  2.0 unx      110 b- defN 23-May-16 14:08 stix_shifter_modules_reversinglabs-5.3.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       21 b- defN 23-May-16 14:08 stix_shifter_modules_reversinglabs-5.3.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3103 b- defN 23-May-16 14:08 stix_shifter_modules_reversinglabs-5.3.0.dist-info/RECORD
+26 files, 107835 bytes uncompressed, 29818 bytes compressed:  72.3%
```

## zipnote {}

```diff
@@ -54,26 +54,26 @@
 
 Filename: stix_shifter_modules/reversinglabs/stix_transmission/ping_connector.py
 Comment: 
 
 Filename: stix_shifter_modules/reversinglabs/stix_transmission/results_connector.py
 Comment: 
 
-Filename: stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/LICENSE.md
+Filename: stix_shifter_modules_reversinglabs-5.3.0.dist-info/LICENSE.md
 Comment: 
 
-Filename: stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/METADATA
+Filename: stix_shifter_modules_reversinglabs-5.3.0.dist-info/METADATA
 Comment: 
 
-Filename: stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/NOTICE
+Filename: stix_shifter_modules_reversinglabs-5.3.0.dist-info/NOTICE
 Comment: 
 
-Filename: stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/WHEEL
+Filename: stix_shifter_modules_reversinglabs-5.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/top_level.txt
+Filename: stix_shifter_modules_reversinglabs-5.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/RECORD
+Filename: stix_shifter_modules_reversinglabs-5.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## stix_shifter_modules/reversinglabs/entry_point.py

```diff
@@ -8,15 +8,14 @@
 from .stix_translation.results_translator import ResultsTranslator
 from stix_shifter_utils.stix_translation.src.json_to_stix.json_to_stix import JSONToStix
 import os
 
 
 class EntryPoint(BaseEntryPoint):
 
-    # python main.py translate ibmxfe results '{"type": "identity","id": "identity--f431f809-377b-45e0-aa1c-6a4751cae5ff","name": "IBM X-Force","identity_class": "system"}' '' < ../xfe_result.json --stix-validator
 
     def __init__(self, connection={}, configuration={}, options={}):
         super().__init__(connection, configuration, options)
         self.set_async(False)
 
         if connection:
             api_client = APIClient(connection, configuration)
```

## stix_shifter_modules/reversinglabs/configuration/config.json

### Pretty-printed

 * *Similarity: 0.7599549755799756%*

 * *Differences: {"'configuration'": "{'rateLimit': OrderedDict([('type', 'fields'), ('rateLimit', "*

 * *                    "OrderedDict([('default', 10000), ('type', 'number'), ('hidden', True)])), "*

 * *                    "('rateUnit', OrderedDict([('default', 'Day'), ('type', 'text'), ('hidden', "*

 * *                    "True)]))]), 'cacheDuration': OrderedDict([('type', 'fields'), "*

 * *                    "('cacheDuration', OrderedDict([('default', 10), ('type', 'number'), "*

 * *                    "('hidden', True)])), ('unit', Ordere […]*

```diff
@@ -4,33 +4,89 @@
             "password": {
                 "type": "password"
             },
             "type": "fields",
             "username": {
                 "type": "text"
             }
+        },
+        "cacheDuration": {
+            "cacheDuration": {
+                "default": 10,
+                "hidden": true,
+                "type": "number"
+            },
+            "type": "fields",
+            "unit": {
+                "default": "Minute",
+                "hidden": true,
+                "type": "text"
+            }
+        },
+        "dataTypeList": {
+            "domain": {
+                "default": true,
+                "type": "checkbox"
+            },
+            "hash": {
+                "default": true,
+                "type": "checkbox"
+            },
+            "ip": {
+                "default": true,
+                "type": "checkbox"
+            },
+            "type": "fields",
+            "url": {
+                "default": true,
+                "type": "checkbox"
+            }
+        },
+        "rateLimit": {
+            "rateLimit": {
+                "default": 10000,
+                "hidden": true,
+                "type": "number"
+            },
+            "rateUnit": {
+                "default": "Day",
+                "hidden": true,
+                "type": "text"
+            },
+            "type": "fields"
         }
     },
     "connection": {
         "help": {
             "default": "www.ibm.com",
             "type": "link"
         },
         "host": {
+            "default": "",
+            "hidden": true,
             "type": "text"
         },
         "namespace": {
+            "default": "9d4bedaf-d351-4f50-930f-f8eb121e5bae",
+            "hidden": true,
             "type": "text"
         },
         "options": {
             "async_call": {
                 "hidden": true,
                 "optional": true,
                 "type": "text"
             },
+            "concurrent": {
+                "default": 4,
+                "max": 100,
+                "min": 1,
+                "previous": "connection.maxConcurrentSearches",
+                "type": "number"
+            },
             "dialects": {
                 "hidden": true,
                 "optional": true,
                 "type": "array"
             },
             "language": {
                 "default": "stix",
@@ -108,14 +164,15 @@
                 },
                 "optional": true,
                 "previous": "connection.mapping",
                 "type": "json"
             },
             "result_limit": {
                 "default": 10000,
+                "hidden": true,
                 "max": 500000,
                 "min": 1,
                 "previous": "connection.resultSizeLimit",
                 "type": "number"
             },
             "stix_2.1": {
                 "default": false,
@@ -128,14 +185,15 @@
                 "hidden": true,
                 "optional": true,
                 "previous": "connection.stix_validator",
                 "type": "boolean"
             },
             "time_range": {
                 "default": 5,
+                "hidden": true,
                 "max": 10000,
                 "min": 1,
                 "nullable": true,
                 "previous": "connection.timerange",
                 "type": "number"
             },
             "timeout": {
@@ -158,15 +216,20 @@
                 "optional": true,
                 "previous": "connection.validate_pattern",
                 "type": "boolean"
             }
         },
         "port": {
             "default": 443,
+            "hidden": true,
+            "max": 65535,
+            "min": 1,
             "type": "number"
         },
         "type": {
+            "description": "Enrich IP addresses, domains, hashes and URLs with the ReversingLabs threat intelligence service.",
             "displayName": "ReversingLabs",
+            "id": "ReversingLabs_Connector",
             "type": "connectorType"
         }
     }
 }
```

## stix_shifter_modules/reversinglabs/configuration/lang_en.json

### Pretty-printed

 * *Similarity: 0.6712239583333333%*

 * *Differences: {"'configuration'": "{'auth': {'username': {'description': 'ReversingLabs Username'}, 'password': "*

 * *                    "{'description': 'ReversingLabs Password'}}, 'rateLimit': "*

 * *                    "OrderedDict([('rateLimit', OrderedDict([('label', 'Rate Limit'), "*

 * *                    "('description', 'The number of queries allowed by ReversingLabs')])), "*

 * *                    "('rateUnit', OrderedDict([('label', 'Rate Unit'), ('description', 'The rate "*

 * *                    "unit for rate limit in [seconds […]*

```diff
@@ -1,73 +1,108 @@
 {
     "configuration": {
         "auth": {
             "password": {
-                "description": "Password for your RL instance",
+                "description": "ReversingLabs Password",
                 "label": "Password"
             },
             "username": {
-                "description": "Username to login to your RL instance",
+                "description": "ReversingLabs Username",
                 "label": "Username"
             }
+        },
+        "cacheDuration": {
+            "cacheDuration": {
+                "description": "How long should we cache the results of the STIX Bundle execution?",
+                "label": "Cache Duration"
+            },
+            "unit": {
+                "description": "The unit for cache in [seconds, minutes, days, months, years ...]",
+                "label": "Rate Unit"
+            }
+        },
+        "dataTypeList": {
+            "domain": {
+                "description": "Whether Domain queries are supported by Reversing Labs based on the User's API Provisioning",
+                "label": "Domain"
+            },
+            "hash": {
+                "description": "Whether Hash queries are supported by Reversing Labs based on the User's API Provisioning",
+                "label": "Hash"
+            },
+            "ip": {
+                "description": "Whether IP Address lookup queries are supported by Reversing Labs based on the User's API Provisioning",
+                "label": "IP Address"
+            },
+            "url": {
+                "description": "Whether Domain queries are supported by Reversing Labs based on the User's API Provisioning",
+                "label": "URL"
+            }
+        },
+        "rateLimit": {
+            "rateLimit": {
+                "description": "The number of queries allowed by ReversingLabs",
+                "label": "Rate Limit"
+            },
+            "rateUnit": {
+                "description": "The rate unit for rate limit in [seconds, minutes, days, months, years ...]",
+                "label": "Rate Unit"
+            }
         }
     },
     "connection": {
-        "help": {
-            "label": "Need additional help?"
-        },
         "host": {
             "description": "Specify the OCP Cluster hostname or the XForce API host URL",
-            "label": "Management IP address or hostname",
-            "placeholder": "https://mundy.threatqtie.com"
+            "label": "Management IP address or Hostname",
+            "placeholder": "192.168.1.10"
+        },
+        "namespace": {
+            "description": "Supply a UUID to generate deterministic UUIDs for the resulting STIX bundle",
+            "label": "The UUID Namespace to generate unique "
         },
         "options": {
             "concurrent": {
                 "description": "The number of simultaneous connections that can be made to the data source.  Valid input range is {{min}} to {{max}}.",
-                "label": "Concurrent Search Limit"
+                "label": "Concurrent search limit"
             },
             "dialects": {
                 "description": "The dialect to use if the data source needs to search multiple schema or database tables.",
                 "label": "Dialect"
             },
             "mapping": {
                 "description": "Custom stix mapping if default mapping needs to be replaced",
-                "label": "Custom Mapping"
+                "label": "Custom mapping"
             },
             "result_limit": {
                 "description": "The maximum number of entries or objects that are returned by search query.  Valid input range is {{min}} to {{max}}.",
-                "label": "Result Size Limit"
+                "label": "Result size limit"
+            },
+            "search_timeout": {
+                "description": "The limit on how long the query will run, in minutes, on the data source.",
+                "label": "Query Search Timeout Limit"
             },
             "stix_validator": {
                 "description": "Validate translated STIX Objects",
-                "label": "STIX Object Validator"
+                "label": "STIX object validator"
             },
             "time_range": {
                 "description": "Time range for the search, in minutes, represented as last x minutes.  Valid input range is {{min}} to {{max}}.",
-                "label": "Query Time Range"
+                "label": "Query time range"
             },
             "timeout": {
                 "description": "The limit on how long to wait for the data source response, in seconds. Valid input range is {{min}} to {{max}}.",
-                "label": "Query Response Timeout Limit"
+                "label": "Query response timeout limit"
             },
             "validate_pattern": {
                 "description": "Validate STIX patterns that needs to be translated into native data source query",
-                "label": "STIX Pattern Validator"
+                "label": "STIX pattern validator"
             }
         },
         "port": {
-            "description": "Set the port number that is associated with the hostname or IP address",
+            "description": "Set the port number that is associated with the Host name or IP",
             "label": "Host Port"
         },
-        "selfSignedCert": {
-            "description": "Paste your certificate",
-            "label": "X-Force Exchange Connection Certificate"
-        },
-        "sni": {
-            "description": "The Server Name Indicator (SNI) enables a separate hostname to be provided for SSL authentication",
-            "label": "Server Name Indicator"
-        },
         "type": {
             "description": "Data source type"
         }
     }
 }
```

## stix_shifter_modules/reversinglabs/stix_translation/json_to_stix_translator.py

```diff
@@ -15,41 +15,49 @@
 NUMBER_OBSERVED_KEY = 'number_observed'
 FIRST_OBSERVED_KEY = 'first_observed'
 LAST_OBSERVED_KEY = 'last_observed'
 
 
 # convert JSON data to STIX object using map_data and transformers
 def convert_to_stix(data_source, map_data, data, transformers, options, callback=None):
+    try:
+        ds2stix = DataSourceObjToStixObj(data_source, map_data, transformers, options, callback)
 
-    ds2stix = DataSourceObjToStixObj(data_source, map_data, transformers, options, callback)
-
-    # map data list to list of transformed objects
-    observation = ds2stix.transform
-    results = list(map(observation, data))
-
-    for stix_object in results:
-        if ds2stix.spec_version == "2.1":
-            del stix_object["objects"]
-        ds2stix.bundle["objects"].append(stix_object)
-
-    for _, value in ds2stix.unique_cybox_objects.items():
-        ds2stix.bundle["objects"].append(value)
-
-    if options.get('stix_validator'):
-        if ds2stix.spec_version == "2.1":
-            # Serialize and Deserialize bundle to covert StixObjectIds to strings
-            bundle_obj = json.dumps(ds2stix.bundle, sort_keys=False)
-            bundle_obj = json.loads(bundle_obj)
-        else:
-            bundle_obj = ds2stix.bundle
-        validated_result = validate_instance(bundle_obj, ValidationOptions(version=ds2stix.spec_version))
-        print_results(validated_result)
+        # map data list to list of transformed objects
+        observation = ds2stix.transform
+        results = list(map(observation, data))
+
+        for stix_object in results:
+            if ds2stix.spec_version == "2.1":
+                del stix_object["objects"]
+            ds2stix.bundle["objects"].append(stix_object)
+
+        for _, value in ds2stix.unique_cybox_objects.items():
+            ds2stix.bundle["objects"].append(value)
+
+        if options.get('stix_validator'):
+            if ds2stix.spec_version == "2.1":
+                # Serialize and Deserialize bundle to covert StixObjectIds to strings
+                bundle_obj = json.dumps(ds2stix.bundle, sort_keys=False)
+                bundle_obj = json.loads(bundle_obj)
+            else:
+                bundle_obj = ds2stix.bundle
+            validated_result = validate_instance(bundle_obj, ValidationOptions(version=ds2stix.spec_version))
+            print_results(validated_result)
 
-    return ds2stix.bundle
+        return ds2stix.bundle
 
+    except Exception as e:
+        try:
+            # try to print the error line
+            logger_log = logger.set_logger(__name__)
+            logger_log.error(logger.last_tb_to_string(e))
+        except:
+            pass
+        raise e
 
 class DataSourceObjToStixObj:
     logger = logger.set_logger(__name__)
 
     def __init__(self, data_source, ds_to_stix_map, transformers, options, callback=None):
         self.identity_id = data_source["id"]
         self.ds_to_stix_map = ds_to_stix_map
@@ -196,31 +204,38 @@
         
         return tag_ind
 
     def _add_property(self, type_name, property_key, parent_key_ind, value, objects, group=False, cybox=True):
         """
         Add observable object property and its STIX valid value to the cached `objects` dictionary
         """
+        named_group =  isinstance(group, str) and group.lower() != "true"
         parent_key_ind_str = str(parent_key_ind)
         if not parent_key_ind_str in objects:
             if cybox:
+                # Grouped properties go in a list
+                if named_group:
+                    value = [value]
                 objects[parent_key_ind_str] = {
                     'type': type_name,
                     property_key: value
                 }
                 if self.spec_version == "2.1":
                     objects[parent_key_ind_str]["id"] = parent_key_ind
                     objects[parent_key_ind_str]["spec_version"] = "2.1"
             else:
                 objects[parent_key_ind_str] = {
                 property_key: value
             }
         else:
             if not property_key in objects[parent_key_ind_str]:
                 objects[parent_key_ind_str][property_key] = value
+            # Add grouped value in existing list element
+            elif isinstance(value, dict) and named_group and isinstance(objects[parent_key_ind_str][property_key], list):
+                objects[parent_key_ind_str][property_key][0] = dict_merge(objects[parent_key_ind_str][property_key][0], value)
             elif isinstance(value, dict):
                 objects[parent_key_ind_str][property_key] = dict_merge(objects[parent_key_ind_str][property_key], value)
             elif isinstance(objects[parent_key_ind_str][property_key], list) and group:
                 objects[parent_key_ind_str][property_key].extend(value)
 
             
     def _handle_properties(self, to_stix_config_prop, data, objects, object_tag_ref_map, parent_data=None, ds_sub_key=None, object_key_ind=None):
@@ -300,16 +315,18 @@
                 if len(config_keys) < 2:
                     if False is prop.get('cybox', self.cybox_default): 
                         object_tag_ref_map['out_cybox'][key] = self._compose_value_object(data, [], observable_key=key, object_tag_ref_map=object_tag_ref_map, transformer=transformer, references=references, unwrap=unwrap)
                     pass
                 else:
                     type_name = config_keys[0]
                     property_key = config_keys[1]
+                    # set the object to combine properties from same SCO
                     parent_key = prop['object'] if 'object' in prop else type_name
 
+                    # set the group to combine properties in a list
                     group = prop['group'] if 'group' in prop else False
                     substitute_key = prop['ds_key'] if 'ds_key' in prop else None
 
                     if False is cybox and not substitute_key:
                         value = self._compose_value_object(data, config_keys[2:], observable_key=key, object_tag_ref_map=object_tag_ref_map, transformer=transformer, references=references, unwrap=unwrap)
                         self._add_property(type_name, property_key, type_name, value, object_tag_ref_map['out_cybox'], cybox=False)
                         continue
```

## stix_shifter_modules/reversinglabs/stix_translation/results_translator.py

```diff
@@ -1,11 +1,60 @@
 from stix_shifter_utils.modules.base.stix_translation.base_results_translator import BaseResultTranslator
 from . import sdo_translator
-from ipaddress import ip_network, IPv4Network
+# from stix_shifter_utils.normalization.normalization_helper import create_attributes, evaluate_attribute_type
+from os import path
+import json
+from ipaddress import ip_network, IPv4Network, IPv6Network, IPv6Network
+from stix_shifter_utils.utils import logger
 import uuid
+from urllib.parse import urlparse
+
+
+def create_attributes(attribute_fields, data):
+  threat_attribute_report = []
+  if isinstance(attribute_fields, dict):
+    for attribute, value in attribute_fields.items():
+      if attribute in data:
+        attribute_dict = {}
+        attribute_dict['attribute_name'] = value
+        attribute_dict['attribute_value'] = str(data[attribute])
+        attribute_dict['attribute_type'] = evaluate_attribute_type(data[attribute])
+        threat_attribute_report.append(attribute_dict) if attribute_dict['attribute_type'] is not None else ''
+  elif type(attribute_fields) is str:
+    attribute_dict = {}
+    attribute_dict['attribute_name'] = attribute_fields
+    attribute_dict['attribute_value'] = str(data)
+    attribute_dict['attribute_type'] = evaluate_attribute_type(data)
+    threat_attribute_report.append(attribute_dict) if attribute_dict['attribute_type'] is not None else ''
+  return threat_attribute_report
+
+
+def evaluate_attribute_type(attribute):
+  # supported types = string, number, uri, ip, lat_lng
+  attribute_type = None
+  if isinstance(attribute, bool):
+    attribute_type = 'string' if attribute is True else None
+  elif isinstance(attribute, (int, float, complex)):
+    attribute_type = 'number'
+  if isinstance(attribute, (str)):
+    attribute_type = 'string'
+    if uri_validator(attribute):
+      attribute_type = 'uri'
+    try:
+      if isinstance(ip_network(attribute), (IPv4Network, IPv6Network)):
+        attribute_type = 'ip'
+    except ValueError:
+      pass
+
+  return attribute_type
+
+
+def uri_validator(x):
+  result = urlparse(x)
+  return all([result.scheme, result.netloc])
 
 class ResultsTranslator(BaseResultTranslator):
 
   # Get indicator_types value
   def get_indicator_types(self, value):
     if value in ["KNOWN", 'known']:
       return 'benign'
@@ -69,37 +118,42 @@
           indicator_types = {
             "indicator_types": [indicator_types_value]} if indicator_types_value is not None else None
           return indicator_types
 
     return None
 
   def get_description(self, data):
-    for ds_key in data:
-      if ds_key == "rl":
-
-        if "uri_state" in data[ds_key][0]:
-          value = data[ds_key][0]['uri_state']['counters']
+    if data.get('rl'):
+        rl_report = data['rl'][0]
+        if "uri_state" in rl_report:
+          value = rl_report['uri_state']['counters']
+          value = dict((k.capitalize(), v) for (k, v) in value.items())
           description = {"description": str(value).strip('{}')}
           return description
 
-        elif "analysis" in data[ds_key][0]:
-          value = data[ds_key][0]['analysis']['statistics']
+        elif "analysis" in rl_report:
+          value = rl_report['analysis']['statistics']
+          value = dict((k.capitalize(), v) for (k, v) in value.items())
           description = {"description":  str(value).strip('{}')}
           return description
 
-        elif "malware_presence" in data[ds_key][0] and (data[ds_key][0].get('malware_presence').get('classification') is not None):
-          value = data[ds_key][0]['malware_presence']['classification']
-          description = {"description":  str(value).strip('{}')}
-          return description
+        # elif "malware_presence" in data[ds_key][0] and (data[ds_key][0].get('malware_presence').get('classification') is not None):
+        #   value = data[ds_key][0]['malware_presence']['classification']
+        #   value = dict((k.capitalize(), v) for (k, v) in value.items())
+        #   description = {"description":  str(value).strip('{}')}
+        elif "malware_presence" in rl_report and (rl_report.get('malware_presence').get('status')):
+          value = rl_report['malware_presence']['status']
+          description = 'Report - {}'.format(value) 
+          return {"description":  description}
 
         else:
-          description = {"description": "Not Available"}
+          description = {"description": "Report - Not Available"}
           return description
 
-    return None
+    return {'description': 'Not Available'}
 
   # Get required pattern field from the report, the pattern is a combination of data and dataType fields in the Analyzer result JSON
   def get_pattern_from_json(self, data):
     pattern_type, pattern_value = data['dataType'], data['data']
     pattern = self.evaluate_pattern(pattern_type, pattern_value)
     pattern = {"pattern": pattern}
     return pattern
@@ -129,33 +183,30 @@
 
     return pattern
 
 
   def get_malware_object(self, data):
     try:
     # Malware SDO only present in RL hash dataType
-      if data["dataType"] == 'hash' and data['rl'][0].get('malware_presence') and data['rl'][0]['malware_presence'].get('classification'):
-        classification = data['rl'][0]['malware_presence'].get('classification')
+      if data["dataType"] == 'hash' and data['rl'][0].get('malware_presence'):
+        classification = data['rl'][0]['malware_presence'].get('classification', {})
         malware = []
         malware_type = classification.get('type')
-        #malware_family = classification.get('family_name')
         malware_info = {}
         if malware_type:
           malware_info['malware_types'] = malware_type
-          #malware_info[]
           malware_info['is_family'] = True
           malware.append(malware_info)
         return malware
       else:
         return
 
     except ValueError:
       raise ValueError("Exception occurred to parse report data for malware SDO")
 
-
   def create_indicator_object(self, *properties):
     indicator_object = {}
     for prop in properties:
       if prop is not None:
         for key, value in prop.items():
           indicator_object[key] = value
     return indicator_object
@@ -163,148 +214,232 @@
 
   def get_threat_report(self, data):
     report = {'x_ibm_original_threat_feed_data': {'full': data['rl']}}
     return report
 
 
   def get_threat_score(self, data, indicator):
-    if not indicator:
-      return None
+
 
     BENIGN_SCORE_MIN = 0
     BENIGN_SCORE_MAX = 9
     UNKNOWN_SCORE_MIN = 10
     UNKNOWN_SCORE_MAX = 29
     SUSPICIOUS_SCORE_MIN = 30
     SUSPICIOUS_SCORE_MAX = 69
     MALICIOUS_SCORE_MIN = 70
     MALICIOUS_SCORE_MAX = 100
+    INDICATOR_TYPE = indicator['indicator_types'][0]
 
-    for ds_key in data:
-      if ds_key == "rl":
-        # When IP adr is passed
-        if "uri_state" in data[ds_key][0]:
+    if(INDICATOR_TYPE == 'benign'):
+      tis_range_min = BENIGN_SCORE_MIN
+      tis_range_max = BENIGN_SCORE_MAX
+    elif(INDICATOR_TYPE == 'unknown'):
+      tis_range_min = UNKNOWN_SCORE_MIN
+      tis_range_max = UNKNOWN_SCORE_MAX
+    elif (INDICATOR_TYPE == 'anomalous-activity'):
+      tis_range_min = SUSPICIOUS_SCORE_MIN
+      tis_range_max = SUSPICIOUS_SCORE_MAX
+    else:
+      tis_range_min = MALICIOUS_SCORE_MIN
+      tis_range_max = MALICIOUS_SCORE_MAX
 
-          if(indicator['indicator_types'][0] == 'benign'):
-            return {"threat_score": 0.0}
-          elif (indicator['indicator_types'][0] == 'unknown'):
-            return {"threat_score": UNKNOWN_SCORE_MIN}
-
-          malicious = data[ds_key][0]['uri_state']['counters']['malicious']
-          suspicious = data[ds_key][0]['uri_state']['counters']['suspicious']
-
-          if malicious >= suspicious:
-            tis_range_min = MALICIOUS_SCORE_MIN
-            tis_range_max = MALICIOUS_SCORE_MAX
-            threat_score = malicious/suspicious if suspicious != 0 else malicious
-          else:
-            tis_range_min = SUSPICIOUS_SCORE_MIN
-            tis_range_max = SUSPICIOUS_SCORE_MAX
-            threat_score = suspicious/malicious if malicious != 0 else suspicious
-
-          range_min = 1
-          range_max = 10
-          if threat_score > 10:
-            threat_score = 10
-          tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
-          return {"threat_score": round(tis_score, 1)}
-
-        elif "analysis" in data[ds_key][0]:
-          statistics = data[ds_key][0]['analysis']['statistics']
-          malicious = statistics['malicious']
-          suspicious = statistics['suspicious']
-          unknown = statistics['unknown']
-          known = statistics['known']
-          if (malicious > 0 and malicious >= suspicious):
-            tis_range_min = MALICIOUS_SCORE_MIN
-            tis_range_max = MALICIOUS_SCORE_MAX
-            threat_score = malicious/suspicious if suspicious != 0 else malicious
-          elif suspicious > 0:
-            tis_range_min = SUSPICIOUS_SCORE_MIN
-            tis_range_max = SUSPICIOUS_SCORE_MAX
-            threat_score = suspicious/malicious if malicious != 0 else suspicious
-          elif unknown > 0:
-            tis_range_min = UNKNOWN_SCORE_MIN
-            tis_range_max = UNKNOWN_SCORE_MAX
-            threat_score = int(unknown/known * 10)
-          else:
-            return {"threat_score": 0.0}
-          range_min = 1
-          range_max = 10
-          if threat_score > 10:
-            threat_score = 10
-          tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
-          return {"threat_score": round(tis_score, 1)}
-
-        # When Hash is passed
-        elif "malware_presence" in data[ds_key][0] and 'threat_level' in data[ds_key][0]['malware_presence'] and 'trust_factor' in data[ds_key][0]['malware_presence']:
-          threat_level = data[ds_key][0]['malware_presence']['threat_level']
-          trust_factor = data[ds_key][0]['malware_presence']['trust_factor']
-          # Since trust factor = 0 is most trustworthy, we flip the list
-          trust_range = [5, 4, 3, 2, 1, 0]
-          trust = trust_range[trust_factor]
-          threat_score = threat_level * trust
-          range_min = 0
-          range_max = 25
-          if(indicator['indicator_types'][0] == 'benign'):
-            tis_range_min = BENIGN_SCORE_MIN
-            tis_range_max = BENIGN_SCORE_MAX
-            tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
-          elif(indicator['indicator_types'][0] == 'unknown'):
-            tis_range_min = UNKNOWN_SCORE_MIN
-            tis_range_max = UNKNOWN_SCORE_MAX
-            tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
-          elif (indicator['indicator_types'][0] == 'anomalous-activity'):
-            tis_range_min = SUSPICIOUS_SCORE_MIN
-            tis_range_max = SUSPICIOUS_SCORE_MAX
-            tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
-          else:
-            tis_range_min = MALICIOUS_SCORE_MIN
-            tis_range_max = MALICIOUS_SCORE_MAX
-            tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
 
-          threat_score = {"threat_score": round(tis_score, 1)}
-          return threat_score
+    ds_key = data.get('rl', [])
+    if ds_key:
+      ds_key = ds_key[0]
 
+      # When IP addr is passed
+      if "uri_state" in ds_key:
+
+        if(INDICATOR_TYPE == 'benign'):
+          return {"threat_score": BENIGN_SCORE_MIN}
+        elif (INDICATOR_TYPE == 'unknown'):
+          return {"threat_score": UNKNOWN_SCORE_MIN}
+
+        malicious = ds_key['uri_state']['counters']['malicious']
+        suspicious = ds_key['uri_state']['counters']['suspicious']
+
+        if malicious >= suspicious:
+          threat_score = malicious/suspicious if suspicious != 0 else malicious
         else:
-          if(indicator['indicator_types'][0] == 'benign'):
-            return {"threat_score": round(BENIGN_SCORE_MIN, 1)}
-          elif(indicator['indicator_types'][0] == 'unknown'):
-            return {"threat_score": round(UNKNOWN_SCORE_MIN, 1)}
-          elif(indicator['indicator_types'][0] == 'anomalous-activity'):
-            return {"threat_score": round(SUSPICIOUS_SCORE_MIN, 1)}
-          else:
-            return {"threat_score": round(MALICIOUS_SCORE_MIN, 1)}
+          threat_score = suspicious/malicious if malicious != 0 else suspicious
+
+        range_min = 0
+        range_max = 10
+        if threat_score > 10:
+          threat_score = 10
+
+        tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
+        return {"threat_score": round(tis_score, 1)}
+
+      elif "analysis" in ds_key:
+        statistics = ds_key['analysis']['statistics']
+        malicious = statistics['malicious']
+        suspicious = statistics['suspicious']
+        unknown = statistics['unknown']
+        known = statistics['known']
+
+        if (malicious > 0 and malicious >= suspicious):
+          threat_score = malicious/suspicious if suspicious != 0 else malicious
+        elif suspicious > 0:
+          threat_score = suspicious/malicious if malicious != 0 else suspicious
+        elif unknown > 0:
+          threat_score = int(unknown/known * 10)
+        else:
+          threat_score = 0
+
+        range_min = 0
+        range_max = 10
+        if threat_score > 10:
+          threat_score = 10
+        tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
+        return {"threat_score": round(tis_score, 1)}
+
+      # When Hash is passed
+      elif "malware_presence" in ds_key and 'threat_level' in ds_key['malware_presence'] and 'trust_factor' in ds_key['malware_presence']:
+        threat_level = ds_key['malware_presence']['threat_level']
+        trust_factor = ds_key['malware_presence']['trust_factor']
+        # Since trust factor = 0 is most trustworthy, we flip the list
+        trust_range = [5, 4, 3, 2, 1, 0]
+        trust = trust_range[trust_factor]
+        threat_score = threat_level * trust
+        range_min = 0
+        range_max = 25
+
+        tis_score = tis_range_min + (tis_range_max-tis_range_min) * 1.0 * (threat_score-range_min) / (range_max - range_min)
+        threat_score = {"threat_score": round(tis_score, 1)}
+        return threat_score
+
+    return {"threat_score": round(tis_range_min, 1)}
+
+
+  def get_threat_attributes(self, data):
+    threat_attribute_report = []
+    if 'rl' not in data:
+      return {'threat_attributes' : threat_attribute_report}
+
+    full_report = data.get('rl', [])[0]
+    # We pass the fields we want as attributes, with then new names of the fields
+    
+    uri_state_fields = { 'sha1': 'SHA-1' }
+    field_dict = {'uri_state': uri_state_fields}
+
+    for attribute_keys, attribute_value in field_dict.items():
+      if full_report.get(attribute_keys):
+        threat_attribute_report += create_attributes(attribute_value, full_report[attribute_keys])
+
+    uri_counters = full_report.get('uri_state', {}).get('counters')
+    if uri_counters:
+      threat_attribute_report.extend(self.get_uri_counters_attributes(uri_counters))
+
+
+    if data['dataType'] == 'hash':
+      malware_presence_fields = {
+        'first_seen': 'First Seen', 
+        'last_seen': 'Last Seen',
+        'classification': 'Classification', # Available in RF Description
+        'scanner_count': 'Scanner Count',
+        'scanner_percent': 'Scanner Percent',
+        'scanner_match': 'Scanner Match',
+        'status': 'Status',
+        'threat_level': 'Threat Level',
+        'trust_factor': 'Trust Factor',
+      }
+
+      classification_fields = {
+        'subplatform': 'Subplatform',
+        'platform': 'Platform',
+        'type': 'Type',
+        'is_generic': 'Is Generic',
+        'family_name': 'Family Name'
+      }
+
+      field_dict = {
+        'malware_presence': malware_presence_fields,
+        'classification': classification_fields
+      }
+
+      for attribute_keys, attribute_value in field_dict.items():
+        if attribute_keys in full_report:
+          threat_attribute_report += create_attributes(attribute_value, full_report[attribute_keys])
+
+      if full_report.get('malware_presence', {}).get('classification'):
+        full_report = full_report['malware_presence']
+        for attribute_keys, attribute_value in field_dict.items():
+          if attribute_keys in full_report:
+            threat_attribute_report += create_attributes(attribute_value, full_report[attribute_keys])
+
+
+    elif data['dataType'] == 'url' or data['dataType'] == 'domain':
+      full_fields = {
+        'classification': 'classification', # Available in indicator types
+      }
+      THIRD_PARTY_REPUTATIONS = 'third_party_reputations'
+      if full_report.get('classification'):
+        attribute_dict = {}
+        attribute_dict['attribute_name'] = full_fields['classification']
+        attribute_dict['attribute_value'] = full_report['classification']
+        attribute_dict['attribute_type'] = evaluate_attribute_type(full_report['classification'])
+        threat_attribute_report.append(attribute_dict)
+
+      if full_report.get('third_party_reputations', {}).get('statistics', {}):
+        attribute_dict, statistics = {}, full_report[THIRD_PARTY_REPUTATIONS]['statistics']
+        for statistics_key, statistics_value in statistics.items():
+          attribute_dict = {}
+          attribute_dict['attribute_name'] = THIRD_PARTY_REPUTATIONS + " {}".format(statistics_key)
+          attribute_dict['attribute_value'] = statistics_value
+          attribute_dict['attribute_type'] = evaluate_attribute_type(statistics_value)
+          threat_attribute_report.append(attribute_dict)
+
+
+    return {'threat_attributes' : threat_attribute_report} if threat_attribute_report else None
+
+
+  def get_uri_counters_attributes(self, uri_counters: dict) -> list:
+      threat_attribute_report = []
+      for counter,value in uri_counters.items():
+        attribute_name = '{} Counters'.format(counter.capitalize())
+        counter_dict = {
+          'attribute_name': attribute_name,
+          'attribute_value': value,
+          'attribute_type': evaluate_attribute_type(value)
+        }
+        threat_attribute_report.append(counter_dict)
+      return threat_attribute_report
 
 
   def translate_results(self, data_source, data):
     """
-    Translates JSON data into STIX results
+    Translates JSON data into STIX results based on a mapping file
     :param data: JSON formatted data to translate into STIX format
     :type data: str
+    :param mapping: The mapping file path to use as instructions on how to translate the given JSON data to STIX.
+        Defaults the path to whatever is passed into the constructor for JSONToSTIX (This should be the to_stix_map.json in the module's json directory)
+    :type mapping: str (filepath)
     :return: STIX formatted results
     :rtype: str
     """
 
-    json_data = data
-    json_data = json_data[0]
-    ANALYZER_NAME = 'ReversingLabs_1_0'
-    data_source['id'] = ANALYZER_NAME
+    json_data = data[0]
+    CONNECTOR_NAME = 'ReversingLabs_Connector'
+    data_source['id'] = CONNECTOR_NAME
 
     # Add Namespace
     try:
       uuid.UUID(json_data["namespace"])
     except ValueError:
       raise ValueError("Namespace is not valid UUID")
     NAMESPACE = json_data["namespace"]
-    data_source['name'] = ANALYZER_NAME
+    data_source['name'] = CONNECTOR_NAME
 
     pattern = self.get_pattern_from_json(json_data)
     indicator_types = self.get_optional_values(json_data)
     description = self.get_description(json_data)
+    threat_attributes = self.get_threat_attributes(json_data)
     threat_score = self.get_threat_score(json_data, indicator_types)
     indicator_name = {'name': json_data['data']}
     indicator_object = self.create_indicator_object(pattern, indicator_types, description, indicator_name)
 
     if (len(json_data['rl']) == 0):
         json_data['rl'] = [{'message': 'IOC not found'}]
 
@@ -314,28 +449,30 @@
     stix_bundle = sdo_translator_object.create_stix_bundle()
 
     # Add Indentity SDO
     identity_object = sdo_translator_object.create_identity_sdo(data_source, NAMESPACE)
     stix_bundle['objects'] += identity_object
 
     # Add extension-definition SDO
-    toplevel_properties = ['x_ibm_original_threat_feed_data']
+    toplevel_properties = ['x_ibm_original_threat_feed_data', 'threat_score']
     nested_properties = []
-    if (threat_score):
-      toplevel_properties.append('threat_score')
+    if (threat_attributes):
+      toplevel_properties.append('threat_attributes')
 
     extension_object = sdo_translator_object.create_extension_sdo(identity_object[0], NAMESPACE, nested_properties, toplevel_properties=toplevel_properties)
     stix_bundle['objects'] += extension_object
 
     # Add Indicator SDO
     extension_id = extension_object[0]['id']
     identity_id = identity_object[0]['id']
     report = self.get_threat_report(json_data)
     nested_indicator = []
     top_indicator = [threat_score, report]
+    if (threat_attributes):
+      top_indicator.append(threat_attributes)
 
     indicator_stix_object = sdo_translator_object.create_indicator_sdo(indicator_object, identity_id, extension_id, nested_indicator, top_indicator)
     stix_bundle['objects'] += indicator_stix_object
 
     malware_object = self.get_malware_object(json_data)
     # Add Malware SDO    
     # Should return a list of malware dict
```

## stix_shifter_modules/reversinglabs/stix_translation/sdo_translator.py

```diff
@@ -1,4 +1,21 @@
 from stix_shifter_utils.normalization.BaseNormalization import BaseNormalization
 
 class SdoTranslator(BaseNormalization):
-    pass
+    def create_sighting_sdo(self, sighting_object, indicator_id):
+        return super().create_sighting_sdo(sighting_object, indicator_id)    
+
+    def create_infrastructure_object_sdo(self, infrastructure_object, enriched_ioc, indicator_id):          
+        return super().create_infrastructure_object_sdo(infrastructure_object, enriched_ioc, indicator_id)  
+
+    def create_malware_sdo(self, malware_object, indicator_id, enriched_ioc):
+        return super().create_malware_sdo(malware_object, indicator_id, enriched_ioc)
+
+    def create_identity_sdo(self, data_source, namespace):
+        return super().create_identity_sdo(data_source, namespace)
+
+    def create_extension_sdo(self, identity_object, namespace, nested_properties, toplevel_properties):
+        # Create an extension-definition object to be used in conjunction with STIX Indicator object       
+        return super().create_extension_sdo(identity_object, namespace, nested_properties, toplevel_properties)      
+
+    def create_indicator_sdo(self, indicator_object, identity_id, extension_id, nested_properties, top_properties=None):
+        return super().create_indicator_sdo(indicator_object, identity_id, extension_id, nested_properties, top_properties)
```

## stix_shifter_modules/reversinglabs/stix_transmission/api_client.py

```diff
@@ -1,114 +1,107 @@
 from stix_shifter_utils.stix_transmission.utils.RestApiClientAsync import RestApiClientAsync
 import json
 import hashlib
-from aiohttp import BasicAuth
-
-
+from base64 import b64encode
 class APIClient():
 
     def __init__(self, connection, configuration):
         # Uncomment when implementing data source API client.
         auth_values = configuration.get('auth')
-        auth = BasicAuth(auth_values['username'], auth_values['password'])
+        # auth = (auth_values['username'], auth_values['password'])
+        token = b64encode(f"{auth_values['username']}:{auth_values['password']}".encode('utf-8')).decode('utf-8')
         headers = dict()
         headers['Accept'] = 'application/json'
-
+        headers['Authorization'] = f'Basic {token}'
         connection['host'] = 'data.reversinglabs.com'
         url_modifier_function = None
-        self.client = RestApiClientAsync(host=connection.get('host'),
-                                    port=None,
-                                    headers=headers,
-                                    url_modifier_function=url_modifier_function,
-                                    auth=auth
-                                    )
+        self.client = RestApiClientAsync(host=connection.get('host'), port=None, headers=headers, 
+                                    url_modifier_function=url_modifier_function)
         self.connection = connection
         self.namespace = connection.get('namespace')
+        self.timeout = connection['options'].get('timeout')
 
 
     async def ping_reversinglabs(self):
 
-        endpoint = 'api/uri/statistics/uri_state/sha1/4b84b15bff6ee5796152495a230e45e3d7e947d9?format=json'
+        endpoint = '/api/uri/statistics/uri_state/sha1/4b84b15bff6ee5796152495a230e45e3d7e947d9?format=json'
         response = await self.client.call_api(endpoint, 'GET')
-        data = response.read().decode('utf-8')
+        return response.read().decode('utf-8'), response.code
 
-        return {"message": data, "code": response.code}
-
-    async def get_search_results(self, query_expression, range_start=None, range_end=None):
+    async def get_search_results(self, query_expression):
         # Return the search results. Results must be in JSON format before being translated into STIX
         # query_expression = (json.loads(query_expression))
         data_type = query_expression['dataType']
         data = query_expression['data']
         uri = get_uri_sha1(data)
 
         if data_type == 'ip' or data_type == 'domain':
             endpoint_uri_state = f'api/uri/statistics/uri_state/sha1/{uri}?format=json'
-            uri_state = await self.client.call_api(endpoint_uri_state, 'GET')
+            uri_state = await self.client.call_api(endpoint_uri_state, 'GET', timeout=self.timeout)
             json_data_uri_state = json.loads(uri_state.read().decode('utf-8')) if uri_state.code == 200 else {}
 
             if uri_state.code == 200:
                 json_data_uri_state['namespace'] = self.namespace
-                return {"message": json_data_uri_state, "code": uri_state.code}
+                return json_data_uri_state, uri_state.code
             else:
                 json_data_uri_state['error'] = uri_state.read().decode('utf-8')
                 json_data_uri_state['code'] = uri_state.code
                 json_data_uri_state['indicator_types'] = [ "unknown" ]
                 json_data_uri_state['description'] =  uri_state.read().decode('utf-8')
                 json_data_uri_state['namespace'] = self.namespace
-                return {"message": json_data_uri_state, "code": uri_state.code}
+                return json_data_uri_state, uri_state.code
 
         elif data_type == 'url':
 
             post_body = json.dumps({
                 "rl": {
                     "query": {
                         "url": data,
                         "response_format": "json"
                     }
-
                 }
             })
 
             endpoint_url = 'api/networking/url/v1/report/query/json'
-            url_response = await self.client.call_api(endpoint_url, 'POST', data = post_body)
+            url_response = await self.client.call_api(endpoint_url, 'POST', data = post_body, timeout=self.timeout)
             json_data_url = json.loads(url_response.read().decode('utf-8')) if url_response.code == 200 else {}
 
             if url_response.code == 200:
                 status_code = 200
                 json_data_url['namespace'] = self.namespace
-                return {"message": json_data_url, "code": status_code}
+                return json_data_url, status_code
 
             else:
                 json_data_url['error'] = url_response.read().decode('utf-8')
                 json_data_url['code'] = url_response.code
                 json_data_url['indicator_types'] = ["unknown"]
                 json_data_url['description'] = url_response.read().decode('utf-8')
                 json_data_url['namespace'] = self.namespace
-                return {"message": json_data_url, "code": url_response.code}
+                return json_data_url, url_response.code
 
 
         elif data_type == 'hash':
             HASH_LENGTH = {'40': 'sha1', '64': 'sha256', '32': 'md5'}
             hash_type = HASH_LENGTH.get(str(len(data)), '')
 
             endpoint_malware_presence = f'api/databrowser/malware_presence/query/{hash_type}/{data}?format=json&extended=true'
-            malware_presence = await self.client.call_api(endpoint_malware_presence, 'GET')
+            malware_presence = await self.client.call_api(endpoint_malware_presence, 'GET', timeout=self.timeout)
             json_data_malware_presence = json.loads(malware_presence.read().decode('utf-8')) if malware_presence.code == 200 else {}
 
             if malware_presence.code == 200:
                 status_code = 200
                 json_data_malware_presence['namespace'] = self.namespace
-                return {"message": json_data_malware_presence, "code": status_code}
+                return json_data_malware_presence, status_code
             else:
                 json_data_malware_presence['error'] = malware_presence.read().decode('utf-8')
                 json_data_malware_presence['code'] = malware_presence.code
                 json_data_malware_presence['indicator_types'] = ["unknown"]
                 json_data_malware_presence['description'] = malware_presence.read().decode('utf-8')
                 json_data_malware_presence['namespace'] = self.namespace
-                return {"message": json_data_malware_presence, "code": malware_presence.code}
+                return json_data_malware_presence, malware_presence.code
 
         else:
             return {"code": 401, "error": "IoC Type not supported"}
 
         # return response
 
     async def delete_search(self, search_id):
```

## stix_shifter_modules/reversinglabs/stix_transmission/delete_connector.py

```diff
@@ -5,15 +5,15 @@
 class DeleteConnector(BaseDeleteConnector):
     def __init__(self, api_client):
         self.api_client = api_client
         self.logger = logger.set_logger(__name__)
 
     async def delete_query_connection(self, search_id):
         try:
-            response_dict = await self.api_client.delete_search(search_id)
+            response_dict =await  self.api_client.delete_search(search_id)
             response_code = response_dict["code"]
 
             # Construct a response object
             return_obj = dict()
             if response_code == 200:
                 return_obj['success'] = response_dict['success']
             else:
```

## stix_shifter_modules/reversinglabs/stix_transmission/ping_connector.py

```diff
@@ -1,30 +1,27 @@
 from stix_shifter_utils.modules.base.stix_transmission.base_ping_connector import BasePingConnector
 from stix_shifter_utils.utils.error_response import ErrorResponder
 from stix_shifter_utils.utils import logger
-
+import json
 
 class PingConnector(BasePingConnector):
     def __init__(self, api_client):
         self.api_client = api_client
         self.logger = logger.set_logger(__name__)
+        self.connector = __name__.split('.')[1]
 
     async def ping_connection(self):
         try:
-            response = await self.api_client.ping_reversinglabs()
-
-            # response = json.loads(response_dict.read().decode('utf-8'))
-            # response_code = response_dict.code
-            # response_dict = {'code': 1010, 'message': 'remote system error message'} # <-- simulate error in response to test error mapping
-            # response_code = response_dict["code"]
-
-            # Construct a response object
+            response_dict, response_code = await self.api_client.ping_reversinglabs()
             return_obj = dict()
-            if response['code'] == 200:
+
+            if response_code == 200:
                 return_obj['success'] = True
+                return_obj['code'] = response_code
+                return_obj['connector'] = self.connector
             else:
-                response['message'] = 'Pinging failed'
-                ErrorResponder.fill_error(return_obj, response, ['message'], connector='reversinglabs')
+                ErrorResponder.fill_error(return_obj, response_dict, ['message'], connector=self.connector)
+                self.logger.error(return_obj)
             return return_obj
         except Exception as err:
             self.logger.error('error when pinging datasource {}:'.format(err))
             raise
```

## stix_shifter_modules/reversinglabs/stix_transmission/results_connector.py

```diff
@@ -11,50 +11,51 @@
     async def create_results_connection(self, search_id, offset, length):
         try:
             min_range = offset
             max_range = offset + length
             # print(search_id, min_range, max_range, length)
             search_id = search_id.replace('\'', "\"")
             query_json= json.loads(search_id)
-            response = await self.api_client.get_search_results(query_json)
-            response_code = response['code']
+            response, response_code = await self.api_client.get_search_results(query_json)
+            print(response)
 
             # Grab the response, extract the response code, and convert it to readable json
             # response_dict = self.api_client.get_search_results(search_id, min_range, max_range)
             # json_data = json.loads(response.read().decode('utf-8'))
             # print(type(response), response)
             # response_code = response.code
-            json_data = response['message']
+            json_data = response
 
             if "rl" in json_data.keys():
                 json_data['rl'] = [json_data['rl']]
             else:
                 rl_data = {}
                 rl_data['rl'] = [{'message': 'IOC not found'}]
                 json_data = rl_data
 
+
+
+
             # # Construct a response object
             return_obj = dict()
             if response_code == 200:
                 json_data['data'] = query_json['data']
                 json_data['dataType'] = query_json['dataType']
                 return_obj['success'] = True
                 return_obj['data'] = [json_data]
             else:
                 json_data['data'] = query_json['data']
                 json_data['dataType'] = query_json['dataType']
                 json_data['namespace'] = response['namespace']
                 return_obj['success'] = True
                 return_obj['data'] = [json_data]
 
-                ErrorResponder.fill_error(return_obj, response, ['message'], connector='reversinglabs')
-
             # else:
             #     # ErrorResponder.fill_error(return_obj, response_dict, ['message'])
             #     ErrorResponder.fill_error(return_obj, json_data)
             #     return_obj['error'] = json_data['error']
             return return_obj
         except Exception as err:
-            response['message'] = str(err)
             self.logger.error('error when getting search results: {}'.format(err))
-            ErrorResponder.fill_error(return_obj, response, ['message'], connector='reversinglabs')
+            import traceback
+            self.logger.error(traceback.print_stack())
             raise
```

## Comparing `stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/LICENSE.md` & `stix_shifter_modules_reversinglabs-5.3.0.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/METADATA` & `stix_shifter_modules_reversinglabs-5.3.0.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,67 +1,59 @@
 Metadata-Version: 2.1
 Name: stix-shifter-modules-reversinglabs
-Version: 5.2.1.dev816
+Version: 5.3.0
 Summary: Tools and interface to translate STIX formatted results and queries to different data source formats and to set up appropriate connection strings for invoking and triggering actions in openwhisk
 Home-page: https://github.com/opencybersecurityalliance/stix-shifter
 Author: ibm
 Author-email: 
 Project-URL: Source, https://github.com/opencybersecurityalliance/stix-shifter
 Keywords: datasource stix translate transform transmit
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Description-Content-Type: text/markdown
 License-File: LICENSE.md
 License-File: NOTICE
-Requires-Dist: uuid (==1.30)
 
+[![example workflow](https://github.com/opencybersecurityalliance/stix-shifter/actions/workflows/main.yml/badge.svg)](https://github.com/opencybersecurityalliance/stix-shifter/actions)
 [![codecov](https://codecov.io/gh/opencybersecurityalliance/stix-shifter/branch/develop/graph/badge.svg?token=gQvl14peRj)](https://codecov.io/gh/opencybersecurityalliance/stix-shifter)
 
-### Join us on Slack!
-
-[Click here](https://docs.google.com/forms/d/1vEAqg9SKBF3UMtmbJJ9qqLarrXN5zeVG3_obedA3DKs) and fill out the form to receive an invite to the Open Cybersecurity Alliance slack instance, then join the #stix-shifter channel, to meet and discuss usage with the team.
-
-### Introduction Webinar!
-
-[Click here](https://ibm.biz/BdzTyA) to view an introduction webinar on STIX Shifter and the use cases it solves for.
-
-### Introduction
+# Introduction to STIX-Shifter
 
 STIX-shifter is an open source python library allowing software to connect to products that house data repositories by using STIX Patterning, and return results as STIX Observations.
 
-For more information about this project, see the [STIX-shifter Overview](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/OVERVIEW.md)
+This library takes in STIX 2 Patterns as input, and "finds" data that matches the patterns inside various products that house repositories of cybersecurity data. Examples of such products include SIEM systems, endpoint management systems, threat intelligence platforms, orchestration platforms, network control points, data lakes, and more.
 
-### Dependencies
+In addition to "finding" the data by using these patterns, STIX-Shifter also _transforms the output_ into STIX 2 Observations. Why would we do that you ask? To put it simply - so that all of the security data, regardless of the source, mostly looks and behaves the same.
 
-This stix-shifter has the following dependencies:
+[## Project Overview and CLI Commands](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/OVERVIEW.md)
 
-- [stix2-patterns==1.3.0](https://pypi.org/project/stix2-patterns/)
-- [stix2-validator==1.1.2](https://pypi.org/project/stix2-validator/)
-- [stix2-matcher==1.0.0](https://pypi.org/project/stix2-matcher/)
-- [antlr4-python3-runtime==4.8](https://pypi.org/project/antlr4-python3-runtime/)
-- [python-dateutil==2.8.1](https://pypi.org/project/python-dateutil/)
+For general information about STIX, this project, and the command line utilities, see the [STIX-shifter Overview](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/OVERVIEW.md)
 
-Your development environment must use Python version: 3.8 greater
 
-## Installation
+# Installation
 
-The recommended method for installing the STIX-shifter is via pip. Two prerequisite packages needs to be installed inlcuding the package of stix-shifter connector module to complete a stix-shifter connector installation. Run below commands to install all the packages-
+The recommended method for installing stix-shifter is via pip. Two prerequisite packages needs to be installed inlcuding the package of stix-shifter connector module to complete a stix-shifter connector installation. Run the below commands to install all the packages:
 
 1. Main stix-shifter package:  `pip install stix-shifter`
 
 2. Stix-shifter Utility package:  `pip install stix-shifter-utils`
 
 3. Desired stix-shifter connector module package:  `pip install stix-shifter-modules-<module name> `
    Example:  `pip install stix-shifter-modules-qradar`
 
-## Usage
+## Dependencies
+
+STIX-shifter requries Python 3.8 or greater. See the [requirements file](stix_shifter/requirements.txt) for library dependencies. 
 
+# Usage
 
-### As A Command Line Utility
+STIX-Shifter can use used the following ways:
+
+## 1. As a command line utility
 
 The STIX-Shifter comes with a bundled script which you can use to translate STIX Pattern to a native datasource query. It can also be used to translate a JSON data source query result to a STIX bundle of observable objects. You can also send query to a datasource by using a transmission option. 
 
 More details of the command line option can be found [here](https://github.com/opencybersecurityalliance/stix-shifter/blob/master/OVERVIEW.md#how-to-use)
 
 ```
 $ stix-shifter translate <MODULE NAME> query "<STIX IDENTITY OBJECT>" "<STIX PATTERN>" "<OPTIONS>"
@@ -74,17 +66,17 @@
 In order to build `stix-shifter` packages from source follow the below prerequisite steps:
    1. Go to the stix-shifter parent directory
    2. Optionally, you can create a Python 3 virtual environemnt:
        `virtualenv -p python3 virtualenv && source virtualenv/bin/activate`
    3. Run setup: `python3 setup.py install`
 
 
-### Running From the Source
+## 2. Running from the source
 
-You may also use `python3 main.py` script. All the options are the same as "As a command line utility" usage above.
+You may also use the `python3 main.py` script. All the options are the same as the command line utility described above.
 
 Example:
 
 ```
 python3 main.py translate qradar query {} "[ipv4-addr:value = '127.0.0.1']" {}
 ```
 
@@ -92,15 +84,15 @@
    1. Go to the stix-shifter parent directory
    2. Optionally, you can create a Python 3 virtual environemnt:
        `virtualenv -p python3 virtualenv && source virtualenv/bin/activate`
    3. Run setup to install dependancies: `INSTALL_REQUIREMENTS_ONLY=1 python3 setup.py install`. 
 
 **Note:** setup.py only installs dependencies when INSTALL_REQUIREMENTS_ONLY=1 directive is used. This option is similar to `python3 generate_requirements.py && pip install -r requirements.txt`
 
-### As A Library
+## 3. As a library
 
 You can also use this library to integrate STIX Shifter into your own tools. You can translate a STIX Pattern:
 
 ```
 from stix_shifter.stix_translation import stix_translation
 
 translation = stix_translation.StixTranslation()
@@ -110,35 +102,47 @@
 ```
 ### Use of custom mappings
 
 If a connector has been installed using pip, the process for editing the STIX mappings is different than if you have pulled-down the project. When working locally, you can edit the mapping files directly. See the [mapping files for the MySQL connector](stix_shifter_modules/mysql/stix_translation/json) as an example. Editing the mapping files won't work if the connector has been installed with pip; the setup script of the stix-shifter package includes the mapppings inside `config.json`. This allows stix-shifter to injest custom mappings as part of the connector's configuration.
 
 Refer to [Use of custom mappings](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/adapter-guide/custom_mappings.md) for more details on how to edit the mappings in the configuration.
 
-## Contributing
+# Contributing
 
 We are thrilled you are considering contributing! We welcome all contributors.
-
 Please read our [guidelines for contributing](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/CONTRIBUTING.md).
 
-## Developer Guides
+## [Connector Developer Guide](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/adapter-guide/develop-stix-adapter.md)
 
-If you want to create a new connector for STIX-shifter, see the [developer guide](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/adapter-guide/develop-stix-adapter.md)
+<!-- If you want to create a new connector for STIX-shifter, see the [developer guide](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/adapter-guide/develop-stix-adapter.md) -->
 
-There are also a few [Jupyter Notebook labs](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/lab) that cover the CLI commands and dev process.
+## [Jupyter Notebook Development Labs](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/lab)
 
-## Licensing
+<!-- There are also a few [Jupyter Notebook labs](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/lab) that cover the CLI commands and dev process. -->
+
+# Licensing
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
     http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 
-## More Resources
-   - [Changelog](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/CHANGELOG.md)
+# More Resources
+
+## Join us on Slack!
+
+[Click here](https://docs.google.com/forms/d/1vEAqg9SKBF3UMtmbJJ9qqLarrXN5zeVG3_obedA3DKs) and fill out the form to receive an invite to the Open Cybersecurity Alliance slack instance, then join the #stix-shifter channel, to meet and discuss usage with the team.
+
+## Introduction Webinar!
+
+[Click here](https://ibm.biz/BdzTyA) to view an introduction webinar on STIX Shifter and the use cases it solves for.
+
+## Changelog
+
+- [Changelog](https://github.com/opencybersecurityalliance/stix-shifter/blob/develop/CHANGELOG.md)
```

## Comparing `stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/NOTICE` & `stix_shifter_modules_reversinglabs-5.3.0.dist-info/NOTICE`

 * *Files identical despite different names*

## Comparing `stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/RECORD` & `stix_shifter_modules_reversinglabs-5.3.0.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 stix_shifter_modules/reversinglabs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-stix_shifter_modules/reversinglabs/entry_point.py,sha256=f37IWeAn_N1AAi_CcEm_gBZlrLIdiQnX8eyPMJ7dExE,2166
-stix_shifter_modules/reversinglabs/configuration/config.json,sha256=Prsp_rtFM_iau7U2L6K_PzY2xUSCQh7Pwih3Q7yg4Cs,5773
+stix_shifter_modules/reversinglabs/entry_point.py,sha256=UrD7JaCikAicjisOdat5C_ub-dDxUuMllsADUMzA9t4,1952
+stix_shifter_modules/reversinglabs/configuration/config.json,sha256=5dPShzACZ6t87aPurkMs_5SimEEzzP5MsmeobIETok8,7629
 stix_shifter_modules/reversinglabs/configuration/dialects.json,sha256=tewYuoIE-WBBxsLTlOstMkMSUs6sFlEyW1dveC61xwk,78
-stix_shifter_modules/reversinglabs/configuration/lang_en.json,sha256=4Umjj3pLO4VoZDNimacZX1B5FLvfVAwVfPiwCJ1p6WE,3026
+stix_shifter_modules/reversinglabs/configuration/lang_en.json,sha256=wLyOcMUFLcJXFDxtw5F085583bCUsWaiAr8dRNRFJZU,4575
 stix_shifter_modules/reversinglabs/stix_translation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-stix_shifter_modules/reversinglabs/stix_translation/json_to_stix_translator.py,sha256=72KkjPPwPGUxxyhtYaq9CcFAOOKG_emxSqKeCnmveyw,21567
+stix_shifter_modules/reversinglabs/stix_translation/json_to_stix_translator.py,sha256=8KbNAbPFHVIw6CN4tylW35GqJ1sxBZpaxpQaFAM6e0M,22536
 stix_shifter_modules/reversinglabs/stix_translation/query_constructor.py,sha256=TVFyOrsTdUowXN-yqVlQJ2avvM4VBEBVtVXPTyES-Ko,11237
 stix_shifter_modules/reversinglabs/stix_translation/query_translator.py,sha256=1IsBlz_YYM9s0myfyed9Wy0fqkV82k77UXd_fTEE38w,1029
-stix_shifter_modules/reversinglabs/stix_translation/results_translator.py,sha256=JCHgLVLYKpJUhvUBCL2aYfkSHa5W6U2qq2dKXlA-TJo,13838
-stix_shifter_modules/reversinglabs/stix_translation/sdo_translator.py,sha256=X51pxmvpE6b3rWLWxcAL2F_ro3ihpuZgiNpO7FYSyfc,130
+stix_shifter_modules/reversinglabs/stix_translation/results_translator.py,sha256=Do7nfpQZfIyM_jCc43VuolRXXSMrcyXuEMkc9ASmpIk,18762
+stix_shifter_modules/reversinglabs/stix_translation/sdo_translator.py,sha256=mQ9feFH8J44N9r1WC38uNDFa36oKRt-t3pzkacreenc,1354
 stix_shifter_modules/reversinglabs/stix_translation/json/from_stix_map.json,sha256=-UJEIZCQlv-_oB2lRT-f6YB502Say9IfHi845aPwXXw,498
 stix_shifter_modules/reversinglabs/stix_translation/json/operators.json,sha256=vpVJifC1l94MGrRbJxej7YK6h7XdRb3zz1RRBGdgg3U,598
 stix_shifter_modules/reversinglabs/stix_translation/json/to_stix_map.json,sha256=e4m4NVH_lCk64JOyWsggUkysLi432jcEekqO0hMpgdk,6
 stix_shifter_modules/reversinglabs/stix_transmission/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-stix_shifter_modules/reversinglabs/stix_transmission/api_client.py,sha256=iUm1UbDmSvz5Ns7o3HuAlUyA3YhVrtRto8jc7cIzyRY,5615
-stix_shifter_modules/reversinglabs/stix_transmission/delete_connector.py,sha256=q6a1nsLmQaIkTdIjo6_HX997FE-GXnvX6PCSImxf1Pc,1012
+stix_shifter_modules/reversinglabs/stix_transmission/api_client.py,sha256=6Tjg3fN_wgYmRgiMUO-jwpRZ7hY_ghHdyD7bWyfXX-s,5539
+stix_shifter_modules/reversinglabs/stix_transmission/delete_connector.py,sha256=eB1TNi468bnt1NL-T1a9KKIGJ9DQGim2wJtC1VKzxa0,1012
 stix_shifter_modules/reversinglabs/stix_transmission/error_mapper.py,sha256=D6Ie1eEPddxDL1tjX-lsO3S_v1eFEkUnIjhF1p3cOZQ,1845
-stix_shifter_modules/reversinglabs/stix_transmission/ping_connector.py,sha256=pTWF7kH2Q40s1-azfncef6Lezq8EHruBgugKNwPnTXw,1307
-stix_shifter_modules/reversinglabs/stix_transmission/results_connector.py,sha256=E-kMi6-JhHwwjXFCArUN5wc3Z_4GsFA3Px-2st-3gvw,2752
-stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/LICENSE.md,sha256=ssGEKMVW69oFTBblVhD1YPolqCOyOCJi4wRDRI7xCnU,12786
-stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/METADATA,sha256=zdR-eAMOe58O4gpAiOyQmuACsqsqHR-6DVxfRLI8r3w,7128
-stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/NOTICE,sha256=wx-gWE9vSnLJ7YQkrGlMp9VNXOXG57TTxDDRd9CEdYg,1418
-stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
-stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/top_level.txt,sha256=NX-VgUOr8fI-lMXHt3gtjfsEn1UPaGAVszt6Z_CTp2s,21
-stix_shifter_modules_reversinglabs-5.2.1.dev816.dist-info/RECORD,,
+stix_shifter_modules/reversinglabs/stix_transmission/ping_connector.py,sha256=mE2hvi97_X2nqovSmUy28hzkulN3fJTxtx-6GsC1MkA,1126
+stix_shifter_modules/reversinglabs/stix_transmission/results_connector.py,sha256=WctbXwDAgYo4qZ2_a1OjlHIHpIiVfv7LMu51ySz6tXo,2578
+stix_shifter_modules_reversinglabs-5.3.0.dist-info/LICENSE.md,sha256=ssGEKMVW69oFTBblVhD1YPolqCOyOCJi4wRDRI7xCnU,12786
+stix_shifter_modules_reversinglabs-5.3.0.dist-info/METADATA,sha256=ADkYfNQPaJlgzY5cv_DJptmmiR5ktAIk5nAoRvErU6Q,8043
+stix_shifter_modules_reversinglabs-5.3.0.dist-info/NOTICE,sha256=wx-gWE9vSnLJ7YQkrGlMp9VNXOXG57TTxDDRd9CEdYg,1418
+stix_shifter_modules_reversinglabs-5.3.0.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
+stix_shifter_modules_reversinglabs-5.3.0.dist-info/top_level.txt,sha256=NX-VgUOr8fI-lMXHt3gtjfsEn1UPaGAVszt6Z_CTp2s,21
+stix_shifter_modules_reversinglabs-5.3.0.dist-info/RECORD,,
```

