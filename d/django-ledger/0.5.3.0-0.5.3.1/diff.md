# Comparing `tmp/django_ledger-0.5.3.0-py3-none-any.whl.zip` & `tmp/django_ledger-0.5.3.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,9 +1,9 @@
-Zip file size: 2639054 bytes, number of entries: 331
--rw-r--r--  2.0 unx      458 b- defN 23-May-08 16:34 django_ledger/__init__.py
+Zip file size: 2642161 bytes, number of entries: 331
+-rw-r--r--  2.0 unx      458 b- defN 23-May-16 16:43 django_ledger/__init__.py
 -rw-r--r--  2.0 unx     3723 b- defN 22-Oct-21 23:13 django_ledger/admin.py
 -rw-r--r--  2.0 unx      163 b- defN 22-Oct-18 09:39 django_ledger/apps.py
 -rw-r--r--  2.0 unx      491 b- defN 23-May-06 18:26 django_ledger/exceptions.py
 -rw-r--r--  2.0 unx     5964 b- defN 23-May-08 16:33 django_ledger/settings.py
 -rw-r--r--  2.0 unx     5064 b- defN 22-Nov-18 00:44 django_ledger/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-18 09:39 django_ledger/contrib/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/__init__.py
@@ -58,47 +58,47 @@
 -rw-r--r--  2.0 unx     1178 b- defN 22-Oct-18 09:39 django_ledger/forms/ledger.py
 -rw-r--r--  2.0 unx     7479 b- defN 22-Oct-21 23:13 django_ledger/forms/purchase_order.py
 -rw-r--r--  2.0 unx     3075 b- defN 23-May-06 18:26 django_ledger/forms/transactions.py
 -rw-r--r--  2.0 unx     1131 b- defN 22-Oct-21 23:13 django_ledger/forms/unit.py
 -rw-r--r--  2.0 unx      513 b- defN 22-Oct-18 09:39 django_ledger/forms/utils.py
 -rw-r--r--  2.0 unx     2215 b- defN 23-May-06 18:26 django_ledger/forms/vendor.py
 -rw-r--r--  2.0 unx      322 b- defN 22-Oct-18 09:39 django_ledger/io/__init__.py
--rw-r--r--  2.0 unx    33115 b- defN 23-May-06 18:26 django_ledger/io/data_generator.py
+-rw-r--r--  2.0 unx    32043 b- defN 23-May-16 16:43 django_ledger/io/data_generator.py
 -rw-r--r--  2.0 unx    19213 b- defN 23-May-06 18:26 django_ledger/io/io_context.py
 -rw-r--r--  2.0 unx    19863 b- defN 23-May-06 18:26 django_ledger/io/io_mixin.py
 -rw-r--r--  2.0 unx     1488 b- defN 22-Oct-18 09:39 django_ledger/io/ofx.py
 -rw-r--r--  2.0 unx     3568 b- defN 22-Oct-18 09:39 django_ledger/io/ratios.py
--rw-r--r--  2.0 unx    19348 b- defN 23-May-06 18:26 django_ledger/io/roles.py
+-rw-r--r--  2.0 unx    19806 b- defN 23-May-16 16:43 django_ledger/io/roles.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jan-11 14:51 django_ledger/management/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jan-11 14:51 django_ledger/management/commands/__init__.py
 -rw-r--r--  2.0 unx     1495 b- defN 23-Jan-11 18:26 django_ledger/management/commands/generate_oauth2_codes.py
 -rw-r--r--  2.0 unx    74729 b- defN 22-Dec-27 23:22 django_ledger/migrations/0001_initial.py
 -rw-r--r--  2.0 unx      703 b- defN 23-Jan-09 17:12 django_ledger/migrations/0002_alter_journalentrymodel_managers_and_more.py
 -rw-r--r--  2.0 unx     6069 b- defN 23-Feb-04 16:10 django_ledger/migrations/0003_remove_accountmodel_django_ledg_role_1bff96_idx_and_more.py
 -rw-r--r--  2.0 unx      586 b- defN 23-Feb-10 19:09 django_ledger/migrations/0004_remove_itemmodel_depth_remove_itemmodel_numchild_and_more.py
 -rw-r--r--  2.0 unx     1569 b- defN 23-Feb-15 14:27 django_ledger/migrations/0005_remove_itemmodel_django_ledg_invento_dbf206_idx_and_more.py
 -rw-r--r--  2.0 unx      749 b- defN 23-Feb-17 19:45 django_ledger/migrations/0006_alter_journalentrymodel_je_number_and_more.py
 -rw-r--r--  2.0 unx     4027 b- defN 23-May-06 18:26 django_ledger/migrations/0007_remove_customermodel_django_ledg_custome_16f95a_idx_and_more.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Dec-27 23:22 django_ledger/migrations/__init__.py
 -rw-r--r--  2.0 unx      745 b- defN 23-Jan-09 16:38 django_ledger/models/__init__.py
--rw-r--r--  2.0 unx    25403 b- defN 23-May-06 18:26 django_ledger/models/accounts.py
+-rw-r--r--  2.0 unx    25495 b- defN 23-May-16 16:43 django_ledger/models/accounts.py
 -rw-r--r--  2.0 unx     7658 b- defN 23-May-06 18:26 django_ledger/models/bank_account.py
--rw-r--r--  2.0 unx    57733 b- defN 23-May-08 15:46 django_ledger/models/bill.py
+-rw-r--r--  2.0 unx    57805 b- defN 23-May-16 16:43 django_ledger/models/bill.py
 -rw-r--r--  2.0 unx    12561 b- defN 23-May-06 18:26 django_ledger/models/coa.py
--rw-r--r--  2.0 unx    27087 b- defN 23-May-06 18:26 django_ledger/models/coa_default.py
+-rw-r--r--  2.0 unx    27169 b- defN 23-May-16 16:43 django_ledger/models/coa_default.py
 -rw-r--r--  2.0 unx    12057 b- defN 23-May-06 18:26 django_ledger/models/customer.py
 -rw-r--r--  2.0 unx     3485 b- defN 22-Oct-18 09:39 django_ledger/models/data_import.py
--rw-r--r--  2.0 unx    70525 b- defN 23-May-08 16:00 django_ledger/models/entity.py
--rw-r--r--  2.0 unx    53553 b- defN 23-May-06 18:26 django_ledger/models/estimate.py
--rw-r--r--  2.0 unx    54335 b- defN 23-May-08 15:46 django_ledger/models/invoice.py
--rw-r--r--  2.0 unx    55542 b- defN 23-May-06 18:26 django_ledger/models/items.py
+-rw-r--r--  2.0 unx    95834 b- defN 23-May-16 16:43 django_ledger/models/entity.py
+-rw-r--r--  2.0 unx    54011 b- defN 23-May-16 16:43 django_ledger/models/estimate.py
+-rw-r--r--  2.0 unx    54407 b- defN 23-May-16 16:43 django_ledger/models/invoice.py
+-rw-r--r--  2.0 unx    53358 b- defN 23-May-16 16:43 django_ledger/models/items.py
 -rw-r--r--  2.0 unx    44797 b- defN 23-May-06 18:26 django_ledger/models/journal_entry.py
 -rw-r--r--  2.0 unx    10730 b- defN 23-May-06 18:26 django_ledger/models/ledger.py
--rw-r--r--  2.0 unx    46220 b- defN 23-May-08 13:03 django_ledger/models/mixins.py
--rw-r--r--  2.0 unx    40708 b- defN 23-May-06 18:26 django_ledger/models/purchase_order.py
+-rw-r--r--  2.0 unx    46279 b- defN 23-May-16 16:43 django_ledger/models/mixins.py
+-rw-r--r--  2.0 unx    41344 b- defN 23-May-16 16:43 django_ledger/models/purchase_order.py
 -rw-r--r--  2.0 unx    19622 b- defN 23-May-06 18:26 django_ledger/models/transactions.py
 -rw-r--r--  2.0 unx     7962 b- defN 23-Feb-10 22:26 django_ledger/models/unit.py
 -rw-r--r--  2.0 unx     5193 b- defN 23-May-06 18:26 django_ledger/models/utils.py
 -rw-r--r--  2.0 unx    11361 b- defN 23-May-06 18:26 django_ledger/models/vendor.py
 -rw-r--r--  2.0 unx      157 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/__init__.py
 -rw-r--r--  2.0 unx     1077 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/digest.py
 -rw-r--r--  2.0 unx      958 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/net_payable.py
@@ -268,16 +268,16 @@
 -rw-r--r--  2.0 unx     1341 b- defN 22-Nov-14 16:22 django_ledger/templates/django_ledger/vendor/vendor_update.html
 -rw-r--r--  2.0 unx     1290 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/vendor/includes/card_vendor.html
 -rw-r--r--  2.0 unx     3400 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/vendor/tags/vendor_table.html
 -rw-r--r--  2.0 unx      205 b- defN 22-Oct-18 09:39 django_ledger/templatetags/__init__.py
 -rw-r--r--  2.0 unx    30805 b- defN 23-May-08 15:56 django_ledger/templatetags/django_ledger.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-18 09:39 django_ledger/tests/__init__.py
 -rw-r--r--  2.0 unx     4585 b- defN 23-May-08 12:50 django_ledger/tests/base.py
--rw-r--r--  2.0 unx     3059 b- defN 22-Oct-18 09:39 django_ledger/tests/test_auth.py
--rw-r--r--  2.0 unx    18178 b- defN 23-May-08 16:12 django_ledger/tests/test_bill.py
+-rw-r--r--  2.0 unx     3059 b- defN 23-May-16 16:43 django_ledger/tests/test_auth.py
+-rw-r--r--  2.0 unx    18194 b- defN 23-May-16 16:43 django_ledger/tests/test_bill.py
 -rw-r--r--  2.0 unx    12180 b- defN 23-May-06 18:26 django_ledger/tests/test_entity.py
 -rw-r--r--  2.0 unx     8595 b- defN 23-May-07 03:01 django_ledger/tests/test_purchase_order.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-18 09:39 django_ledger/tests/bdd/__init__.py
 -rw-r--r--  2.0 unx      599 b- defN 22-Oct-18 09:39 django_ledger/tests/bdd/features/steps/README.py
 -rw-r--r--  2.0 unx     1905 b- defN 23-Jan-11 00:55 django_ledger/urls/__init__.py
 -rw-r--r--  2.0 unx     1310 b- defN 23-Feb-03 12:23 django_ledger/urls/account.py
 -rw-r--r--  2.0 unx      230 b- defN 22-Oct-18 09:39 django_ledger/urls/auth.py
@@ -306,28 +306,28 @@
 -rw-r--r--  2.0 unx      771 b- defN 22-Oct-18 09:39 django_ledger/views/auth.py
 -rw-r--r--  2.0 unx     5172 b- defN 23-Feb-08 23:43 django_ledger/views/bank_account.py
 -rw-r--r--  2.0 unx    23049 b- defN 23-May-08 15:55 django_ledger/views/bill.py
 -rw-r--r--  2.0 unx     1704 b- defN 23-Feb-09 00:02 django_ledger/views/coa.py
 -rw-r--r--  2.0 unx     3668 b- defN 23-Feb-08 23:43 django_ledger/views/customer.py
 -rw-r--r--  2.0 unx    10554 b- defN 22-Nov-14 14:57 django_ledger/views/data_import.py
 -rw-r--r--  2.0 unx     4322 b- defN 22-Dec-27 00:20 django_ledger/views/djl_api.py
--rw-r--r--  2.0 unx    16074 b- defN 23-Feb-15 14:27 django_ledger/views/entity.py
+-rw-r--r--  2.0 unx    16066 b- defN 23-May-16 16:43 django_ledger/views/entity.py
 -rw-r--r--  2.0 unx    12833 b- defN 23-Feb-08 23:43 django_ledger/views/estimate.py
 -rw-r--r--  2.0 unx     2460 b- defN 22-Oct-21 23:13 django_ledger/views/feedback.py
 -rw-r--r--  2.0 unx     1365 b- defN 22-Oct-21 23:13 django_ledger/views/home.py
--rw-r--r--  2.0 unx     5020 b- defN 23-Feb-15 14:27 django_ledger/views/inventory.py
+-rw-r--r--  2.0 unx     4812 b- defN 23-May-16 16:43 django_ledger/views/inventory.py
 -rw-r--r--  2.0 unx    20253 b- defN 23-Feb-10 19:09 django_ledger/views/invoice.py
--rw-r--r--  2.0 unx    21278 b- defN 23-Feb-15 14:27 django_ledger/views/item.py
+-rw-r--r--  2.0 unx    21343 b- defN 23-May-16 16:43 django_ledger/views/item.py
 -rw-r--r--  2.0 unx    10774 b- defN 23-May-06 18:26 django_ledger/views/journal_entry.py
 -rw-r--r--  2.0 unx     8628 b- defN 23-Feb-15 14:27 django_ledger/views/ledger.py
 -rw-r--r--  2.0 unx    17325 b- defN 23-May-08 12:23 django_ledger/views/mixins.py
 -rw-r--r--  2.0 unx    21078 b- defN 23-May-07 03:06 django_ledger/views/purchase_order.py
 -rw-r--r--  2.0 unx      206 b- defN 23-Feb-15 14:27 django_ledger/views/transactions.py
 -rw-r--r--  2.0 unx     9501 b- defN 23-Feb-15 14:27 django_ledger/views/unit.py
 -rw-r--r--  2.0 unx     3457 b- defN 23-Feb-08 23:43 django_ledger/views/vendor.py
--rw-r--r--  2.0 unx      713 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/AUTHORS.md
--rw-r--r--  2.0 unx    35148 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/LICENSE
--rw-r--r--  2.0 unx    11091 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       26 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    36443 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/RECORD
-331 files, 5043134 bytes uncompressed, 2578464 bytes compressed:  48.9%
+-rw-r--r--  2.0 unx      713 b- defN 23-May-16 16:45 django_ledger-0.5.3.1.dist-info/AUTHORS.md
+-rw-r--r--  2.0 unx    35148 b- defN 23-May-16 16:45 django_ledger-0.5.3.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx    11045 b- defN 23-May-16 16:45 django_ledger-0.5.3.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-16 16:45 django_ledger-0.5.3.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       26 b- defN 23-May-16 16:45 django_ledger-0.5.3.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    36443 b- defN 23-May-16 16:45 django_ledger-0.5.3.1.dist-info/RECORD
+331 files, 5066935 bytes uncompressed, 2581571 bytes compressed:  49.1%
```

## zipnote {}

```diff
@@ -969,26 +969,26 @@
 
 Filename: django_ledger/views/unit.py
 Comment: 
 
 Filename: django_ledger/views/vendor.py
 Comment: 
 
-Filename: django_ledger-0.5.3.0.dist-info/AUTHORS.md
+Filename: django_ledger-0.5.3.1.dist-info/AUTHORS.md
 Comment: 
 
-Filename: django_ledger-0.5.3.0.dist-info/LICENSE
+Filename: django_ledger-0.5.3.1.dist-info/LICENSE
 Comment: 
 
-Filename: django_ledger-0.5.3.0.dist-info/METADATA
+Filename: django_ledger-0.5.3.1.dist-info/METADATA
 Comment: 
 
-Filename: django_ledger-0.5.3.0.dist-info/WHEEL
+Filename: django_ledger-0.5.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: django_ledger-0.5.3.0.dist-info/top_level.txt
+Filename: django_ledger-0.5.3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: django_ledger-0.5.3.0.dist-info/RECORD
+Filename: django_ledger-0.5.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## django_ledger/__init__.py

```diff
@@ -5,14 +5,14 @@
 Contributions to this module:
     * Miguel Sanda <msanda@arrobalytics.com>
 """
 
 default_app_config = 'django_ledger.apps.DjangoLedgerConfig'
 
 """Django Ledger"""
-__version__ = '0.5.3.0'
+__version__ = '0.5.3.1'
 __license__ = 'GPLv3 License'
 
 __author__ = 'Miguel Sanda'
 __email__ = 'msanda@arrobalytics.com'
 
 __url__ = 'https://www.djangoledger.com'
```

## django_ledger/io/data_generator.py

```diff
@@ -7,26 +7,26 @@
 """
 
 from datetime import date, timedelta
 from decimal import Decimal
 from itertools import groupby
 from random import randint, random, choice, choices
 from string import ascii_uppercase
-from typing import Union
+from typing import Union, Optional
 
 from django.core.exceptions import ImproperlyConfigured, ValidationError
 from django.utils.timezone import localtime, localdate
 
 from django_ledger.io.roles import (INCOME_OPERATIONAL, ASSET_CA_INVENTORY, COGS, ASSET_CA_CASH, ASSET_CA_PREPAID,
                                     LIABILITY_CL_DEFERRED_REVENUE, EXPENSE_OPERATIONAL, EQUITY_CAPITAL,
                                     ASSET_CA_RECEIVABLES, LIABILITY_CL_ACC_PAYABLE)
-from django_ledger.models import (EntityModel, TransactionModel, AccountModel, VendorModel, CustomerModel,
+from django_ledger.models import (EntityModel, TransactionModel, VendorModel, CustomerModel,
                                   EntityUnitModel, BankAccountModel, LedgerModel, UnitOfMeasureModel, ItemModel,
-                                  BillModel, ItemTransactionModel, PurchaseOrderModel, InvoiceModel,
-                                  EstimateModel, LoggingMixIn, InvoiceModelValidationError)
+                                  BillModel, ItemTransactionModel, InvoiceModel,
+                                  EstimateModel, LoggingMixIn, InvoiceModelValidationError, ChartOfAccountModel)
 from django_ledger.utils import (generate_random_sku, generate_random_upc, generate_random_item_id)
 
 try:
     from faker import Faker
     from faker.providers import company, address, phone_number, bank
 
     FAKER_IMPORTED = True
@@ -60,14 +60,15 @@
         self.local_date = localdate()
         self.tx_quantity = tx_quantity
         self.localtime = localtime()
         self.COUNT_INVENTORY = True
         self.DAYS_FORWARD = days_forward
 
         self.entity_model: EntityModel = entity_model
+        self.default_coa: Optional[ChartOfAccountModel] = None
         self.capital_contribution = capital_contribution
         self.user_model = user_model
 
         self.is_accruable_probability = 0.2
         self.is_paid_probability = 0.90
 
         self.vendor_models = None
@@ -106,23 +107,16 @@
 
         if txs_qs.count() > 0:
             raise ValidationError(
                 f'Cannot populate random data on {self.entity_model.name} because it already has existing Transactions')
 
         self.create_coa()
         self.logger.info(f'Pulling Entity {self.entity_model} accounts...')
-        self.account_models = AccountModel.objects.for_entity_available(
-            entity_slug=self.entity_model,
-            user_model=self.user_model
-        ).order_by('role')
-
-        self.accounts_by_role = {
-            g: list(v) for g, v in groupby(self.account_models, key=lambda a: a.role)
-        }
-
+        self.account_models = self.entity_model.get_coa_accounts(order_by=('role', 'code'))
+        self.accounts_by_role = {g: list(v) for g, v in groupby(self.account_models, key=lambda a: a.role)}
         self.create_vendors()
         self.create_customers()
         self.create_entity_units()
         self.create_bank_accounts()
         self.create_uom_models()
 
         self.create_products()
@@ -151,14 +145,20 @@
             self.MIN_DAYS_FORWARD,
             self.MAX_DAYS_FORWARD
         ))
         if next_date > self.local_date:
             next_date = self.local_date
         return next_date
 
+    def create_coa(self):
+        entity_model = self.entity_model
+        coa_model = entity_model.create_chart_of_accounts(assign_as_default=True, commit=True)
+        entity_model.populate_default_coa(coa_model=coa_model, activate_accounts=True)
+        self.default_coa = entity_model.default_coa
+
     def create_entity_units(self, nb_units: int = None):
         self.logger.info(f'Creating entity units...')
         nb_units = self.NB_UNITS if not nb_units else nb_units
 
         if nb_units:
             assert nb_units >= 0, 'Number of unite must be greater than 0'
 
@@ -176,105 +176,120 @@
 
         self.entity_unit_models = self.entity_model.entityunitmodel_set.all()
 
     def create_vendors(self):
         self.logger.info('Creating vendors...')
         vendor_count = randint(10, 20)
         vendor_models = [
-            VendorModel(
-                vendor_name=self.fk.name() if random() > .7 else self.fk.company(),
-                entity_model=self.entity_model,
-                address_1=self.fk.street_address(),
-                address_2=self.fk.building_number() if random() < .2 else None,
-                city=self.fk.city(),
-                state=self.fk.state_abbr(),
-                zip_code=self.fk.postcode(),
-                phone=self.fk.phone_number(),
-                country=self.COUNTRY,
-                email=self.fk.email(),
-                website=self.fk.url(),
-                active=True,
-                hidden=False,
-                description='A cool vendor description.'
-            ) for _ in range(vendor_count)
+            self.entity_model.create_vendor(
+                vendor_model_kwargs={
+                    'vendor_name': self.fk.name() if random() > .7 else self.fk.company(),
+                    'address_1': self.fk.street_address(),
+                    'address_2': self.fk.building_number() if random() < .2 else None,
+                    'city': self.fk.city(),
+                    'state': self.fk.state_abbr(),
+                    'zip_code': self.fk.postcode(),
+                    'phone': self.fk.phone_number(),
+                    'country': self.COUNTRY,
+                    'email': self.fk.email(),
+                    'website': self.fk.url(),
+                    'active': True,
+                    'hidden': False,
+                    'description': 'A cool vendor description.'
+                }, commit=False) for _ in range(vendor_count)
         ]
 
         for vendor in vendor_models:
             vendor.full_clean()
 
         self.vendor_models = VendorModel.objects.bulk_create(vendor_models, ignore_conflicts=True)
 
     def create_customers(self):
         self.logger.info(f'Creating entity customers...')
         customer_count = randint(10, 20)
         customer_models = [
-            CustomerModel(
-                customer_name=self.fk.name() if random() > .2 else self.fk.company(),
-                entity_model=self.entity_model,
-                address_1=self.fk.street_address() + self.fk.street_suffix(),
-                address_2=self.fk.building_number() if random() > .2 else None,
-                city=self.fk.city(),
-                state=self.fk.state_abbr(),
-                zip_code=self.fk.postcode(),
-                country=self.COUNTRY,
-                phone=self.fk.phone_number(),
-                email=self.fk.email(),
-                website=self.fk.url(),
-                active=True,
-                hidden=False,
-                description=f'A cool customer description. We love customers!'
-            ) for _ in range(customer_count)
+            self.entity_model.create_customer(
+                customer_model_kwargs={
+                    'customer_name': self.fk.name() if random() > .2 else self.fk.company(),
+                    'address_1': self.fk.street_address() + self.fk.street_suffix(),
+                    'address_2': self.fk.building_number() if random() > .2 else None,
+                    'city': self.fk.city(),
+                    'state': self.fk.state_abbr(),
+                    'zip_code': self.fk.postcode(),
+                    'country': self.COUNTRY,
+                    'phone': self.fk.phone_number(),
+                    'email': self.fk.email(),
+                    'website': self.fk.url(),
+                    'active': True,
+                    'hidden': False,
+                    'description': f'A cool customer description. We love customers!'
+                }) for _ in range(customer_count)
         ]
 
         for customer in customer_models:
             customer.full_clean()
 
         self.customer_models = CustomerModel.objects.bulk_create(customer_models, ignore_conflicts=True)
 
     def create_bank_accounts(self):
         self.logger.info(f'Creating entity accounts...')
         bank_account_models = [
-            BankAccountModel(name=f'{self.entity_model.name} Checking Account',
-                             account_number=self.fk.bban(),
-                             routing_number=self.fk.swift11(),
-                             aba_number=self.fk.swift(),
-                             account_type='checking',
-                             active=True,
-                             cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
-                             entity_model=self.entity_model),
-            BankAccountModel(name=f'{self.entity_model.name} Savings Account',
-                             account_number=self.fk.bban(),
-                             routing_number=self.fk.swift11(),
-                             aba_number=self.fk.swift(),
-                             active=True,
-                             account_type='savings',
-                             cash_account=choice(self.accounts_by_role['asset_ca_cash']),
-                             entity_model=self.entity_model),
+            self.entity_model.create_bank_account(
+                name=f'{self.entity_model.name} Checking Account',
+                account_type=BankAccountModel.ACCOUNT_CHECKING,
+                active=True,
+                cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
+                bank_account_model_kwargs={
+                    'aba_number': self.fk.swift(),
+                    'routing_number': str(randint(0, 9999999)).zfill(9),
+                    'account_number': str(randint(0, 9999999)).zfill(9)
+                },
+                commit=False
+            ),
+            self.entity_model.create_bank_account(
+                name=f'{self.entity_model.name} Savings Account',
+                account_type=BankAccountModel.ACCOUNT_SAVINGS,
+                active=True,
+                cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
+                bank_account_model_kwargs={
+                    'aba_number': self.fk.swift(),
+                    'routing_number': str(randint(0, 9999999)).zfill(9),
+                    'account_number': str(randint(0, 9999999)).zfill(9)
+                },
+                commit=False
+            )
         ]
         for ba in bank_account_models:
-            ba.clean()
+            ba.full_clean()
 
         self.bank_account_models = BankAccountModel.objects.bulk_create(bank_account_models, ignore_conflicts=True)
 
     def create_uom_models(self):
         self.logger.info(f'Creating entity Unit of Measures...')
+
         UOMs = {
             'unit': 'Unit',
-            'ln.ft': 'Linear Feet',
-            'sq.ft': 'Square Feet',
+            'ln-ft': 'Linear Feet',
+            'sq-ft': 'Square Fee t',
             'lb': 'Pound',
             'pallet': 'Pallet',
             'man-hour': 'Man Hour'
         }
 
         uom_models = [
-            UnitOfMeasureModel(unit_abbr=abbr,
-                               entity=self.entity_model,
-                               name=name) for abbr, name in UOMs.items()
+            self.entity_model.create_uom(
+                unit_abbr=abbr,
+                name=name,
+                commit=False
+            ) for abbr, name in UOMs.items()
         ]
+
+        for uom in uom_models:
+            uom.full_clean()
+
         self.uom_models = UnitOfMeasureModel.objects.bulk_create(uom_models)
 
     def create_products(self):
         self.logger.info(f'Creating entity product items...')
         product_count = randint(self.PRODUCTS_MIN, self.PRODUCTS_MAX)
         product_models = list()
         for i in range(product_count):
@@ -323,42 +338,14 @@
 
         for service in service_item_models:
             service.full_clean()
 
         ItemModel.objects.bulk_create(service_item_models)
         self.update_services()
 
-    def update_products(self):
-        self.logger.info(f'Updating product catalog...')
-        self.product_models = ItemModel.objects.products(
-            entity_slug=self.entity_model.slug,
-            user_model=self.user_model
-        )
-
-    def update_services(self):
-        self.logger.info(f'Updating service catalog...')
-        self.service_models = ItemModel.objects.services(
-            entity_slug=self.entity_model.slug,
-            user_model=self.user_model
-        )
-
-    def update_inventory(self):
-        self.logger.info(f'Updating inventory...')
-        self.inventory_models = ItemModel.objects.inventory_all(
-            entity_slug=self.entity_model.slug,
-            user_model=self.user_model
-        )
-
-    def update_expenses(self):
-        self.logger.info(f'Updating expenses...')
-        self.expense_models = ItemModel.objects.expenses(
-            entity_slug=self.entity_model.slug,
-            user_model=self.user_model
-        )
-
     def create_expenses(self):
         self.logger.info(f'Creating entity expense items...')
         expense_count = randint(self.PRODUCTS_MIN, self.PRODUCTS_MAX)
         expense_models = [
             ItemModel(
                 name=f'Expense Item {randint(1000, 9999)}',
                 uom=choice(self.uom_models),
@@ -402,25 +389,38 @@
         ]
 
         for inv in inventory_models:
             inv.full_clean()
 
         self.inventory_models = ItemModel.objects.bulk_create(inventory_models)
 
+    def update_products(self):
+        self.logger.info(f'Updating product catalog...')
+        self.product_models = self.entity_model.get_items_products()
+
+    def update_services(self):
+        self.logger.info(f'Updating service catalog...')
+        self.service_models = self.entity_model.get_items_services()
+
+    def update_inventory(self):
+        self.logger.info(f'Updating inventory...')
+        self.inventory_models = self.entity_model.get_items_inventory()
+
+    def update_expenses(self):
+        self.logger.info(f'Updating expenses...')
+        self.expense_models = self.entity_model.get_items_expenses()
+
     def create_estimate(self, date_draft: date):
-        estimate_model: EstimateModel = EstimateModel(
-            terms=choice(EstimateModel.CONTRACT_TERMS)[0],
-            title=f'Customer Estimate {date_draft}',
-            date_draft=date_draft
+        estimate_model = self.entity_model.create_estimate(
+            estimate_title=f'Customer Estimate {date_draft}',
+            date_draft=date_draft,
+            customer_model=choice(self.customer_models),
+            contract_terms=choice(EstimateModel.CONTRACT_TERMS_CHOICES_VALID),
+            commit=True
         )
-        estimate_model.configure(entity_slug=self.entity_model,
-                                 user_model=self.user_model,
-                                 customer_model=choice(self.customer_models))
-
-        estimate_model.save()
         self.logger.info(f'Creating entity estimate {estimate_model.estimate_number}...')
 
         estimate_items = [
             ItemTransactionModel(
                 ce_model=estimate_model,
                 item_model=choice(self.product_models),
                 ce_quantity=round(random() * randint(5, 15), 2),
@@ -451,34 +451,26 @@
                 elif random() > 0.8:
                     date_void = self.get_next_date(date_approved)
                     estimate_model.mark_as_void(commit=True, date_void=date_void)
             elif random() > 0.8:
                 date_canceled = self.get_next_date(date_in_review)
                 estimate_model.mark_as_canceled(commit=True, date_canceled=date_canceled)
 
-    def create_bill(self, date_draft):
-        bill_model: BillModel = BillModel(
-            vendor=choice(self.vendor_models),
-            progress=Decimal(str(round(random(), 2))),
-            terms=choice(BillModel.TERM_CHOICES)[0],
-            amount_due=0,
+    def create_bill(self, date_draft: date):
+        bill_model = self.entity_model.create_bill(
+            vendor_model=choice(self.vendor_models),
             cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
             prepaid_account=choice(self.accounts_by_role[ASSET_CA_PREPAID]),
-            unearned_account=choice(self.accounts_by_role[LIABILITY_CL_ACC_PAYABLE]),
+            payable_account=choice(self.accounts_by_role[LIABILITY_CL_ACC_PAYABLE]),
+            terms=choice(BillModel.TERM_CHOICES_VALID),
             date_draft=date_draft,
-            additional_info=dict()
+            additional_info=dict(),
+            commit=True
         )
 
-        ledger_model, bill_model = bill_model.configure(
-            entity_slug=self.entity_model,
-            user_model=self.user_model,
-            commit_ledger=True)
-
-        bill_model.full_clean()
-        bill_model.save()
         self.logger.info(f'Creating entity bill {bill_model.bill_number}...')
 
         bill_items = [
             ItemTransactionModel(
                 bill_model=bill_model,
                 item_model=choice(self.expense_models),
                 quantity=round(random() * randint(5, 15), 2),
@@ -523,18 +515,16 @@
                         commit=True
                     )
             elif random() > 0.8:
                 canceled_date = self.get_next_date(date_in_review)
                 bill_model.mark_as_canceled(date_canceled=canceled_date)
 
     def create_po(self, date_draft: date):
-        po_model: PurchaseOrderModel = PurchaseOrderModel(date_draft=date_draft)
-        po_model = po_model.configure(entity_slug=self.entity_model, user_model=self.user_model)
-        po_model.po_title = f'PO Title for {po_model.po_number}'
-        po_model.save()
+
+        po_model = self.entity_model.create_purchase_order(date_draft=date_draft)
 
         po_items = [
             ItemTransactionModel(
                 po_model=po_model,
                 item_model=choice(self.product_models),
                 po_quantity=round(random() * randint(3, 10) + 3, 2),
                 po_unit_cost=round(random() * randint(100, 800), 2),
@@ -559,38 +549,24 @@
                 date_approved = self.get_next_date(date_review)
                 po_model.mark_as_approved(commit=True, date_approved=date_approved)
                 if random() > 0.25:
                     # add a PO bill...
                     date_fulfilled = self.get_next_date(date_approved)
                     date_bill_draft = date_fulfilled - timedelta(days=randint(1, 3))
 
-                    bill_model: BillModel = BillModel(
+                    bill_model = self.entity_model.create_bill(
+                        vendor_model=choice(self.vendor_models),
+                        terms=choice(BillModel.TERM_CHOICES_VALID),
                         date_draft=date_bill_draft,
-                        vendor=choice(self.vendor_models))
-
-                    bill_model.cash_account = choice(self.accounts_by_role[ASSET_CA_CASH])
-                    bill_model.prepaid_account = choice(self.accounts_by_role[ASSET_CA_PREPAID])
-                    bill_model.unearned_account = choice(self.accounts_by_role[LIABILITY_CL_ACC_PAYABLE])
-
-                    ledger_model, bill_model = bill_model.configure(
-                        entity_slug=self.entity_model.slug,
-                        user_model=self.user_model,
-                        commit_ledger=True
+                        cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
+                        prepaid_account=choice(self.accounts_by_role[ASSET_CA_PREPAID]),
+                        payable_account=choice(self.accounts_by_role[LIABILITY_CL_ACC_PAYABLE]),
+                        commit=True
                     )
 
-                    bill_model.terms = choice([
-                        BillModel.TERMS_ON_RECEIPT,
-                        BillModel.TERMS_NET_30,
-                        BillModel.TERMS_NET_60,
-                        BillModel.TERMS_NET_90
-                    ])
-
-                    bill_model.full_clean()
-                    bill_model.save()
-
                     for po_i in po_items:
                         po_i.po_total_amount = round(po_i.po_total_amount, 2)
                         po_i.total_amount = round(po_i.po_total_amount, 2)
                         po_i.quantity = round(po_i.po_quantity, 2)
                         po_i.unit_cost = round(po_i.po_unit_cost, 2)
                         po_i.bill_model = bill_model
                         po_i.po_item_status = ItemTransactionModel.STATUS_RECEIVED
@@ -644,40 +620,32 @@
                                                                                       'updated'
                                                                                   ])
                                     po_model.mark_as_fulfilled(
                                         date_fulfilled=date_fulfilled,
                                         commit=True)
 
                                     self.entity_model.update_inventory(
-                                        user_model=self.user_model,
+                                        # user_model=self.user_model,
                                         commit=True)
 
                                     self.update_products()
                                     self.update_inventory()
 
     def create_invoice(self, date_draft: date):
-        invoice_model = InvoiceModel(
-            customer=choice(self.customer_models),
-            progress=Decimal(str(round(random(), 2))),
-            terms=choice(InvoiceModel.TERM_CHOICES)[0],
+        invoice_model = self.entity_model.create_invoice(
+            customer_model=choice(self.customer_models),
+            terms=choice(InvoiceModel.TERM_CHOICES_VALID),
             cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
             prepaid_account=choice(self.accounts_by_role[ASSET_CA_RECEIVABLES]),
-            unearned_account=choice(self.accounts_by_role[LIABILITY_CL_DEFERRED_REVENUE]),
+            payable_account=choice(self.accounts_by_role[LIABILITY_CL_DEFERRED_REVENUE]),
             date_draft=date_draft,
-            additional_info=dict()
+            additional_info=dict(),
+            commit=True
         )
         self.logger.info(f'Creating entity invoice {invoice_model.invoice_number}...')
-        ledger_model, invoice_model = invoice_model.configure(
-            entity_slug=self.entity_model,
-            user_model=self.user_model,
-            commit_ledger=True
-        )
-
-        invoice_model.full_clean()
-        invoice_model.save()
 
         invoice_items = list()
 
         for i in range(randint(1, 10)):
             item_model: ItemModel = choice(self.product_models)
             quantity = Decimal.from_float(round(random() * randint(1, 2), 2))
             entity_unit = choice(self.entity_unit_models) if random() > .75 else None
@@ -732,15 +700,15 @@
                     invoice_model.mark_as_paid(
                         entity_slug=self.entity_model.slug,
                         user_model=self.user_model,
                         date_paid=date_paid,
                         commit=True
                     )
                     self.entity_model.update_inventory(
-                        user_model=self.user_model,
+                        # user_model=self.user_model,
                         commit=True
                     )
                     self.update_inventory()
                     self.update_products()
                 elif random() > 0.8:
                     date_void = self.get_next_date(date_approved)
                     invoice_model.mark_as_void(
@@ -769,14 +737,10 @@
             ledger_posted=True,
             je_posted=True
         )
 
     def recount_inventory(self):
         self.logger.info(f'Recounting inventory...')
         self.entity_model.update_inventory(
-            user_model=self.user_model,
+            # user_model=self.user_model,
             commit=True
         )
-
-    def create_coa(self):
-        entity_model = self.entity_model
-        entity_model.populate_default_coa(activate_accounts=True)
```

## django_ledger/io/roles.py

```diff
@@ -4,15 +4,15 @@
 
 Contributions to this module:
     * Miguel Sanda <msanda@arrobalytics.com>
 """
 
 import sys
 from itertools import chain
-from typing import Set
+from typing import Set, List, Union
 
 from django.utils.translation import gettext as _
 
 from django_ledger.exceptions import InvalidRoleError
 
 mod = sys.modules[__name__]
 
@@ -605,14 +605,29 @@
 ROLES_GROUPS = [g for g in ROLES_VARS if g.split('_')[0] == 'GROUP']
 
 GROUPS_DIRECTORY = dict()
 for group in ROLES_GROUPS:
     GROUPS_DIRECTORY[group] = getattr(mod, group)
 
 
-def validate_roles(roles) -> Set[str]:
+def validate_roles(roles: Union[str, List[str]], raise_exception: bool = True) -> Set[str]:
+    """
+    Validates a given role identifier against the valid role available.
+    Parameters
+    ----------
+    roles: str or list
+        The role or list of roles to validate.
+    raise_exception: bool
+        Raises InvalidRoleError if any of the roles provided if not valid.
+
+    Returns
+    -------
+    set
+        A set of the valid roles.
+    """
     if isinstance(roles, str):
         roles = set(roles)
     for r in roles:
         if r not in VALID_ROLES:
-            raise InvalidRoleError('{rls}) is invalid. Choices are {ch}'.format(ch=', '.join(VALID_ROLES), rls=r))
+            if raise_exception:
+                raise InvalidRoleError('{rls}) is invalid. Choices are {ch}'.format(ch=', '.join(VALID_ROLES), rls=r))
     return set(roles)
```

## django_ledger/models/accounts.py

```diff
@@ -103,14 +103,17 @@
             Returns a QuerySet filtered by user-provided list of Roles.
         """
         if isinstance(roles, str):
             roles = [roles]
         roles = validate_roles(roles)
         return self.filter(role__in=roles)
 
+    def expenses(self):
+        return self.filter(role__in=GROUP_EXPENSES)
+
     def is_coa_root(self):
         return self.filter(role__in=ROOT_GROUP)
 
     def not_coa_root(self):
         return self.exclude(role__in=ROOT_GROUP)
 
     def for_entity(self, entity_slug, user_model):
@@ -135,15 +138,15 @@
         return [
             (bsr, [
                 (r, list(l)) for r, l in groupby(gb, key=lambda a: a.get_role_display())
             ]) for bsr, gb in accounts_gb
         ]
 
     def is_role_default(self):
-        return self.filter(role_default=True)
+        return self.not_coa_root().filter(role_default=True)
 
 
 class AccountModelManager(MP_NodeManager):
     """
     This Model Manager will be used as interface through which the database query operations can be provided to the
     Account Model. It uses the custom defined AccountModelQuerySet and hence overrides the normal get_queryset
     function which return all rows of a model.
```

## django_ledger/models/bill.py

```diff
@@ -466,24 +466,26 @@
 
             if not ledger_name:
                 ledger_name = f'Bill {self.uuid}'
             ledger_name += f' | {ledger_name}'
             ledger_model.name = ledger_name
 
             ledger_model.clean()
+            ledger_model.clean_fields()
 
             self.ledger = ledger_model
 
             if commit_ledger:
                 self.ledger.save()
 
             if self.can_generate_bill_number():
                 self.generate_bill_number(commit=commit)
 
             self.clean()
+            self.clean_fields()
 
             if commit:
                 self.save()
 
         return self.ledger, self
 
     # State..
```

## django_ledger/models/coa_default.py

```diff
@@ -305,14 +305,24 @@
      'parent': None},
     {'code': '6210', 'role': roles.EXPENSE_TAXES, 'balance_type': 'debit', 'name': 'Payroll Taxes', 'parent': None},
     {'code': '6280', 'role': roles.EXPENSE_TAXES, 'balance_type': 'debit', 'name': 'Taxes', 'parent': None},
     {'code': '6500', 'role': roles.EXPENSE_OTHER, 'balance_type': 'debit', 'name': 'Misc. Expense', 'parent': None}
 
 ]
 
+
+def get_default_coa() -> List[Dict]:
+    if DJANGO_LEDGER_DEFAULT_COA is not None and isinstance(DJANGO_LEDGER_DEFAULT_COA, list):
+        return DJANGO_LEDGER_DEFAULT_COA
+    return DEFAULT_CHART_OF_ACCOUNTS
+
+
+if DJANGO_LEDGER_DEFAULT_COA:
+    DJANGO_LEDGER_DEFAULT_COA = get_default_coa()
+
 PREFIX_MAP = {
     'in': ROOT_INCOME,
     'ex': ROOT_EXPENSES,
     'lia': ROOT_LIABILITIES,
     'eq': ROOT_CAPITAL,
     'asset': ROOT_ASSETS,
     'cogs': ROOT_COGS
@@ -333,20 +343,14 @@
     """
     code_list = [i['code'] for i in DEFAULT_CHART_OF_ACCOUNTS]
     code_set = set(code_list)
     if not len(code_list) == len(code_set):
         raise DjangoLedgerConfigurationError('Default CoA is not unique.')
 
 
-def get_default_coa() -> List[Dict]:
-    if DJANGO_LEDGER_DEFAULT_COA is not None and isinstance(DJANGO_LEDGER_DEFAULT_COA, list):
-        return DJANGO_LEDGER_DEFAULT_COA
-    return DEFAULT_CHART_OF_ACCOUNTS
-
-
 def get_default_coa_rst(default_coa: Optional[Dict] = None) -> str:
     """
     Converts the provided Chart of Account into restructuredText format.
     Parameters
     ----------
     default_coa:
         A dictionary of chart of accounts. Must follow the same keys as CHART_OF_ACCOUNTS.
```

## django_ledger/models/entity.py

```diff
@@ -37,22 +37,23 @@
 from django.db.models import Q, QuerySet
 from django.db.models.signals import pre_save
 from django.urls import reverse
 from django.utils.text import slugify
 from django.utils.translation import gettext_lazy as _
 from treebeard.mp_tree import MP_Node, MP_NodeManager, MP_NodeQuerySet
 
-from django_ledger.io import roles as roles_module
+from django_ledger.io import roles as roles_module, validate_roles
 from django_ledger.io.io_mixin import IOMixIn
 from django_ledger.models.accounts import AccountModel, AccountModelQuerySet
 from django_ledger.models.bank_account import BankAccountModelQuerySet, BankAccountModel
 from django_ledger.models.coa import ChartOfAccountModel, ChartOfAccountModelQuerySet
 from django_ledger.models.coa_default import CHART_OF_ACCOUNTS_ROOT_MAP
 from django_ledger.models.customer import CustomerModelQueryset, CustomerModel
-from django_ledger.models.items import ItemModelQuerySet, ItemTransactionModelQuerySet
+from django_ledger.models.items import (ItemModelQuerySet, ItemTransactionModelQuerySet, UnitOfMeasureModel,
+                                        UnitOfMeasureModelQuerySet, ItemModel)
 from django_ledger.models.ledger import LedgerModel
 from django_ledger.models.mixins import CreateUpdateMixIn, SlugNameMixIn, ContactInfoMixIn, LoggingMixIn
 from django_ledger.models.unit import EntityUnitModel
 from django_ledger.models.utils import lazy_loader
 from django_ledger.models.vendor import VendorModelQuerySet, VendorModel
 
 UserModel = get_user_model()
@@ -603,14 +604,28 @@
         -------
         bool
             True if EntityModel instance has a Default CoA.
         """
         return self.default_coa_id is not None
 
     def get_default_coa(self, raise_exception: bool = True) -> Optional[ChartOfAccountModel]:
+        """
+        Fetches the EntityModel default Chart of Account.
+
+        Parameters
+        ----------
+        raise_exception: bool
+            Raises exception if no default CoA has been assigned.
+
+        Returns
+        -------
+        ChartOfAccountModel
+            The EntityModel default ChartOfAccount.
+        """
+
         if not self.default_coa_id:
             if raise_exception:
                 raise EntityModelValidationError(f'EntityModel {self.slug} does not have a default CoA')
         return self.default_coa
 
     def create_chart_of_accounts(self,
                                  assign_as_default: bool = False,
@@ -658,23 +673,42 @@
                 ])
         return chart_of_accounts
 
     def populate_default_coa(self,
                              activate_accounts: bool = False,
                              force: bool = False,
                              ignore_if_default_coa: bool = True,
-                             chart_of_accounts: Optional[ChartOfAccountModel] = None,
+                             coa_model: Optional[ChartOfAccountModel] = None,
                              commit: bool = True):
+        """
+        Populates the EntityModel default CoA with the default Chart of Account list provided by Django Ledger or user
+        defined. See DJANGO_LEDGER_DEFAULT_COA setting.
+
+        Parameters
+        ----------
+        activate_accounts: bool
+            Activates all AccountModels for immediate use. Defaults to False.
+        force: bool
+            Forces the creation of accounts even if other accounts are present. Defaults to False.
+        ignore_if_default_coa: bool
+            Raises exception if EntityModel already has a default CoA. Defaults to True.
+        coa_model: ChartOfAccountModel
+            Optional CoA Model to populate. Will be validated against EntityModel if provided.
+        commit: bool
+        '   Commits the newly created CoA into the Database. Defaults to True.
+        """
 
-        if not chart_of_accounts:
+        if not coa_model:
             if not self.has_default_coa():
                 self.create_chart_of_accounts(assign_as_default=True, commit=commit)
-            chart_of_accounts: ChartOfAccountModel = self.default_coa
+            coa_model: ChartOfAccountModel = self.default_coa
+        else:
+            self.validate_chart_of_accounts_for_entity(coa_model=coa_model)
 
-        coa_accounts_qs = chart_of_accounts.accountmodel_set.all()
+        coa_accounts_qs = coa_model.accountmodel_set.all()
 
         # forces evaluation
         len(coa_accounts_qs)
 
         coa_has_accounts = coa_accounts_qs.not_coa_root().exists()
 
         if not coa_has_accounts or force:
@@ -699,36 +733,70 @@
 
                     try:
                         roles_set.remove(account_model.role)
                     except KeyError:
                         pass
 
                     account_model.clean()
-                    chart_of_accounts.create_account(account_model)
+                    coa_model.create_account(account_model)
 
         else:
             if not ignore_if_default_coa:
-                raise ValidationError(f'Entity {self.name} already has existing accounts. '
-                                      'Use force=True to bypass this check')
+                raise EntityModelValidationError(f'Entity {self.name} already has existing accounts. '
+                                                 'Use force=True to bypass this check')
 
     def validate_chart_of_accounts_for_entity(self,
                                               coa_model: ChartOfAccountModel,
                                               raise_exception: bool = True) -> bool:
+        """
+        Validates the CoA Model against the EntityModel instance.
+
+        Parameters
+        ----------
+        coa_model: ChartOfAccountModel
+            The CoA Model to validate.
+        raise_exception: bool
+            Raises EntityModelValidationError if CoA Model is not valid for the EntityModel instance.
+
+        Returns
+        -------
+        bool
+            True if valid, else False.
+        """
         if coa_model.entity_id == self.uuid:
             return True
         if raise_exception:
             raise EntityModelValidationError(
                 f'Invalid ChartOfAccounts model {coa_model.slug} for EntityModel {self.slug}')
         return False
 
     def validate_account_model_for_coa(self,
                                        account_model: AccountModel,
                                        coa_model: ChartOfAccountModel,
                                        raise_exception: bool = True) -> bool:
+        """
+        Validates that the AccountModel provided belongs to the CoA Model provided.
+
+        Parameters
+        ----------
+        account_model: AccountModel
+            The AccountModel to validate.
+        coa_model: ChartOfAccountModel
+            The ChartOfAccountModel to validate against.
+        raise_exception: bool
+            Raises EntityModelValidationError if AccountModel is invalid for the EntityModel and CoA instance.
+
+        Returns
+        -------
+        bool
+            True if valid, else False.
+        """
         valid = self.validate_chart_of_accounts_for_entity(coa_model, raise_exception=raise_exception)
+        if not valid:
+            return valid
         if valid and account_model.coa_model_id == coa_model.uuid:
             return True
         if raise_exception:
             raise EntityModelValidationError(
                 f'Invalid AccountModel model {account_model.uuid} for EntityModel {self.slug}'
             )
         return False
@@ -790,15 +858,15 @@
         if order_by:
             account_model_qs = account_model_qs.order_by(*order_by)
         return account_model_qs
 
     def get_coa_accounts(self,
                          coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
                          active: bool = True,
-                         order_by: Optional[Tuple[str]] = ('code',)) -> AccountModelQuerySet:
+                         order_by: Optional[Tuple] = ('code',)) -> AccountModelQuerySet:
         """
         Fetches the AccountModelQuerySet for a specific ChartOfAccountModel.
 
         Parameters
         ----------
         coa_model: ChartOfAccountModel, UUID, str
             The ChartOfAccountsModel UUID, model instance or slug to pull accounts from. If None, will use default CoA.
@@ -818,15 +886,15 @@
         else:
             account_model_qs = AccountModel.objects.filter(
                 coa_model__entity__uuid__exact=self.uuid
             ).select_related('coa_model', 'coa_model__entity')
 
             if isinstance(coa_model, ChartOfAccountModel):
                 self.validate_chart_of_accounts_for_entity(coa_model=coa_model, raise_exception=True)
-                account_model_qs = account_model_qs.filter(coa_model=coa_model)
+                account_model_qs = coa_model.accountmodel_set.all()
             if isinstance(coa_model, str):
                 account_model_qs = account_model_qs.filter(coa_model__slug__exact=coa_model)
             elif isinstance(coa_model, UUID):
                 account_model_qs = account_model_qs.filter(coa_model__uuid__exact=coa_model)
 
         if active:
             account_model_qs = account_model_qs.active()
@@ -892,24 +960,39 @@
 
         if isinstance(code_list, str):
             return account_model_qs.filter(code__exact=code_list)
         return account_model_qs.filter(code__in=code_list)
 
     def get_default_account_for_role(self,
                                      role: str,
-                                     coa_model: Optional[ChartOfAccountModel] = None,
-                                     account_model_qs: Optional[AccountModelQuerySet] = None) -> AccountModel:
+                                     coa_model: Optional[ChartOfAccountModel] = None) -> AccountModel:
+        """
+        Gets the given role default AccountModel from the provided CoA.
+        CoA will be validated against the EntityModel instance.
+
+        Parameters
+        ----------
+        role: str
+            The CoA role to fetch the corresponding default Account Model.
+        coa_model: ChartOfAccountModel
+            The CoA Model to pull default account from. If not provided, will use EntityModel default CoA.
+
+        Returns
+        -------
+        AccountModel
+            The default account model for the specified CoA role.
+        """
+        validate_roles(role, raise_exception=True)
         if not coa_model:
             coa_model = self.default_coa
         else:
             self.validate_chart_of_accounts_for_entity(coa_model)
 
-        if not account_model_qs:
-            return coa_model.accountmodel_set.get(role__exact=role, role_default=True)
-        return account_model_qs.get(coa_model=coa_model, role__exact=role, role_default=True)
+        account_model_qs = coa_model.accountmodel_set.all().is_role_default()
+        return account_model_qs.get(role__exact=role)
 
     def create_account(self,
                        account_model_kwargs: Dict,
                        coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
                        raise_exception: bool = True) -> Tuple[ChartOfAccountModel, AccountModel]:
         """
         Creates a new AccountModel for the EntityModel.
@@ -1044,30 +1127,74 @@
         customer_model.clean()
         if commit:
             customer_model.save()
         return customer_model
 
     # ### BILL MANAGEMENT ####
     def get_bills(self):
+        """
+        Fetches a QuerySet of BillModels associated with the EntityModel instance.
+
+        Returns
+        -------
+        BillModelQuerySet
+        """
         BillModel = lazy_loader.get_bill_model()
         return BillModel.objects.filter(
             ledger__entity__uuid__exact=self.uuid
         ).select_related('ledger', 'ledger__entity', 'vendor')
 
     def create_bill(self,
                     vendor_model: Union[VendorModel, UUID, str],
+                    terms: str,
+                    date_draft: Optional[date] = None,
                     xref: Optional[str] = None,
                     cash_account: Optional[AccountModel] = None,
                     prepaid_account: Optional[AccountModel] = None,
                     payable_account: Optional[AccountModel] = None,
                     additional_info: Optional[Dict] = None,
                     ledger_name: Optional[str] = None,
                     coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
                     commit: bool = True):
+        """
+        Creates a new BillModel for the EntityModel instance.
+        Bill will have DRAFT status.
+
+        Parameters
+        ----------
+        vendor_model: VendorModel or UUID or str
+            The VendorModel, VendorModel UUID or VendorModel Number
+        terms: str
+            Payment terms of the new BillModel. A choice of BillModel.TERM_CHOICES_VALID
+        date_draft: date
+            Date to use as draft date for the new BillModel.
+        xref: str
+            Optional External Reference for the Bill (i.e. Vendor invoice number.)
+        cash_account: AccountModel
+            Optional CASH AccountModel associated with the new BillModel. Defaults to CASH default AccountModel role.
+        prepaid_account: AccountModel
+            Optional PREPAID AccountModel associated with the new BillModel for accruing purposes.
+            Defaults to PREPAID default AccountModel role.
+        payable_account: AccountModel
+            Optional PAYABLE AccountModel associated with the new BillModel for accruing purposes.
+            Defaults to ACCOUNTS PAYABLE default AccountModel role.
+        additional_info: Dict
+            Additional user-defined information stored as JSON in the Database.
+        ledger_name: str
+            Optional LedgerModel name to be assigned to the BillModel instance.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels
+        commit: bool
+            If True, commits the new BillModel in the Database.
 
+        Returns
+        -------
+        BillModel
+            The newly created BillModel in DRAFT state.
+        """
         BillModel = lazy_loader.get_bill_model()
 
         if isinstance(vendor_model, VendorModel):
             if not vendor_model.entity_model_id == self.uuid:
                 raise EntityModelValidationError(f'VendorModel {vendor_model.uuid} belongs to a different EntityModel.')
         elif isinstance(vendor_model, UUID):
             vendor_model = self.get_vendor_by_uuid(vendor_uuid=vendor_model)
@@ -1079,52 +1206,98 @@
         account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
 
         account_model_qs = account_model_qs.with_roles(roles=[
             roles_module.ASSET_CA_CASH,
             roles_module.ASSET_CA_PREPAID,
             roles_module.LIABILITY_CL_ACC_PAYABLE
         ]).is_role_default()
+
         # evaluates the queryset...
         len(account_model_qs)
 
         bill_model = BillModel(
-            vendor=vendor_model,
             xref=xref,
+            vendor=vendor_model,
+            terms=terms,
             additional_info=additional_info,
             cash_account=account_model_qs.get(role=roles_module.ASSET_CA_CASH) if not cash_account else cash_account,
             prepaid_account=account_model_qs.get(
                 role=roles_module.ASSET_CA_PREPAID) if not prepaid_account else prepaid_account,
             unearned_account=account_model_qs.get(
                 role=roles_module.LIABILITY_CL_ACC_PAYABLE) if not payable_account else payable_account
         )
 
         _, bill_model = bill_model.configure(entity_slug=self,
                                              ledger_name=ledger_name,
+                                             date_draft=date_draft,
                                              commit=commit,
                                              commit_ledger=commit)
 
         return bill_model
 
     # ### INVOICE MANAGEMENT ####
     def get_invoices(self):
+        """
+        Fetches a QuerySet of InvoiceModels associated with the EntityModel instance.
+
+        Returns
+        -------
+        InvoiceModelQuerySet
+        """
         InvoiceModel = lazy_loader.get_invoice_model()
         return InvoiceModel.objects.filter(
             ledger__entity__uuid__exact=self.uuid
         ).select_related('ledger', 'ledger__entity', 'customer')
 
     def create_invoice(self,
                        customer_model: Union[VendorModel, UUID, str],
+                       terms: str,
                        cash_account: Optional[AccountModel] = None,
                        prepaid_account: Optional[AccountModel] = None,
                        payable_account: Optional[AccountModel] = None,
                        additional_info: Optional[Dict] = None,
                        ledger_name: Optional[str] = None,
                        coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                       date_draft: Optional[date] = None,
                        commit: bool = True):
 
+        """
+        Creates a new InvoiceModel for the EntityModel instance.
+        Invoice will have DRAFT status.
+
+        Parameters
+        ----------
+        customer_model: CustomerModel or UUID or str
+            The CustomerModel, CustomerModel UUID or CustomerModel Number
+        terms: str
+            A choice of InvoiceModel.TERM_CHOICES_VALID
+        cash_account: AccountModel
+            Optional CASH AccountModel associated with the new InvoiceModel. Defaults to CASH default AccountModel role.
+        prepaid_account: AccountModel
+            Optional PREPAID AccountModel associated with the new InvoiceModel for accruing purposes.
+            Defaults to PREPAID default AccountModel role.
+        payable_account: AccountModel
+            Optional PAYABLE AccountModel associated with the new InvoiceModel for accruing purposes.
+            Defaults to ACCOUNTS PAYABLE default AccountModel role.
+        additional_info: Dict
+            Additional user-defined information stored as JSON in the Database.
+        ledger_name: str
+            Optional LedgerModel name to be assigned to the InvoiceModel instance.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels
+        date_draft: date
+            Optional date to use as Draft Date. Defaults to localdate() if None.
+        commit: bool
+            If True, commits the new BillModel in the Database.
+
+        Returns
+        -------
+        InvoiceModel
+            The newly created InvoiceModel in DRAFT state.
+        """
         InvoiceModel = lazy_loader.get_invoice_model()
 
         if isinstance(customer_model, CustomerModel):
             if not customer_model.entity_model_id == self.uuid:
                 raise EntityModelValidationError(
                     f'CustomerModel {customer_model.uuid} belongs to a different EntityModel.')
         elif isinstance(customer_model, UUID):
@@ -1143,89 +1316,189 @@
 
         # evaluates the queryset...
         len(account_model_qs)
 
         invoice_model = InvoiceModel(
             customer=customer_model,
             additional_info=additional_info,
+            terms=terms,
             cash_account=account_model_qs.get(role=roles_module.ASSET_CA_CASH) if not cash_account else cash_account,
             prepaid_account=account_model_qs.get(
                 role=roles_module.ASSET_CA_PREPAID) if not prepaid_account else prepaid_account,
             unearned_account=account_model_qs.get(
                 role=roles_module.LIABILITY_CL_ACC_PAYABLE) if not payable_account else payable_account
         )
 
         _, invoice_model = invoice_model.configure(entity_slug=self,
                                                    ledger_name=ledger_name,
                                                    commit=commit,
+                                                   date_draft=date_draft,
                                                    commit_ledger=commit)
 
         return invoice_model
 
     # ### PURCHASE ORDER MANAGEMENT ####
     def get_purchase_orders(self):
+        """
+        Fetches a QuerySet of PurchaseOrderModels associated with the EntityModel instance.
+
+        Returns
+        -------
+        PurchaseOrderModelQuerySet
+        """
         return self.purchaseordermodel_set.all().select_related('entity')
 
     def create_purchase_order(self,
-                              draft_date: Optional[date] = None,
+                              po_title: Optional[str] = None,
                               estimate_model=None,
+                              date_draft: Optional[date] = None,
                               commit: bool = True):
+        """
+        Creates a new PurchaseOrderModel for the EntityModel instance.
+        PO will have DRAFT status.
+
+        Parameters
+        ----------
+        po_title: str
+            The user defined title for the new Purchase Order Model.
+        date_draft: date
+            Optional date to use as Draft Date. Defaults to localdate() if None.
+        estimate_model: EstimateModel
+            The EstimateModel to associate the PO for tracking.
+        commit: bool
+            If True, commits the new PO in the Database. Defaults to True.
+
+        Returns
+        -------
+        PurchaseOrderModel
+            The newly created PurchaseOrderModel in DRAFT state.
+        """
         PurchaseOrderModel = lazy_loader.get_purchase_order_model()
         po_model = PurchaseOrderModel()
         return po_model.configure(
             entity_slug=self,
-            draft_date=draft_date,
+            draft_date=date_draft,
             estimate_model=estimate_model,
-            commit=commit
+            commit=commit,
+            po_title=po_title
         )
 
     # ### ESTIMATE/CONTRACT MANAGEMENT ####
     def get_estimates(self):
+        """
+        Fetches a QuerySet of EstimateModels associated with the EntityModel instance.
+
+        Returns
+        -------
+        EstimateModelQuerySet
+        """
         return self.estimatemodel_set.all().select_related('entity')
 
     def create_estimate(self,
                         estimate_title: str,
+                        contract_terms: str,
                         customer_model: Union[CustomerModel, UUID, str],
-                        draft_date: Optional[date] = None,
+                        date_draft: Optional[date] = None,
                         commit: bool = True):
+        """
+        Creates a new EstimateModel for the EntityModel instance.
+        Estimate will have DRAFT status.
+
+        Parameters
+        ----------
+        estimate_title: str
+            A user defined title for the Estimate.
+        date_draft: date
+            Optional date to use as Draft Date. Defaults to localdate() if None.
+        customer_model: CustomerModel or UUID or str
+            The CustomerModel, CustomerModel UUID or CustomerModel Number
+        contract_terms: str
+            A choice of EstimateModel.CONTRACT_TERMS_CHOICES_VALID
+        commit: bool
+            If True, commits the new PO in the Database. Defaults to True.
 
+        Returns
+        -------
+        PurchaseOrderModel
+            The newly created PurchaseOrderModel in DRAFT state.
+        """
         if isinstance(customer_model, CustomerModel):
             self.validate_customer(customer_model)
         elif isinstance(customer_model, str):
             customer_model = self.get_customer_by_number(customer_number=customer_model)
         elif isinstance(customer_model, UUID):
             customer_model = self.get_customer_by_uuid(customer_uuid=customer_model)
         else:
             raise EntityModelValidationError('CustomerModel must be an instance of CustomerModel, UUID or str.')
 
         EstimateModel = lazy_loader.get_estimate_model()
-        estimate_model = EstimateModel()
+        estimate_model = EstimateModel(terms=contract_terms)
         return estimate_model.configure(
             entity_slug=self,
-            date_draft=draft_date,
+            date_draft=date_draft,
             customer_model=customer_model,
             estimate_title=estimate_title,
             commit=commit
         )
 
     # ### BANK ACCOUNT MANAGEMENT ####
     def get_bank_accounts(self, active: bool = True) -> BankAccountModelQuerySet:
+        """
+        Fetches a QuerySet of BankAccountModels associated with the EntityModel instance.
+
+        Parameters
+        ----------
+        active: bool
+            If True, returns only active Bank Accounts. Defaults to True.
+
+        Returns
+        -------
+        BankAccountModelQuerySet
+        """
         bank_account_qs = self.bankaccountmodel_set.all().select_related('entity_model')
         if active:
             bank_account_qs = bank_account_qs.active()
         return bank_account_qs
 
     def create_bank_account(self,
                             name: str,
                             account_type: str,
                             active=False,
                             cash_account: Optional[AccountModel] = None,
                             coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
                             bank_account_model_kwargs: Optional[Dict] = None,
                             commit: bool = True):
+
+        """
+        Creates a new BankAccountModel for the EntityModel instance.
+        Estimate will have DRAFT status.
+
+        Parameters
+        ----------
+        name: str
+            A user defined name for the BankAccountModel.
+        account_type: date
+            A choice of BankAccountModel.VALID_ACCOUNT_TYPES.
+        active: bool
+            Marks the account as active.
+        cash_account: AccountModel
+            Optional CASH AccountModel associated with the new InvoiceModel. Defaults to CASH default AccountModel role.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels.
+        commit: bool
+            If True, commits the new BankAccountModel in the Database. Defaults to True.
+        bank_account_model_kwargs: Dict
+            Additional kwargs for the new BankAccountModel instance.
+
+        Returns
+        -------
+        PurchaseOrderModel
+            The newly created PurchaseOrderModel in DRAFT state.
+        """
+
         if bank_account_model_kwargs is None:
             bank_account_model_kwargs = dict()
         if account_type not in BankAccountModel.VALID_ACCOUNT_TYPES:
             raise EntityModelValidationError(
                 _(f'Invalid Account Type: choices are {BankAccountModel.VALID_ACCOUNT_TYPES}'))
         account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
         account_model_qs = account_model_qs.with_roles(roles=roles_module.ASSET_CA_CASH).is_role_default()
@@ -1238,15 +1511,435 @@
             **bank_account_model_kwargs
         )
         bank_account_model.clean()
         if commit:
             bank_account_model.save()
         return bank_account_model
 
+    # #### ITEM MANAGEMENT ###
+
+    def validate_item_qs(self, item_qs: ItemModelQuerySet, raise_exception: bool = True) -> bool:
+        """
+        Validates the given ItemModelQuerySet against the EntityModel instance.
+        Parameters
+        ----------
+        item_qs: ItemModelQuerySet
+            The ItemModelQuerySet to validate.
+        raise_exception: bool
+            Raises EntityModelValidationError if ItemModelQuerySet is not valid.
+
+        Returns
+        -------
+        bool
+            True if valid, else False.
+        """
+        for item_model in item_qs:
+            if item_model.entity_id != self.uuid:
+                if raise_exception:
+                    raise EntityModelValidationError(f'Invalid item_qs provided for entity {self.slug}...')
+                return False
+        return True
+
+    def get_uom_all(self) -> UnitOfMeasureModelQuerySet:
+        """
+        Fetches the EntityModel instance Unit of Measures QuerySet.
+
+        Returns
+        -------
+        UnitOfMeasureModelQuerySet
+        """
+        return self.unitofmeasuremodel_set.all().select_related('entity')
+
+    def create_uom(self, name: str, unit_abbr: str, active: bool = True, commit: bool = True) -> UnitOfMeasureModel:
+        """
+        Creates a new Unit of Measure Model associated with the EntityModel instance
+
+        Parameters
+        ----------
+        name: str
+            The user defined name of the new Unit of Measure Model instance.
+        unit_abbr: str
+            The unique slug abbreviation of the UoM model. Will be indexed.
+        active: bool
+            Mark this UoM as active.
+        commit: bool
+            Saves the model in the DB if True. Defaults to True
+
+        Returns
+        -------
+        UnitOfMeasureModel
+        """
+        uom_model = UnitOfMeasureModel(
+            name=name,
+            unit_abbr=unit_abbr,
+            is_active=active,
+            entity=self
+        )
+        uom_model.clean()
+        uom_model.clean_fields()
+        if commit:
+            uom_model.save()
+        return uom_model
+
+    def get_items_all(self, active: bool = True) -> ItemModelQuerySet:
+        """
+        Fetches all EntityModel instance ItemModel's.
+        QuerySet selects relevant related fields to avoid additional
+        DB queries for most use cases.
+
+        Parameters
+        ----------
+        active: bool
+            Filters the QuerySet to active accounts only. Defaults to True.
+
+        Returns
+        -------
+        ItemModelQuerySet
+        """
+        qs = self.itemmodel_set.all().select_related(
+            'uom',
+            'entity',
+            'inventory_account',
+            'cogs_account',
+            'earnings_account',
+            'expense_account'
+        )
+        if active:
+            return qs.active()
+        return qs
+
+    def get_items_products(self, active: bool = True) -> ItemModelQuerySet:
+        """
+        Fetches all EntityModel instance ItemModel's that qualify as Products.
+        QuerySet selects relevant related fields to avoid additional
+        DB queries for most use cases.
+
+        Parameters
+        ----------
+        active: bool
+            Filters the QuerySet to active accounts only. Defaults to True.
+
+        Returns
+        -------
+        ItemModelQuerySet
+        """
+        qs = self.get_items_all(active=active)
+        return qs.products()
+
+    def create_item_product(self,
+                            name: str,
+                            item_type: str,
+                            uom_model: Union[UUID, UnitOfMeasureModel],
+                            coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                            commit: bool = True) -> ItemModel:
+        """
+        Creates a new items of type PRODUCT.
+
+        Parameters
+        ----------
+        name: str
+            Name of the new service.
+        item_type: str
+            The type of product. A choice of ItemModel.ITEM_TYPE_CHOICES
+        uom_model:
+            The UOM UUID or UnitOfMeasureModel of the Service. Will be validated if provided.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels.
+        commit: bool
+            Commits the ItemModel in the DB. Defaults to True.
+        Returns
+        -------
+        ItemModel
+            The created Product.
+        """
+        if isinstance(uom_model, UUID):
+            uom_model = self.unitofmeasuremodel_set.select_related('entity').get(uuid__exact=uom_model)
+        elif isinstance(uom_model, UnitOfMeasureModel):
+            if uom_model.entity_id != self.uuid:
+                raise EntityModelValidationError(f'Invalid UnitOfMeasureModel for entity {self.slug}...')
+
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+        account_model_qs = account_model_qs.with_roles(roles=[
+            roles_module.ASSET_CA_INVENTORY,
+            roles_module.COGS,
+            roles_module.INCOME_OPERATIONAL
+        ]).is_role_default()
+
+        # evaluates the queryset...
+        len(account_model_qs)
+
+        product_model = ItemModel(
+            entity=self,
+            name=name,
+            uom=uom_model,
+            item_role=ItemModel.ITEM_ROLE_PRODUCT,
+            item_type=item_type,
+            inventory_account=account_model_qs.filter(role=roles_module.ASSET_CA_INVENTORY).get(),
+            earnings_account=account_model_qs.filter(role=roles_module.INCOME_OPERATIONAL).get(),
+            cogs_account=account_model_qs.filter(role=roles_module.COGS).get()
+        )
+        product_model.clean()
+        product_model.clean_fields()
+        if commit:
+            product_model.save()
+        return product_model
+
+    def get_items_services(self, active: bool = True) -> ItemModelQuerySet:
+        """
+        Fetches all EntityModel instance ItemModel's that qualify as Services.
+        QuerySet selects relevant related fields to avoid additional
+        DB queries for most use cases.
+
+        Parameters
+        ----------
+        active: bool
+            Filters the QuerySet to active accounts only. Defaults to True.
+
+        Returns
+        -------
+        ItemModelQuerySet
+        """
+        qs = self.get_items_all(active=active)
+        return qs.services()
+
+    def create_item_service(self,
+                            name: str,
+                            uom_model: Union[UUID, UnitOfMeasureModel],
+                            coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                            commit: bool = True) -> ItemModel:
+        """
+        Creates a new items of type SERVICE.
+
+        Parameters
+        ----------
+        name: str
+            Name of the new service.
+        uom_model:
+            The UOM UUID or UnitOfMeasureModel of the Service. Will be validated if provided.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels.
+        commit: bool
+            Commits the ItemModel in the DB. Defaults to True.
+
+        Returns
+        -------
+        ItemModel
+            The created Service.
+        """
+
+        if isinstance(uom_model, UUID):
+            uom_model = self.unitofmeasuremodel_set.select_related('entity').get(uuid__exact=uom_model)
+        elif isinstance(uom_model, UnitOfMeasureModel):
+            if uom_model.entity_id != self.uuid:
+                raise EntityModelValidationError(f'Invalid UnitOfMeasureModel for entity {self.slug}...')
+
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+        account_model_qs = account_model_qs.with_roles(roles=[
+            roles_module.COGS,
+            roles_module.INCOME_OPERATIONAL
+        ]).is_role_default()
+
+        # evaluates the queryset...
+        len(account_model_qs)
+
+        service_model = ItemModel(
+            entity=self,
+            name=name,
+            uom=uom_model,
+            item_role=ItemModel.ITEM_ROLE_SERVICE,
+            item_type=ItemModel.ITEM_TYPE_LABOR,
+            earnings_account=account_model_qs.filter(role=roles_module.INCOME_OPERATIONAL).get(),
+            cogs_account=account_model_qs.filter(role=roles_module.COGS).get()
+        )
+        service_model.clean()
+        service_model.clean_fields()
+        if commit:
+            service_model.save()
+        return service_model
+
+    def get_items_expenses(self, active: bool = True) -> ItemModelQuerySet:
+        """
+        Fetches all EntityModel instance ItemModel's that qualify as Products.
+        QuerySet selects relevant related fields to avoid additional
+        DB queries for most use cases.
+
+        Parameters
+        ----------
+        active: bool
+            Filters the QuerySet to active accounts only. Defaults to True.
+
+        Returns
+        -------
+        ItemModelQuerySet
+        """
+        qs = self.get_items_all(active=active)
+        return qs.expenses()
+
+    def create_item_expense(self,
+                            name: str,
+                            expense_type: str,
+                            uom_model: Union[UUID, UnitOfMeasureModel],
+                            expense_account: Optional[Union[UUID, AccountModel]] = None,
+                            coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                            commit: bool = True) -> ItemModel:
+
+        """
+        Creates a new items of type EXPENSE.
+
+        Parameters
+        ----------
+        name: str
+            The name of the new service.
+        expense_type: str
+            The type of expense. A choice of ItemModel.ITEM_TYPE_CHOICES
+        uom_model:
+            The UOM UUID or UnitOfMeasureModel of the Service. Will be validated if provided.
+        expense_account: AccountModel
+            Optional EXPENSE_OPERATIONAL AccountModel associated with the new Expense Item.
+            Defaults to EXPENSE_OPERATIONAL default AccountModel role.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels.
+        commit: bool
+            Commits the ItemModel in the DB. Defaults to True.
+
+        Returns
+        -------
+        ItemModel
+        """
+        if isinstance(uom_model, UUID):
+            uom_model = self.unitofmeasuremodel_set.select_related('entity').get(uuid__exact=uom_model)
+        elif isinstance(uom_model, UnitOfMeasureModel):
+            if uom_model.entity_id != self.uuid:
+                raise EntityModelValidationError(f'Invalid UnitOfMeasureModel for entity {self.slug}...')
+
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+        account_model_qs = account_model_qs.with_roles(roles=roles_module.EXPENSE_OPERATIONAL)
+        if not expense_account:
+            expense_account = account_model_qs.is_role_default().get()
+        elif isinstance(expense_account, UUID):
+            expense_account = account_model_qs.get(uuid__exact=expense_account)
+        elif isinstance(expense_account, AccountModel):
+            if expense_account.coa_model.entity_id != self.uuid:
+                raise EntityModelValidationError(f'Invalid account for entity {self.slug}...')
+
+        expense_item_model = ItemModel(
+            entity=self,
+            name=name,
+            uom=uom_model,
+            item_role=ItemModel.ITEM_ROLE_EXPENSE,
+            item_type=expense_type,
+            expense_account=expense_account
+        )
+        expense_item_model.clean()
+        expense_item_model.clean_fields()
+        if commit:
+            expense_item_model.save()
+        return expense_item_model
+
     # ##### INVENTORY MANAGEMENT ####
+
+    def get_items_inventory(self, active: bool = True):
+        """
+        Fetches all EntityModel instance ItemModel's that qualify as inventory.
+        QuerySet selects relevant related fields to avoid additional
+        DB queries for most use cases.
+
+        Parameters
+        ----------
+        active: bool
+            Filters the QuerySet to active accounts only. Defaults to True.
+
+        Returns
+        -------
+        ItemModelQuerySet
+        """
+        qs = self.get_items_all(active=active)
+        return qs.inventory_all()
+
+    def get_items_inventory_wip(self, active: bool = True):
+        """
+        Fetches all EntityModel instance ItemModel's that qualify as work in progress inventory.
+        QuerySet selects relevant related fields to avoid additional
+        DB queries for most use cases.
+
+        Parameters
+        ----------
+        active: bool
+            Filters the QuerySet to active accounts only. Defaults to True.
+
+        Returns
+        -------
+        ItemModelQuerySet
+        """
+        qs = self.get_items_all(active=active)
+        return qs.inventory_wip()
+
+    def create_item_inventory(self,
+                              name: str,
+                              uom_model: Union[UUID, UnitOfMeasureModel],
+                              item_type: str,
+                              inventory_account: Optional[Union[UUID, AccountModel]] = None,
+                              coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                              commit: bool = True):
+        """
+        Creates a new items of type INVENTORY.
+
+        Parameters
+        ----------
+        name: str
+            The name of the new service.
+        item_type: str
+            The type of expense. A choice of ItemModel.ITEM_TYPE_CHOICES
+        uom_model:
+            The UOM UUID or UnitOfMeasureModel of the Service. Will be validated if provided.
+        inventory_account: AccountModel
+            Optional ASSET_CA_INVENTORY AccountModel associated with the new Expense Item.
+            Defaults to ASSET_CA_INVENTORY default AccountModel role.
+        coa_model: ChartOfAccountModel
+            Optional ChartOfAccountsModel to use when fetching default role AccountModels.
+        commit: bool
+            Commits the ItemModel in the DB. Defaults to True.
+
+
+        Returns
+        -------
+        ItemModel
+        """
+        if isinstance(uom_model, UUID):
+            uom_model = self.unitofmeasuremodel_set.select_related('entity').get(uuid__exact=uom_model)
+        elif isinstance(uom_model, UnitOfMeasureModel):
+            if uom_model.entity_id != self.uuid:
+                raise EntityModelValidationError(f'Invalid UnitOfMeasureModel for entity {self.slug}...')
+
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+        account_model_qs = account_model_qs.with_roles(roles=roles_module.ASSET_CA_INVENTORY)
+        if not inventory_account:
+            inventory_account = account_model_qs.is_role_default().get()
+        elif isinstance(inventory_account, UUID):
+            inventory_account = account_model_qs.get(uuid__exact=inventory_account)
+        elif isinstance(inventory_account, AccountModel):
+            if inventory_account.coa_model.entity_id != self.uuid:
+                raise EntityModelValidationError(f'Invalid account for entity {self.slug}...')
+            elif inventory_account.coa_model_id != coa_model.uuid:
+                raise EntityModelValidationError(f'Invalid account for coa {coa_model.slug}...')
+
+        inventory_item_model = ItemModel(
+            name=name,
+            uom=uom_model,
+            entity=self,
+            item_type=item_type,
+            item_role=ItemModel.ITEM_ROLE_INVENTORY,
+            inventory_account=inventory_account
+        )
+        inventory_item_model.clean()
+        inventory_item_model.clean_fields()
+        if commit:
+            inventory_item_model.save()
+        return inventory_item_model
+
     @staticmethod
     def inventory_adjustment(counted_qs, recorded_qs) -> defaultdict:
         """
         Computes the necessary inventory adjustment to update balance sheet.
 
         Parameters
         ----------
@@ -1328,51 +2021,40 @@
                 adjustment[uid]['recorded'] = counted
                 adjustment[uid]['recorded_value'] = recorded_data['value']
                 adjustment[uid]['recorded_avg_cost'] = avg_cost
 
                 adjustment[uid]['count_diff'] -= counted
                 adjustment[uid]['value_diff'] -= recorded_data['value']
                 adjustment[uid]['avg_cost_diff'] -= avg_cost
-
         return adjustment
 
     def update_inventory(self,
-                         user_model,
                          commit: bool = False) -> Tuple[defaultdict, ItemTransactionModelQuerySet, ItemModelQuerySet]:
         """
         Triggers an inventory recount with optional commitment of transaction.
 
         Parameters
         ----------
-        user_model: UserModel
-            The Django UserModel making the request.
-
         commit:
             Updates all inventory ItemModels with the new inventory count.
 
         Returns
         -------
         Tuple[defaultdict, ItemTransactionModelQuerySet, ItemModelQuerySet]
             Return a tuple as follows:
                 0. All necessary inventory adjustments as a dictionary.
                 1. The recounted inventory.
                 2. The recorded inventory on Balance Sheet.
         """
         ItemTransactionModel = lazy_loader.get_item_transaction_model()
         ItemModel = lazy_loader.get_item_model()
 
-        counted_qs: ItemTransactionModelQuerySet = ItemTransactionModel.objects.inventory_count(
-            entity_slug=self.slug,
-            user_model=user_model
-        )
-        recorded_qs: ItemModelQuerySet = self.recorded_inventory(user_model=user_model, as_values=False)
-        recorded_qs_values = self.recorded_inventory(
-            user_model=user_model,
-            item_qs=recorded_qs,
-            as_values=True)
+        counted_qs: ItemTransactionModelQuerySet = ItemTransactionModel.objects.inventory_count(entity_slug=self.slug)
+        recorded_qs: ItemModelQuerySet = self.recorded_inventory(as_values=False)
+        recorded_qs_values = self.recorded_inventory(item_qs=recorded_qs, as_values=True)
 
         adj = self.inventory_adjustment(counted_qs, recorded_qs_values)
 
         updated_items = list()
         for (uuid, name, uom), i in adj.items():
             item_model: ItemModel = recorded_qs.get(uuid__exact=uuid)
             item_model.inventory_received = i['counted']
@@ -1387,47 +2069,41 @@
                                               'inventory_received_value',
                                               'updated'
                                           ])
 
         return adj, counted_qs, recorded_qs
 
     def recorded_inventory(self,
-                           user_model,
                            item_qs: Optional[ItemModelQuerySet] = None,
                            as_values: bool = True) -> ItemModelQuerySet:
         """
         Recorded inventory on the books marked as received. PurchaseOrderModel drives the ordering and receiving of
         inventory. Once inventory is marked as "received" recorded inventory of each item is updated by calling
         :func:`update_inventory <django_ledger.models.entity.EntityModelAbstract.update_inventory>`.
         This function returns relevant values of the recoded inventory, including Unit of Measures.
 
         Parameters
         ----------
-        user_model: UserModel
-            The Django UserModel making the request.
-
         item_qs: ItemModelQuerySet
             Pre fetched ItemModelQuerySet. Avoids additional DB Query.
 
         as_values: bool
             Returns a list of dictionaries by calling the Django values() QuerySet function.
 
 
         Returns
         -------
         ItemModelQuerySet
             The ItemModelQuerySet containing inventory ItemModels with additional Unit of Measure information.
 
         """
         if not item_qs:
-            recorded_qs = self.itemmodel_set.inventory_all(
-                entity_slug=self.slug,
-                user_model=user_model
-            )
+            recorded_qs = self.itemmodel_set.all().inventory_all()
         else:
+            self.validate_item_qs(item_qs)
             recorded_qs = item_qs
         if as_values:
             return recorded_qs.values(
                 'uuid', 'name', 'uom__name', 'inventory_received', 'inventory_received_value')
         return recorded_qs
 
     def add_equity(self,
```

## django_ledger/models/estimate.py

```diff
@@ -58,30 +58,30 @@
 
         Returns
         -------
         EstimateModelQuerySet
             A EstimateModelQuerySet with applied filters.
         """
         return self.filter(
-            Q(status__exact=EstimateModelAbstract.CJ_STATUS_APPROVED) |
-            Q(status__exact=EstimateModelAbstract.CJ_STATUS_COMPLETED)
+            Q(status__exact=EstimateModelAbstract.CONTRACT_STATUS_APPROVED) |
+            Q(status__exact=EstimateModelAbstract.CONTRACT_STATUS_COMPLETED)
         )
 
     def not_approved(self):
         """
         Not approved Estimates or Sales Orders are those that have not been approved or completed.
 
         Returns
         -------
         EstimateModelQuerySet
             A EstimateModelQuerySet with applied filters.
         """
         return self.exclude(
-            Q(status__exact=EstimateModelAbstract.CJ_STATUS_APPROVED) |
-            Q(status__exact=EstimateModelAbstract.CJ_STATUS_COMPLETED)
+            Q(status__exact=EstimateModelAbstract.CONTRACT_STATUS_APPROVED) |
+            Q(status__exact=EstimateModelAbstract.CONTRACT_STATUS_COMPLETED)
         )
 
     def contracts(self):
         """
         A contract are Estimates or Sales Orders are those that have been approved or completed.
 
         Returns
@@ -202,60 +202,62 @@
     material_estimate: Decimal
         The total material costs estimate of the EstimateModel instance.
     equipment_estimate: Decimal
         The total equipment costs estimate of the EstimateModel instance.
     other_estimate: Decimal
         the total miscellaneous costs estimate of the EstimateModel instance.
     """
-    CJ_STATUS_DRAFT = 'draft'
-    CJ_STATUS_REVIEW = 'in_review'
-    CJ_STATUS_APPROVED = 'approved'
-    CJ_STATUS_COMPLETED = 'completed'
-    CJ_STATUS_VOID = 'void'
-    CJ_STATUS_CANCELED = 'canceled'
-    CJ_STATUS = [
-        (CJ_STATUS_DRAFT, _('Draft')),
-        (CJ_STATUS_REVIEW, _('In Review')),
-        (CJ_STATUS_APPROVED, _('Approved')),
-        (CJ_STATUS_COMPLETED, _('Completed')),
-        (CJ_STATUS_VOID, _('Void')),
-        (CJ_STATUS_CANCELED, _('Canceled')),
+    CONTRACT_STATUS_DRAFT = 'draft'
+    CONTRACT_STATUS_REVIEW = 'in_review'
+    CONTRACT_STATUS_APPROVED = 'approved'
+    CONTRACT_STATUS_COMPLETED = 'completed'
+    CONTRACT_STATUS_VOID = 'void'
+    CONTRACT_STATUS_CANCELED = 'canceled'
+    CONTRACT_STATUS_CHOICES = [
+        (CONTRACT_STATUS_DRAFT, _('Draft')),
+        (CONTRACT_STATUS_REVIEW, _('In Review')),
+        (CONTRACT_STATUS_APPROVED, _('Approved')),
+        (CONTRACT_STATUS_COMPLETED, _('Completed')),
+        (CONTRACT_STATUS_VOID, _('Void')),
+        (CONTRACT_STATUS_CANCELED, _('Canceled')),
     ]
+    CONTRACT_STATUS_CHOICES_VALID = tuple(i[0] for i in CONTRACT_STATUS_CHOICES)
 
-    CJ_TERMS_FIXED = 'fixed'
-    CJ_TERMS_TARGET_PRICE = 'target'
-    CJ_TERMS_TM = 't&m'
-    CJ_TERMS_OTHER = 'other'
-    CONTRACT_TERMS = [
-        (CJ_TERMS_FIXED, _('Fixed Price')),
-        (CJ_TERMS_TARGET_PRICE, _('Target Price')),
-        (CJ_TERMS_TM, _('Time & Materials')),
-        (CJ_TERMS_OTHER, _('Other'))
+    CONTRACT_TERMS_FIXED = 'fixed'
+    CONTRACT_TERMS_TARGET_PRICE = 'target'
+    CONTRACT_TERMS_TM = 't&m'
+    CONTRACT_TERMS_OTHER = 'other'
+    CONTRACT_TERMS_CHOICES = [
+        (CONTRACT_TERMS_FIXED, _('Fixed Price')),
+        (CONTRACT_TERMS_TARGET_PRICE, _('Target Price')),
+        (CONTRACT_TERMS_TM, _('Time & Materials')),
+        (CONTRACT_TERMS_OTHER, _('Other'))
     ]
+    CONTRACT_TERMS_CHOICES_VALID = tuple(i[0] for i in CONTRACT_TERMS_CHOICES)
 
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
     estimate_number = models.SlugField(max_length=20,
                                        editable=False,
                                        verbose_name=_('Estimate Number'))
     entity = models.ForeignKey('django_ledger.EntityModel',
                                editable=False,
                                on_delete=models.CASCADE,
                                verbose_name=_('Entity Model'))
     customer = models.ForeignKey('django_ledger.CustomerModel', on_delete=models.RESTRICT, verbose_name=_('Customer'))
-    terms = models.CharField(max_length=10, choices=CONTRACT_TERMS, verbose_name=_('Contract Terms'))
+    terms = models.CharField(max_length=10, choices=CONTRACT_TERMS_CHOICES, verbose_name=_('Contract Terms'))
     title = models.CharField(max_length=250,
                              verbose_name=_('Customer Estimate Title'),
                              validators=[
                                  MinLengthValidator(limit_value=5,
                                                     message=_(f'EstimateModel Title length must be greater than 5'))
                              ])
     status = models.CharField(max_length=10,
-                              choices=CJ_STATUS,
+                              choices=CONTRACT_STATUS_CHOICES,
                               verbose_name=_('Estimate Model Status'),
-                              default=CJ_STATUS_DRAFT)
+                              default=CONTRACT_STATUS_DRAFT)
 
     date_draft = models.DateField(null=True, blank=True, verbose_name=_('Date Draft'))
     date_in_review = models.DateField(null=True, blank=True, verbose_name=_('Date In Review'))
     date_approved = models.DateField(null=True, blank=True, verbose_name=_('Date Approved'))
     date_completed = models.DateField(null=True, blank=True, verbose_name=_('Date Completed'))
     date_canceled = models.DateField(null=True, blank=True, verbose_name=_('Date Canceled'))
     date_void = models.DateField(null=True, blank=True, verbose_name=_('Date Void'))
@@ -384,14 +386,15 @@
             self.entity = entity_model
 
             self.customer = customer_model
             if not date_draft:
                 self.date_draft = localdate()
 
             self.clean()
+            self.clean_fields()
 
             if commit:
                 self.save()
         return self
 
     # State....
 
@@ -400,70 +403,70 @@
         Determines if the EstimateModel is in Draft status.
 
         Returns
         -------
         bool
             True if EstimateModel is in Draft status, else False.
         """
-        return self.status == self.CJ_STATUS_DRAFT
+        return self.status == self.CONTRACT_STATUS_DRAFT
 
     def is_review(self) -> bool:
         """
         Determines if the EstimateModel is In Review status.
 
         Returns
         -------
         bool
             True if EstimateModel is In Review status, else False.
         """
-        return self.status == self.CJ_STATUS_REVIEW
+        return self.status == self.CONTRACT_STATUS_REVIEW
 
     def is_approved(self) -> bool:
         """
         Determines if the EstimateModel is in Approved status.
 
         Returns
         -------
         bool
             True if EstimateModel is in Approved status, else False.
         """
-        return self.status == self.CJ_STATUS_APPROVED
+        return self.status == self.CONTRACT_STATUS_APPROVED
 
     def is_completed(self) -> bool:
         """
         Determines if the EstimateModel is in Completed status.
 
         Returns
         -------
         bool
             True if EstimateModel is in Completed status, else False.
         """
-        return self.status == self.CJ_STATUS_COMPLETED
+        return self.status == self.CONTRACT_STATUS_COMPLETED
 
     def is_canceled(self) -> bool:
         """
         Determines if the EstimateModel is in Canceled status.
 
         Returns
         -------
         bool
             True if EstimateModel is in Canceled status, else False.
         """
-        return self.status == self.CJ_STATUS_CANCELED
+        return self.status == self.CONTRACT_STATUS_CANCELED
 
     def is_void(self):
         """
         Determines if the EstimateModel is in Void status.
 
         Returns
         -------
         bool
             True if EstimateModel is in Void status, else False.
         """
-        return self.status == self.CJ_STATUS_VOID
+        return self.status == self.CONTRACT_STATUS_VOID
 
     def is_contract(self):
         """
         Determines if the EstimateModel is considered a Contract.
 
         Returns
         -------
@@ -606,15 +609,15 @@
         Parameters
         ----------
         commit: bool
             Commits transaction into current EstimateModel instance.
         """
         if not self.can_draft():
             raise EstimateModelValidationError(f'Estimate {self.estimate_number} cannot be marked as draft...')
-        self.status = self.CJ_STATUS_DRAFT
+        self.status = self.CONTRACT_STATUS_DRAFT
         self.clean()
         if commit:
             self.save(update_fields=[
                 'status',
                 'updated'
             ])
 
@@ -687,15 +690,15 @@
             raise EstimateModelValidationError(message='Cost amount is zero!.')
         if not self.revenue_estimate:
             raise EstimateModelValidationError(message='Revenue amount is zero!.')
 
         if not date_in_review:
             date_in_review = localdate()
         self.date_in_review = date_in_review
-        self.status = self.CJ_STATUS_REVIEW
+        self.status = self.CONTRACT_STATUS_REVIEW
         self.clean()
         if commit:
             self.save(update_fields=[
                 'date_in_review',
                 'status',
                 'updated'
             ])
@@ -752,15 +755,15 @@
         if not self.can_approve():
             raise EstimateModelValidationError(
                 f'Estimate {self.estimate_number} cannot be marked as approved.'
             )
         if not date_approved:
             date_approved = localdate()
         self.date_approved = date_approved
-        self.status = self.CJ_STATUS_APPROVED
+        self.status = self.CONTRACT_STATUS_APPROVED
         self.clean()
         if commit:
             self.save(update_fields=[
                 'status',
                 'date_approved',
                 'updated'
             ])
@@ -815,15 +818,15 @@
             Optional date when EstimateModel instance is completed. Defaults to localdate().
         """
         if not self.can_complete():
             raise EstimateModelValidationError(f'Estimate {self.estimate_number} cannot be marked as completed.')
         if not date_completed:
             date_completed = localdate()
         self.date_completed = date_completed
-        self.status = self.CJ_STATUS_COMPLETED
+        self.status = self.CONTRACT_STATUS_COMPLETED
         self.clean()
         if commit:
             self.clean()
             self.save(update_fields=[
                 'status',
                 'date_completed',
                 'updated'
@@ -879,15 +882,15 @@
             Optional date when EstimateModel instance is canceled. Defaults to localdate().
         """
         if not self.can_cancel():
             raise EstimateModelValidationError(f'Estimate {self.estimate_number} cannot be canceled...')
         if not date_canceled:
             date_canceled = localdate()
         self.date_canceled = date_canceled
-        self.status = self.CJ_STATUS_CANCELED
+        self.status = self.CONTRACT_STATUS_CANCELED
         self.clean()
         if commit:
             self.save(update_fields=[
                 'status',
                 'date_canceled',
                 'updated'
             ])
@@ -942,15 +945,15 @@
             Optional date when EstimateModel instance is void. Defaults to localdate().
         """
         if not self.can_void():
             raise EstimateModelValidationError(f'Estimate {self.estimate_number} cannot be void...')
         if not date_void:
             date_void = localdate()
         self.date_void = date_void
-        self.status = self.CJ_STATUS_VOID
+        self.status = self.CONTRACT_STATUS_VOID
         self.clean()
         if commit:
             self.save(update_fields=[
                 'status',
                 'date_void',
                 'updated'
             ])
```

## django_ledger/models/invoice.py

```diff
@@ -418,24 +418,26 @@
             ledger_model: LedgerModel = LedgerModel(entity=entity_model, posted=ledger_posted)
 
             if not ledger_name:
                 ledger_name = f'Invoice {self.uuid}'
             ledger_name += f' | {ledger_name}'
             ledger_model.name = ledger_name
             ledger_model.clean()
+            ledger_model.clean_fields()
 
             self.ledger = ledger_model
 
             if commit_ledger:
                 self.ledger.save()
 
             if self.can_generate_invoice_number():
                 self.generate_invoice_number(commit=commit)
 
             self.clean()
+            self.clean_fields()
 
             if commit:
                 self.save()
         return self.ledger, self
 
     def get_migrate_state_desc(self):
         """
```

## django_ledger/models/items.py

```diff
@@ -42,14 +42,18 @@
 ITEM_LIST_RANDOM_SLUG_SUFFIX = ascii_lowercase + digits
 
 
 class ItemModelValidationError(ValidationError):
     pass
 
 
+class UnitOfMeasureModelQuerySet(models.QuerySet):
+    pass
+
+
 # UNIT OF MEASURES MODEL....
 class UnitOfMeasureModelManager(models.Manager):
     """
     A custom defined QuerySet Manager for the UnitOfMeasureModel.
     """
 
     def for_entity(self, entity_slug: str, user_model) -> QuerySet:
@@ -129,15 +133,15 @@
 
     # todo: rename to entity_model
     entity = models.ForeignKey('django_ledger.EntityModel',
                                editable=False,
                                on_delete=models.CASCADE,
                                verbose_name=_('UoM Entity'))
 
-    objects = UnitOfMeasureModelManager()
+    objects = UnitOfMeasureModelManager.from_queryset(queryset_class=UnitOfMeasureModelQuerySet)()
 
     class Meta:
         abstract = True
         indexes = [
             models.Index(fields=['entity'])
         ]
         unique_together = [
@@ -159,183 +163,154 @@
         Filters the QuerySet to only active Item Models.
 
         Returns
         -------
         ItemModelQuerySet
             A QuerySet with applied filters.
         """
-        return self.filter(active=True)
-
+        return self.filter(is_active=True)
 
-class ItemModelManager(models.Manager):
-    """
-    A custom defined ItemModelManager that implement custom QuerySet methods related to the ItemModel
-    """
-
-    def for_entity(self, entity_slug, user_model):
+    def products(self):
         """
-        Returns a QuerySet of ItemModel associated with a specific EntityModel & UserModel.
-        May pass an instance of EntityModel or a String representing the EntityModel slug.
-
-        Parameters
-        ----------
-        entity_slug: str or EntityModel
-            The entity slug or EntityModel used for filtering the QuerySet.
-        user_model
-            The request UserModel to check for privileges.
+        Filters the QuerySet to ItemModels that only qualify as products.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        qs = self.get_queryset()
-        if isinstance(entity_slug, lazy_loader.get_entity_model()):
-            return qs.filter(
-                Q(entity=entity_slug) &
-                (
-                        Q(entity__managers__in=[user_model]) |
-                        Q(entity__admin=user_model)
-                )
-            ).select_related('uom')
-        return qs.filter(
-            Q(entity__slug__exact=entity_slug) &
+        return self.filter(
             (
-                    Q(entity__managers__in=[user_model]) |
-                    Q(entity__admin=user_model)
-            )
-        ).select_related('uom')
+                    Q(is_product_or_service=True) &
+                    Q(for_inventory=True)
+            ) |
+            Q(item_role=ItemModel.ITEM_ROLE_PRODUCT)
+        )
 
-    def for_entity_active(self, entity_slug, user_model):
+    def services(self):
         """
-        Returns a QuerySet of Active ItemModel associated with a specific EntityModel & UserModel.
-        May pass an instance of EntityModel or a String representing the EntityModel slug.
-
-        Parameters
-        ----------
-        entity_slug: str or EntityModel
-            The entity slug or EntityModel used for filtering the QuerySet.
-        user_model
-            The request UserModel to check for privileges.
+        Filters the QuerySet to ItemModels that only qualify as services.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(is_active=True)
+        return self.filter(
+            (
+                    Q(is_product_or_service=True) &
+                    Q(for_inventory=False)
+            ) |
+            Q(item_role=ItemModel.ITEM_ROLE_SERVICE)
+        )
 
-    def products(self, entity_slug, user_model):
+    def expenses(self):
         """
-        Returns a QuerySet of ItemModels that only qualify as products for a specific EntityModel & UserModel.
-        May pass an instance of EntityModel or a String representing the EntityModel slug.
-
-        Parameters
-        ----------
-        entity_slug: str or EntityModel
-            The entity slug or EntityModel used for filtering the QuerySet.
-        user_model
-            The request UserModel to check for privileges.
+        Filters the QuerySet to ItemModels that only qualify as expenses.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(
+        return self.filter(
             (
-                    Q(is_product_or_service=True) &
-                    Q(for_inventory=True)
-            ) |
-            Q(item_role=ItemModel.ITEM_ROLE_PRODUCT)
+                    Q(is_product_or_service=False) &
+                    Q(for_inventory=False)
+            ) | Q(item_role=ItemModel.ITEM_ROLE_EXPENSE)
         )
 
-    def services(self, entity_slug, user_model):
+    def inventory_wip(self):
         """
-        Returns a QuerySet of ItemModels that only qualify as active services for a specific EntityModel & UserModel.
-        May pass an instance of EntityModel or a String representing the EntityModel slug.
-
-        Parameters
-        ----------
-        entity_slug: str or EntityModel
-            The entity slug or EntityModel used for filtering the QuerySet.
-        user_model
-            The request UserModel to check for privileges.
+        Filters the QuerySet to ItemModels that only qualify as inventory.
+        These types of items cannot be sold as they are not considered a finished product.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(
+        return self.filter(
             (
-                    Q(is_product_or_service=True) &
-                    Q(for_inventory=False)
-            ) |
-            Q(item_role=ItemModel.ITEM_ROLE_SERVICE)
+                    Q(is_product_or_service=False) &
+                    Q(for_inventory=True)
+            ) | Q(item_role=ItemModel.ITEM_ROLE_INVENTORY)
         )
 
-    def expenses(self, entity_slug, user_model):
+    def inventory_all(self):
         """
-        Returns a QuerySet of ItemModels that only qualify as active products for a specific EntityModel & UserModel.
-        May pass an instance of EntityModel or a String representing the EntityModel slug.
+        Filters the QuerySet to ItemModels that only qualify as inventory.
+        These types of items may be finished or unfinished.
 
-        Parameters
-        ----------
-        entity_slug: str or EntityModel
-            The entity slug or EntityModel used for filtering the QuerySet.
-        user_model
-            The request UserModel to check for privileges.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(
+        return self.filter(
             (
-                    Q(is_product_or_service=False) &
-                    Q(for_inventory=False)
-            ) | Q(item_role=ItemModel.ITEM_ROLE_EXPENSE)
+                    (
+                            Q(is_product_or_service=False) &
+                            Q(for_inventory=True)
+                    ) | Q(item_role=ItemModel.ITEM_ROLE_INVENTORY)
+            ) |
+            (
+                    (
+                            Q(is_product_or_service=True) &
+                            Q(for_inventory=True)
+                    ) |
+                    Q(item_role=ItemModel.ITEM_ROLE_PRODUCT)
+
+            )
         )
 
-    def inventory_wip(self, entity_slug, user_model):
+
+class ItemModelManager(models.Manager):
+    """
+    A custom defined ItemModelManager that implement custom QuerySet methods related to the ItemModel
+    """
+
+    def for_entity(self, entity_slug, user_model):
         """
-        Returns a QuerySet of ItemModels that only qualify as inventory in progress for a specific EntityModel &
-        UserModel. These types of items cannot be sold as they are not considered a finished product.
+        Returns a QuerySet of ItemModel associated with a specific EntityModel & UserModel.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
         Parameters
         ----------
         entity_slug: str or EntityModel
             The entity slug or EntityModel used for filtering the QuerySet.
         user_model
             The request UserModel to check for privileges.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
+        qs = self.get_queryset()
+        if isinstance(entity_slug, lazy_loader.get_entity_model()):
+            return qs.filter(
+                Q(entity=entity_slug) &
+                (
+                        Q(entity__managers__in=[user_model]) |
+                        Q(entity__admin=user_model)
+                )
+            ).select_related('uom')
         return qs.filter(
+            Q(entity__slug__exact=entity_slug) &
             (
-                    Q(is_product_or_service=False) &
-                    Q(for_inventory=True)
-            ) | Q(item_role=ItemModel.ITEM_ROLE_INVENTORY)
-        )
+                    Q(entity__managers__in=[user_model]) |
+                    Q(entity__admin=user_model)
+            )
+        ).select_related('uom')
 
-    def inventory_all(self, entity_slug, user_model):
+    def for_entity_active(self, entity_slug, user_model):
         """
-        Returns a QuerySet of ItemModels that qualify as inventory for a specific EntityModel &
-        UserModel. These types of items may be finished or unfinished.
+        Returns a QuerySet of Active ItemModel associated with a specific EntityModel & UserModel.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
         Parameters
         ----------
         entity_slug: str or EntityModel
             The entity slug or EntityModel used for filtering the QuerySet.
         user_model
@@ -343,30 +318,15 @@
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
         qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(
-            (
-                    (
-                            Q(is_product_or_service=False) &
-                            Q(for_inventory=True)
-                    ) | Q(item_role=ItemModel.ITEM_ROLE_INVENTORY)
-            ) |
-            (
-                    (
-                            Q(is_product_or_service=True) &
-                            Q(for_inventory=True)
-                    ) |
-                    Q(item_role=ItemModel.ITEM_ROLE_PRODUCT)
-
-            )
-        )
+        return qs.filter(is_active=True)
 
     def for_bill(self, entity_slug, user_model):
         """
         Returns a QuerySet of ItemModels that can only be used for BillModels for a specific EntityModel &
         UserModel. These types of items qualify as expenses or inventory purchases.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
@@ -405,15 +365,16 @@
             The request UserModel to check for privileges.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        return self.inventory_all(entity_slug=entity_slug, user_model=user_model)
+        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
+        return qs.inventory_all()
 
     def for_estimate(self, entity_slug: str, user_model):
         """
         Returns a QuerySet of ItemModels that can only be used for EstimateModels for a specific EntityModel &
         UserModel. These types of items qualify as products.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
@@ -425,15 +386,16 @@
             The request UserModel to check for privileges.
 
         Returns
         -------
         ItemModelQuerySet
             A Filtered ItemModelQuerySet.
         """
-        return self.products(entity_slug=entity_slug, user_model=user_model)
+        qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
+        return qs.products()
 
 
 class ItemModelAbstract(CreateUpdateMixIn):
     """
     Base implementation of the ItemModel.
 
     Attributes
@@ -498,14 +460,15 @@
     ITEM_TYPE_CHOICES = [
         (ITEM_TYPE_LABOR, _('Labor')),
         (ITEM_TYPE_MATERIAL, _('Material')),
         (ITEM_TYPE_EQUIPMENT, _('Equipment')),
         (ITEM_TYPE_LUMP_SUM, _('Lump Sum')),
         (ITEM_TYPE_OTHER, _('Other')),
     ]
+    ITEM_TYPE_VALID_CHOICES = {i[0] for i in ITEM_TYPE_CHOICES}
 
     ITEM_ROLE_EXPENSE = 'expense'
     ITEM_ROLE_INVENTORY = 'inventory'
     ITEM_ROLE_SERVICE = 'service'
     ITEM_ROLE_PRODUCT = 'product'
     ITEM_ROLE_CHOICES = [
         ('expense', _('Expense')),
@@ -848,14 +811,21 @@
 
     def in_transit(self):
         return self.filter(po_item_status=ItemTransactionModel.STATUS_IN_TRANSIT)
 
     def is_ordered(self):
         return self.filter(po_item_status=ItemTransactionModel.STATUS_ORDERED)
 
+    def is_orphan(self):
+        return self.filter(
+            Q(bill_model_id__isnull=True) &
+            Q(po_model_id__isnull=True) &
+            Q(ce_model_id__isnull=True)
+        )
+
     def get_estimate_aggregate(self):
         return {
             'ce_cost_estimate__sum': sum(i.ce_cost_estimate for i in self),
             'ce_revenue_estimate__sum': sum(i.ce_revenue_estimate for i in self),
             'total_items': len(self)
         }
 
@@ -903,58 +873,23 @@
         return qs.filter(
             Q(ce_model_id__exact=ce_pk) |
             Q(po_model__ce_model_id__exact=ce_pk) |
             Q(bill_model__ce_model_id__exact=ce_pk) |
             Q(invoice_model__ce_model_id__exact=ce_pk)
         )
 
-    def inventory_pipeline(self, entity_slug, user_model):
-        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(
-            Q(item_model__for_inventory=True) &
-            Q(bill_model__isnull=False) &
-            Q(po_item_status__in=[
-                ItemTransactionModel.STATUS_ORDERED,
-                ItemTransactionModel.STATUS_IN_TRANSIT,
-                ItemTransactionModel.STATUS_RECEIVED,
-            ])
-        )
-
-    def inventory_pipeline_aggregate(self, entity_slug: str, user_model):
-        qs = self.inventory_pipeline(entity_slug=entity_slug, user_model=user_model)
-        return qs.values(
-            'item_model__name',
-            'item_model__uom__name',
-            'po_item_status').annotate(
-            total_quantity=Sum('quantity'),
-            total_value=Sum('total_amount')
-        )
-
-    def inventory_pipeline_ordered(self, entity_slug, user_model):
-        qs = self.inventory_pipeline(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(po_item_status=ItemTransactionModel.STATUS_ORDERED)
-
-    def inventory_pipeline_intransit(self, entity_slug, user_model):
-        qs = self.inventory_pipeline(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(po_item_status=ItemTransactionModel.STATUS_IN_TRANSIT)
-
-    def inventory_pipeline_received(self, entity_slug, user_model):
-        qs = self.inventory_pipeline(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(po_item_status=ItemTransactionModel.STATUS_RECEIVED)
-
-    def inventory_invoiced(self, entity_slug, user_model):
-        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(
-            Q(item_model__for_inventory=True) &
-            Q(invoice_model__isnull=False)
-        )
+    # INVENTORY METHODS....
+    def for_entity_inventory(self, entity_slug):
+        qs = self.get_queryset()
+        return qs.filter(item_model__entity__slug__exact=entity_slug)
 
-    def inventory_count(self, entity_slug, user_model):
-        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
+    # Todo move this to QuerySet....
+    def inventory_count(self, entity_slug):
         PurchaseOrderModel = lazy_loader.get_purchase_order_model()
+        qs = self.for_entity_inventory(entity_slug)
         qs = qs.filter(
             Q(item_model__for_inventory=True) &
             (
                 # received inventory...
                     (
                             Q(bill_model__isnull=False) &
                             Q(po_model__po_status=PurchaseOrderModel.PO_STATUS_APPROVED) &
@@ -992,20 +927,53 @@
                      )
             ),
             value_onhand=Coalesce(
                 ExpressionWrapper(F('quantity_onhand') * F('cost_average'),
                                   output_field=DecimalField(decimal_places=3)), Value(0.0), output_field=DecimalField())
         )
 
-    def is_orphan(self, entity_slug, user_model):
-        qs = self.get_queryset()
+    def inventory_pipeline(self, entity_slug):
+        qs = self.for_entity_inventory(entity_slug)
         return qs.filter(
-            Q(bill_model_id__isnull=True) &
-            Q(po_model_id__isnull=True) &
-            Q(ce_model_id__isnull=True)
+            Q(item_model__for_inventory=True) &
+            Q(bill_model__isnull=False) &
+            Q(po_item_status__in=[
+                ItemTransactionModel.STATUS_ORDERED,
+                ItemTransactionModel.STATUS_IN_TRANSIT,
+                ItemTransactionModel.STATUS_RECEIVED,
+            ])
+        )
+
+    def inventory_pipeline_aggregate(self, entity_slug: str):
+        qs = self.inventory_pipeline(entity_slug=entity_slug)
+        return qs.values(
+            'item_model__name',
+            'item_model__uom__name',
+            'po_item_status').annotate(
+            total_quantity=Sum('quantity'),
+            total_value=Sum('total_amount')
+        )
+
+    def inventory_pipeline_ordered(self, entity_slug):
+        qs = self.inventory_pipeline(entity_slug=entity_slug)
+        return qs.filter(po_item_status=ItemTransactionModel.STATUS_ORDERED)
+
+    def inventory_pipeline_in_transit(self, entity_slug):
+        qs = self.inventory_pipeline(entity_slug=entity_slug)
+        return qs.filter(po_item_status=ItemTransactionModel.STATUS_IN_TRANSIT)
+
+    def inventory_pipeline_received(self, entity_slug):
+        qs = self.inventory_pipeline(entity_slug=entity_slug)
+        return qs.filter(po_item_status=ItemTransactionModel.STATUS_RECEIVED)
+
+    def inventory_invoiced(self, entity_slug):
+        qs = self.for_entity_inventory(entity_slug)
+        return qs.filter(
+            Q(item_model__for_inventory=True) &
+            Q(invoice_model__isnull=False)
         )
 
 
 class ItemTransactionModelAbstract(CreateUpdateMixIn):
     DECIMAL_PLACES = 2
 
     STATUS_NOT_ORDERED = 'not_ordered'
@@ -1396,8 +1364,8 @@
     Base ItemTransactionModel from Abstract.
     """
 
 
 class ItemModel(ItemModelAbstract):
     """
     Base ItemModel from Abstract.
-    """
+    """
```

## django_ledger/models/mixins.py

```diff
@@ -946,14 +946,15 @@
 
     TERM_CHOICES = [
         (TERMS_ON_RECEIPT, 'Due On Receipt'),
         (TERMS_NET_30, 'Net 30 Days'),
         (TERMS_NET_60, 'Net 60 Days'),
         (TERMS_NET_90, 'Net 90 Days'),
     ]
+    TERM_CHOICES_VALID = tuple(i[0] for i in TERM_CHOICES)
 
     TERM_DAYS_MAPPING = {
         TERMS_ON_RECEIPT: 0,
         TERMS_NET_30: 30,
         TERMS_NET_60: 60,
         TERMS_NET_90: 90,
         TERMS_NET_90_PLUS: 120
```

## django_ledger/models/purchase_order.py

```diff
@@ -253,37 +253,33 @@
             self.entity_id is not None,
             self.date_draft,
             self.po_status
         ])
 
     def configure(self,
                   entity_slug: Union[str, EntityModel],
+                  po_title: Optional[str] = None,
                   user_model: Optional[UserModel] = None,
                   draft_date: Optional[date] = None,
                   estimate_model=None,
                   commit: bool = False):
         """
         A configuration hook which executes all initial PurchaseOrderModel setup on to the EntityModel and all initial
         values of the EntityModel. Can only call this method once in the lifetime of a PurchaseOrderModel.
 
         Parameters
         __________
-
         entity_slug: str or EntityModel
             The entity slug or EntityModel to associate the Bill with.
-
         user_model:
             The UserModel making the request to check for QuerySet permissions.
-
         ledger_posted:
             An option to mark the BillModel Ledger as posted at the time of configuration. Defaults to False.
-
         bill_desc: str
             An optional description appended to the LedgerModel name.
-
         commit: bool
             Saves the current BillModel after being configured.
 
         Returns
         -------
         PurchaseOrderModel
             The configured PurchaseOrderModel instance.
@@ -303,15 +299,24 @@
             self.po_status = PurchaseOrderModel.PO_STATUS_DRAFT
 
             if estimate_model:
                 self.action_bind_estimate(estimate_model=estimate_model, commit=False)
 
             self.entity = entity_model
 
+            if self.can_generate_po_number():
+                self.generate_po_number(commit=commit)
+
+            if not po_title and not self.po_title and self.po_number:
+                self.po_title = f'PO Number {self.po_number}'
+            else:
+                self.po_title = po_title
+
             self.clean()
+            self.clean_fields()
             if commit:
                 self.save()
         return self
 
     def validate_item_transaction_qs(self, queryset: Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]):
         """
         Validates that the entire ItemTransactionModelQuerySet is bound to the PurchaseOrderModel.
@@ -575,14 +580,21 @@
             True if PurchaseOrderModel can be bound to an EstimateModel, else False.
         """
         if self.is_contract_bound():
             if raise_exception:
                 raise PurchaseOrderModelValidationError(
                     f'PO {self.po_number} already bound to Estimate {self.ce_model.estimate_number}')
             return False
+        elif self.entity_id != estimate_model.entity_id:
+            if raise_exception:
+                raise PurchaseOrderModelValidationError(
+                    f'Invalid EstimateModel for entity {self.entity.slug}'
+                )
+            return False
+
         # check if estimate_model is passed and raise exception if needed...
         is_approved = estimate_model.is_approved()
         if not is_approved and raise_exception:
             raise PurchaseOrderModelValidationError(f'Cannot bind estimate that is not approved.')
         return all([
             is_approved
         ])
```

## django_ledger/tests/test_auth.py

 * *Ordering differences only*

```diff
@@ -1,11 +1,11 @@
 from django.urls import reverse
 
-from django_ledger.tests.base import DjangoLedgerBaseTest
 from dev_env.settings import LOGIN_URL
+from django_ledger.tests.base import DjangoLedgerBaseTest
 
 
 class AuthTest(DjangoLedgerBaseTest):
     TEST_URLS = [
         reverse('django_ledger:home'),
         reverse('django_ledger:entity-dashboard',
                 kwargs={
```

## django_ledger/tests/test_bill.py

```diff
@@ -81,15 +81,15 @@
             if 'ce_pk' in kwargs:
                 url_kwargs['ce_pk'] = uuid4()
 
             url = reverse(f'django_ledger:{path}', kwargs=url_kwargs)
             response = self.CLIENT.get(url, follow=False)
             redirect_url = urlparse(response.url)
             redirect_path = redirect_url.path
-            login_path = DJANGO_LEDGER_LOGIN_URL
+            login_path = reverse(viewname='django_ledger:login')
 
             self.assertEqual(response.status_code, 302, msg=f'{path} view is not protected.')
             self.assertEqual(redirect_path, login_path, msg=f'{path} view not redirecting to correct auth URL.')
 
     def test_bill_list(self):
 
         self.login_client()
```

## django_ledger/views/entity.py

```diff
@@ -82,15 +82,15 @@
             admin=user_model
         )
         entity_model: EntityModel = EntityModel.add_root(instance=entity_model)
         default_coa_model = entity_model.create_chart_of_accounts(assign_as_default=True, commit=True)
 
         if default_coa:
             entity_model.populate_default_coa(activate_accounts=activate_accounts,
-                                              chart_of_accounts=default_coa_model)
+                                              coa_model=default_coa_model)
 
         if sample_data:
             entity_generator = EntityDataGenerator(
                 entity_model=entity_model,
                 user_model=self.request.user,
                 start_date=localdate() - timedelta(days=30 * 8),
                 capital_contribution=Decimal.from_float(50000),
```

## django_ledger/views/inventory.py

```diff
@@ -58,27 +58,20 @@
             self.queryset = EntityModel.objects.for_user(
                 user_model=self.request.user
             )
         return super().get_queryset()
 
     def counted_inventory(self):
         entity_slug = self.kwargs['entity_slug']
-        user_model = self.request.user
-        return ItemTransactionModel.objects.inventory_count(
-            entity_slug=entity_slug,
-            user_model=user_model
-        )
+        return ItemTransactionModel.objects.inventory_count(entity_slug=entity_slug)
 
     def recorded_inventory(self, queryset=None, as_values=True):
         entity_model: EntityModel = self.get_object()
         user_model = self.request.user
-        recorded_qs = entity_model.recorded_inventory(
-            user_model=user_model,
-            item_qs=queryset
-        )
+        recorded_qs = entity_model.recorded_inventory(item_qs=queryset)
         return recorded_qs
 
     def get_context_data(self, adjustment=None, counted_qs=None, recorded_qs=None, **kwargs):
         self.object = self.get_object()
         context = super(InventoryRecountView, self).get_context_data(**kwargs)
         context['page_title'] = _('Inventory Recount')
         context['header_title'] = _('Inventory Recount')
@@ -120,11 +113,9 @@
                                     })
             )
         context = self.get_context_data(**kwargs)
         return self.render_to_response(context)
 
     def update_inventory(self):
         entity_model: EntityModel = self.get_object()
-        adj, counted_qs, recorded_qs = entity_model.update_inventory(
-            user_model=self.request.user,
-            commit=True)
+        adj, counted_qs, recorded_qs = entity_model.update_inventory(commit=True)
         return adj, counted_qs, recorded_qs
```

## django_ledger/views/item.py

```diff
@@ -151,18 +151,18 @@
 
 # PRODUCTS VIEWS...
 class ProductItemModelModelViewQuerySetMixIn:
     queryset = None
 
     def get_queryset(self):
         if not self.queryset:
-            self.queryset = ItemModel.objects.products(
+            self.queryset = ItemModel.objects.for_entity(
                 entity_slug=self.kwargs['entity_slug'],
                 user_model=self.request.user
-            ).select_related(
+            ).products().select_related(
                 'earnings_account', 'cogs_account',
                 'inventory_account', 'uom').order_by('-updated')
         return super().get_queryset()
 
 
 class ProductListView(DjangoLedgerSecurityMixIn,
                       ProductItemModelModelViewQuerySetMixIn,
@@ -281,18 +281,18 @@
 
 # SERVICES VIEWS...
 class ServiceItemModelModelViewQuerySetMixIn:
     queryset = None
 
     def get_queryset(self):
         if not self.queryset:
-            self.queryset = ItemModel.objects.services(
+            self.queryset = ItemModel.objects.for_entity(
                 entity_slug=self.kwargs['entity_slug'],
                 user_model=self.request.user
-            ).select_related(
+            ).services().select_related(
                 'earnings_account', 'cogs_account',
                 'inventory_account', 'uom').order_by('-updated')
         return super().get_queryset()
 
 
 class ServiceListView(DjangoLedgerSecurityMixIn,
                       ServiceItemModelModelViewQuerySetMixIn,
@@ -351,18 +351,18 @@
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
     def get_queryset(self):
-        return ItemModel.objects.services(
+        return ItemModel.objects.for_entity(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user
-        )
+        ).services()
 
     def get_form(self, form_class=None):
         return ServiceUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
@@ -411,18 +411,18 @@
 # EXPENSE ITEMS VIEW...
 
 class ExpenseItemItemModelModelViewQuerySetMixIn:
     queryset = None
 
     def get_queryset(self):
         if not self.queryset:
-            self.queryset = ItemModel.objects.expenses(
+            self.queryset = ItemModel.objects.for_entity(
                 entity_slug=self.kwargs['entity_slug'],
                 user_model=self.request.user
-            ).select_related('expense_account', 'uom').order_by('-updated')
+            ).expenses().select_related('expense_account', 'uom').order_by('-updated')
         return super().get_queryset()
 
 
 class ExpenseItemModelListView(DjangoLedgerSecurityMixIn, ExpenseItemItemModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/expense/expense_list.html'
     PAGE_TITLE = _('Expense Items')
     context_object_name = 'expense_list'
@@ -495,18 +495,18 @@
 # INVENTORY VIEWS...
 
 class InventoryItemItemModelModelViewQuerySetMixIn:
     queryset = None
 
     def get_queryset(self):
         if not self.queryset:
-            self.queryset = ItemModel.objects.inventory_wip(
+            self.queryset = ItemModel.objects.for_entity(
                 entity_slug=self.kwargs['entity_slug'],
                 user_model=self.request.user
-            ).select_related('inventory_account', 'cogs_account', 'uom').order_by('-updated')
+            ).inventory_wip().select_related('inventory_account', 'cogs_account', 'uom').order_by('-updated')
         return super().get_queryset()
 
 
 class InventoryItemModelListView(DjangoLedgerSecurityMixIn, InventoryItemItemModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/inventory/inventory_item_list.html'
     PAGE_TITLE = _('Inventory Items')
     context_object_name = 'inventory_item_list'
```

## Comparing `django_ledger-0.5.3.0.dist-info/AUTHORS.md` & `django_ledger-0.5.3.1.dist-info/AUTHORS.md`

 * *Files identical despite different names*

## Comparing `django_ledger-0.5.3.0.dist-info/LICENSE` & `django_ledger-0.5.3.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `django_ledger-0.5.3.0.dist-info/METADATA` & `django_ledger-0.5.3.1.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: django-ledger
-Version: 0.5.3.0
+Version: 0.5.3.1
 Summary: Bookkeeping & Financial analysis backend for Django. Balance Sheet, Income Statements, Chart of Accounts, Entities
 Author-email: Miguel Sanda <msanda@arrobalytics.com>
 Maintainer-email: Miguel Sanda <msanda@arrobalytics.com>
 License: GPLv3 License
 Project-URL: Homepage, https://www.djangoledger.com
 Project-URL: Bug Tracker, https://github.com/arrobalytics/django-ledger/issues
 Project-URL: Documentation, https://django-ledger.readthedocs.io/en/latest/
@@ -105,44 +105,44 @@
 * Bugfixes & UI/UX Enhancements.
 
 ### Version 0.5
 
 More details available in the [Django Ledger v0.5 Page](https://www.arrobalytics.com/blog/2021/12/07/django-ledger-v05/)
 .
 
+* __0.5__: Testing framework implementation that will include:
+    * Unit tests using the [Built-in Django](https://docs.djangoproject.com/en/3.1/topics/testing/) unit test modules.
+    * Behavioral Driven Testing using [behave](https://behave.readthedocs.io/en/latest/) library.
+    * __Need help!!!! If you want to contribute PLEASE ADD UNIT TESTS!!!__
+    * Start creating basic package documentation via [Sphinx](https://www.sphinx-doc.org/en/master/)
+        * Document code and functions within code base.
+        * Generate HTML documentation.
+    * Work with Accountants, Subject Experts and Developers to define an initial list of Unit Tests to validate output __(
+      help needed!)__.
+    * Update package and code documentation.
+    * Bugfixes & UI/UX Enhancements.
 * __0.5.0__: Inventory tracking.
     * Average Cost.
 * __0.5.1__: Customer estimates & contract tracking.
     * Link Estimate/PO/Bill/Invoice workflow.
     * Journal Entry activity determination & validation (for cash flow).
 * __0.5.2__: Cash flow statement.
     * Human Readable Journal Entry document numbers.
     * Hierarchical Account Model Management.
     * Generate all Django Ledger Model documentation.
-* __0.5.3__: Closing entries, snapshots & trial balance import.
-    * __0.5.3.0__: High Level EntityModel API.
-    * __0.5.3.1__: Balance Sheet Statement, Income Statement & Cash Flow Statement API & PDF report export.
-    * __0.5.3.2__: Closing entries and snapshots.
-    * __0.5.3.3__: Chart of Accounts Import.
-    * __0.5.3.4__: Trial Balance Import.
-    * __0.5.3.5__: GraphQL API.
-* __0.5.4__: Testing framework implementation that will include:
-    * Unit tests using the [Built-in Django](https://docs.djangoproject.com/en/3.1/topics/testing/) unit test modules.
-    * Behavioral Driven Testing using [behave](https://behave.readthedocs.io/en/latest/) library.
-    * __Need help!!!! If you want to contribute PLEASE ADD UNIT TESTS!!!__
-* Start creating basic package documentation via [Sphinx](https://www.sphinx-doc.org/en/master/)
-    * Document code and functions within code base.
-    * Generate HTML documentation.
-* Work with Accountants, Subject Experts and Developers to define an initial list of Unit Tests to validate output __(
-  help needed!)__.
-* Update package and code documentation.
-* Bugfixes & UI/UX Enhancements.
+* __0.5.3__: High Level EntityModel API.
+* __0.5.4__: Balance Sheet Statement, Income Statement & Cash Flow Statement API & PDF report export.
+* __0.5.5__: Closing entries and snapshots.
+* __0.5.6__: Chart of Accounts Import.
+* __0.5.7__: Trial Balance Import.
+* __0.5.8__: GraphQL API.
 
 ### Version 0.6
 
+* IO Digest Context Manager
 * Credit Line Models.
 * Time tracking.
 * Transaction tagging.
 * Update package and code documentation.
 * Bugfixes & UI/UX Enhancements.
 
 ### Version 0.7
```

## Comparing `django_ledger-0.5.3.0.dist-info/RECORD` & `django_ledger-0.5.3.1.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-django_ledger/__init__.py,sha256=Co-XUnNCApAGGtXnP9qgy-IuMfgpLLt9_iIXVA6Jfis,458
+django_ledger/__init__.py,sha256=083rA387621nPQHzWYBtkryQPQbBhwFu8CYzC5aOM-o,458
 django_ledger/admin.py,sha256=cfaobDIf_ATw_LHL4O3AJxUZhaLa75PC-EXOpmA28mE,3723
 django_ledger/apps.py,sha256=H-zEWUjKGakgSDSZmLIoXChZ2h6e0dth0ZO5SpoT-8U,163
 django_ledger/exceptions.py,sha256=rML8sQQ0Hq-DYMLZ76dfw2RYSAsXWUoyHuyC_yP9o1o,491
 django_ledger/settings.py,sha256=6OSMxKv3UX4NmsMSC2-EWvp_eVmEcHgmaitrreKukfk,5964
 django_ledger/utils.py,sha256=GFfjt_PL_nq7PRTkITmcUQBbtwzq3blTtv8NXctYh6Y,5064
 django_ledger/contrib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 django_ledger/contrib/django_ledger_graphene/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
@@ -57,47 +57,47 @@
 django_ledger/forms/ledger.py,sha256=ei1gGV5o43_8tC9ihnz9X5yjTRy80dsKY2qM8lny2G4,1178
 django_ledger/forms/purchase_order.py,sha256=XIi7v6ZaBd9nYgcWLmgNKm9751XBXpbwmUtlpPJklHI,7479
 django_ledger/forms/transactions.py,sha256=o6NKQNKv_4qvJiRkiVSj6Pn7iKX9VVO8TINOw2lfcxc,3075
 django_ledger/forms/unit.py,sha256=rXUefjpuAmUU0vPOqu1ObO4k-bN-_Q6kOqHJ4kp_Vlg,1131
 django_ledger/forms/utils.py,sha256=sgkwBZs15_rZ5NT7h-8Z7wi3-ItM1E1sqoVDo3NQ5Jc,513
 django_ledger/forms/vendor.py,sha256=Nuh8MmSpz4ycMZwiVe--U9Ec6ezIsfACHDkhA2SyiZ4,2215
 django_ledger/io/__init__.py,sha256=gTWfEu1iEdL-TDJiZzOhgzxWuoWnWKcGIpRa4Q04deU,322
-django_ledger/io/data_generator.py,sha256=3zC4ecnnoBc9g8IFHZdIp6hzvokb_1IzgblP1RNrDVY,33115
+django_ledger/io/data_generator.py,sha256=_DZsBTVuHxMRw2G299ARtYHDpluqoTbz_PUa_-Z71y0,32043
 django_ledger/io/io_context.py,sha256=my35khZSO6kMjHZ_O3L5u1lo85kb_6Ua1Iw4yymB25g,19213
 django_ledger/io/io_mixin.py,sha256=TmcY9Cg_Nu2oKWrj3qcOud_d_ZGhgh-zI6hQqurTYaY,19863
 django_ledger/io/ofx.py,sha256=JnmDjhIpLySoixK1WVe6DivRuu02rYsBjqI8yi5Opzs,1488
 django_ledger/io/ratios.py,sha256=BUMdULLE8mu8qEvdC7jXWjYT6vfsldh8yevGwduR7Lg,3568
-django_ledger/io/roles.py,sha256=J86Fwn_EoEXpf3hP9KxkpSTBhmdOWIyi2DYJrbQj18M,19348
+django_ledger/io/roles.py,sha256=mp5Rf_fpyqRVuxQOb0l48WCwZZ_c-0_AdDARmEToOL8,19806
 django_ledger/management/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 django_ledger/management/commands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 django_ledger/management/commands/generate_oauth2_codes.py,sha256=H92pSOMA0VFjdCLXOqdIWql-aKU12uaAPdXgz2DB9Go,1495
 django_ledger/migrations/0001_initial.py,sha256=-C5ZH0eQJK-3oafy7Ld2WoMp6HqzLts1eMrLV_0qfsQ,74729
 django_ledger/migrations/0002_alter_journalentrymodel_managers_and_more.py,sha256=-lH3NCGoUX2zJ3GT5VakvPx7VR7lXz4S_FkTccJQzzE,703
 django_ledger/migrations/0003_remove_accountmodel_django_ledg_role_1bff96_idx_and_more.py,sha256=tw1ZrXynmuUfy8G_NtRJ7ojLFCSk89oDTsLpHWCst1Y,6069
 django_ledger/migrations/0004_remove_itemmodel_depth_remove_itemmodel_numchild_and_more.py,sha256=w9-ReO6JP7bMYvBX0Ne3_0jIeLUbuVV4J7V_1lT4zR8,586
 django_ledger/migrations/0005_remove_itemmodel_django_ledg_invento_dbf206_idx_and_more.py,sha256=VLACIk4f_xTW-gaHsMS2pYggCQazxGvrJPphw6hAZyM,1569
 django_ledger/migrations/0006_alter_journalentrymodel_je_number_and_more.py,sha256=kwj9Jek271-j9CE-dlj8Dtg0Q3fzw4MA9Sw_NBhUehM,749
 django_ledger/migrations/0007_remove_customermodel_django_ledg_custome_16f95a_idx_and_more.py,sha256=b6nC2-sjEWj1v2dosDnciDu-dFLPmqUloHWWTSDJJek,4027
 django_ledger/migrations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 django_ledger/models/__init__.py,sha256=AZVdWQeEW-z-o9sAex4X2bvPxqrcyDG8l2mfVs_cz3E,745
-django_ledger/models/accounts.py,sha256=1AiyGePeP369PLIzNtt-Eos52TA71eJ9VO8Bc4IZxnI,25403
+django_ledger/models/accounts.py,sha256=HBSLRa-sc5S9byckUXfGGw2JaYrRO7xJgrwwihZPdjE,25495
 django_ledger/models/bank_account.py,sha256=MZMpAYOv2xGgijQRSitfJv_snKNqeuEiCvkYrK73_Yk,7658
-django_ledger/models/bill.py,sha256=5vbJz2QUgOKaibFEbZWVJRsupvXLqOuavwUAaZeRG-4,57733
+django_ledger/models/bill.py,sha256=_nYX7tErSbEYmV2VlmLoRG-HMpl2JXVG1MNWBNJFQSU,57805
 django_ledger/models/coa.py,sha256=D482ogfmLoFp45BL6XDXgJNWq_nM4m_EnwYbmJt9hRc,12561
-django_ledger/models/coa_default.py,sha256=nMVSgsA34Yzb7Df5WI2A2FuDEqDMJMX2iQVEz15U_8U,27087
+django_ledger/models/coa_default.py,sha256=l8UOS0QP4vXxBjNBO26HzHt9_c9cngdvp2y7clU3U8Q,27169
 django_ledger/models/customer.py,sha256=KjyDdFzJYm_y7ljlDEheInqXxeiExK3sWfDDDO5ZGDE,12057
 django_ledger/models/data_import.py,sha256=ABD2HU5ZP6BnaPs6DzRvjP9UmIVtobAl0MY_oUGsjxI,3485
-django_ledger/models/entity.py,sha256=khoiuW9F3owYtSr2sMJXeE5441p_YDNq2x4MJ8IaR1Y,70525
-django_ledger/models/estimate.py,sha256=PVmABu9iCXKPJO-uI9QgndsbkSBJKcKbi1bjJwCQbUU,53553
-django_ledger/models/invoice.py,sha256=x1VPqNcPQvdytqpu5mnDkA0HJ43KNjiiUXVRNUa8Y18,54335
-django_ledger/models/items.py,sha256=5X50SQWT3gMmpMwDUYL8su4OLKv2qpa4kJNgg79pd9E,55542
+django_ledger/models/entity.py,sha256=J7ZxZjDT0RxBaFSBuomUNBGIW1hvYWBuEM8laV7dX5k,95834
+django_ledger/models/estimate.py,sha256=F3C4uIlPcc4HETcmkV6Ed9ZTtBVvnTfIeP97KVC3ZjE,54011
+django_ledger/models/invoice.py,sha256=IDfKqOl1DE2g4whfdzJetX76qK-ghaNglYzIa1s1TIo,54407
+django_ledger/models/items.py,sha256=ZiofHQ3r0eXGh4eySHl8OWJStghd2eNsf6VzTY-2z7o,53358
 django_ledger/models/journal_entry.py,sha256=N_UyiU4n4EvAepl5YpWElzS6mq0O5eL0zwaHs2_M9ig,44797
 django_ledger/models/ledger.py,sha256=jD_-lR3mSVoAbGTdMy-k8Y8y8mVuiEjJ-3IVsHXMGoU,10730
-django_ledger/models/mixins.py,sha256=Ywyt-3ABB_yWSyTs25EoD3ymqzhqpf1fNWJ0LbshZPI,46220
-django_ledger/models/purchase_order.py,sha256=hFWfTYc4K9ctTEA0grPb8-xppczplMvyHppk5buioYY,40708
+django_ledger/models/mixins.py,sha256=o3ycKmknYZscnxlP0OGIU-1D_ShOaoJZKrt1DesA2Lw,46279
+django_ledger/models/purchase_order.py,sha256=WYk8tclWCnAtPSAjU8ko4ZQRkRMj37o-Lyovl2atKk4,41344
 django_ledger/models/transactions.py,sha256=okeWDGUxLc1se7q9-8y0-P8WfFiv3W0WJKUhvnJsgRY,19622
 django_ledger/models/unit.py,sha256=7mByF-DxrqyjcOIt4SeGtzqXkkDcabHddLCwPigcHMg,7962
 django_ledger/models/utils.py,sha256=91aD8wll6p0GlgeXAsvy__yXe1u2iVn0L8OeUX0D-i4,5193
 django_ledger/models/vendor.py,sha256=HiQXfj6qh_xUOdQLQQbqGCAJXXMonp5wNzI9tTgNfIs,11361
 django_ledger/models/schemas/__init__.py,sha256=8Tvw33tVJtCvxoXje2lrs9C1bsP_iuGcVi1JqzdPUao,157
 django_ledger/models/schemas/digest.py,sha256=ME_dJ4g2p3dQ97Skh_RTZMwuNLmwTi19BdLM1G6tyAo,1077
 django_ledger/models/schemas/net_payable.py,sha256=2FcfLaaJySjZ3Yk_IMu8SxYWNO_sngEtbuFCXInrQUU,958
@@ -267,16 +267,16 @@
 django_ledger/templates/django_ledger/vendor/vendor_update.html,sha256=4kBUlGgrgRFhdwhjQAxJrp0ATsTWQ4kcKLlUqpkjLKo,1341
 django_ledger/templates/django_ledger/vendor/includes/card_vendor.html,sha256=oCXyuqyF7CnJnDQdK0G0jdYLqtPWYSzwlv8oddyGJg8,1290
 django_ledger/templates/django_ledger/vendor/tags/vendor_table.html,sha256=YC-3T5x4oua3VBg1q690CRzoogKL8qFgQRp5jTKLFgk,3400
 django_ledger/templatetags/__init__.py,sha256=N7iaeMO5xTU-q7RXTVYUy-fu8nMZbiIJ9QEtDCjsTdI,205
 django_ledger/templatetags/django_ledger.py,sha256=ISVNwZRbFd1gINSF7GP_0RCOtqxYujW1eIqjXvW5RJM,30805
 django_ledger/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 django_ledger/tests/base.py,sha256=GqzJkWEiTAv7K1RghjOMRJHSiWMOXQl_R-8WQ52cmhE,4585
-django_ledger/tests/test_auth.py,sha256=upDP9d8OpL2PsdPrbiYORuKo0A2HDLqJ8an_iMq3aKY,3059
-django_ledger/tests/test_bill.py,sha256=zl9IErfHOpR30GTGH8GCqRMP5RSk9UsDmsqMXHOb0oY,18178
+django_ledger/tests/test_auth.py,sha256=6vLkH-ooRFJleorYU5-kVjbqcaD3eZ9c1EU-Kb4tPmU,3059
+django_ledger/tests/test_bill.py,sha256=3BUpSkBZu6F1r5Hu6MziMfSyv12y-02-1MH1ZFunhPM,18194
 django_ledger/tests/test_entity.py,sha256=Y8kKFodNGUcUoUypnnUSBWvDSS_BtfSZgQ2vMqj-3Ic,12180
 django_ledger/tests/test_purchase_order.py,sha256=xjEkZkIbZyM78d3x7rRy8lX3b6cK9inQTLLXvC8Eu44,8595
 django_ledger/tests/bdd/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 django_ledger/tests/bdd/features/steps/README.py,sha256=4HMdVjjflcKQBf0LeZbc5i3TXbe5qGxYBcGmHn4i3jU,599
 django_ledger/urls/__init__.py,sha256=RfQo_QgeLBcQPpgGayNxt24UOAuwDjZzV2Tu8BYlo40,1905
 django_ledger/urls/account.py,sha256=sYGXLYE9Umfb5D02-Gj4j7eQEZgHz21IQcxwrQNChYw,1310
 django_ledger/urls/auth.py,sha256=8dY2h6PQkMayUL81guu9JCxm--Tj0rglvvxg9Qh03aY,230
@@ -305,27 +305,27 @@
 django_ledger/views/auth.py,sha256=-zTjMlLpyxHGPlY9EXFQyeVHMmyeJ2H9RptcW7PDeDg,771
 django_ledger/views/bank_account.py,sha256=fO0_KZXF5CWtnXfXfJ98hMmJn5ZYaJF95k6A0SWRy6c,5172
 django_ledger/views/bill.py,sha256=doUNbLQlV5tsnU2b5k29NXcbcsKkyo-UsnFD92h-rBc,23049
 django_ledger/views/coa.py,sha256=KlcmgsmqrahM3YRxmV96P_60tsAJa_ZUg0dsyvyRVZw,1704
 django_ledger/views/customer.py,sha256=BDJTt6EVKzXAy2qVTCfpkJ3VntrPPDvcpIeU6rvvsAs,3668
 django_ledger/views/data_import.py,sha256=1wfQyXFZtUlvng3HDFm3M4mneHk9ua98MydWiQvnpXk,10554
 django_ledger/views/djl_api.py,sha256=GOl1KBOvrdtScPJatYbfVg3m4bU3-CR8i4EFPrXTOrw,4322
-django_ledger/views/entity.py,sha256=1m7-7s09UuPeXjuZp9pT24Fu40wJ8Mx3H75p7vD8fbA,16074
+django_ledger/views/entity.py,sha256=GJEHXVfxDszcMlNbSc2YoM3xxcXd5dR8rcoXPXuqM58,16066
 django_ledger/views/estimate.py,sha256=8Sna9yNXXwqjjrljce5z5Lmp4RD3f7TtSFP9SE5-g7k,12833
 django_ledger/views/feedback.py,sha256=qoIN44fJnblPx-pJFe5yYeO-dMqp-FReFZiyw0qQb_s,2460
 django_ledger/views/home.py,sha256=WGSMUY-Pz7I7hNxLWYz4AdiH7fJ3QE_Sl4oTLbDesRA,1365
-django_ledger/views/inventory.py,sha256=WAtaPwqjgYsUqrCofg978j-Ue-eHuBrXFzAE5rsrjIQ,5020
+django_ledger/views/inventory.py,sha256=OratyOJFfNjG-LZzDtJImjbLiZ1rXBuHC9hP6TuX5oI,4812
 django_ledger/views/invoice.py,sha256=JBe8t8T556ZOpg7Bt8XPbSwlajV316Gf8c0vB4FTL-I,20253
-django_ledger/views/item.py,sha256=0Z4fUtdR8AXy_7zEGVSn-hkP6O9iudl-bNkc3rr5YF8,21278
+django_ledger/views/item.py,sha256=jMlUy38arDAeNLKnJgEHkZq85Ex5O2lpc68vLlbD6Ak,21343
 django_ledger/views/journal_entry.py,sha256=3Y6KUseWXz-tkualr-ykjQqzoC3SK0toYEV6QRWRO88,10774
 django_ledger/views/ledger.py,sha256=7RUSRBvriu13CKkTeYXEbFhjWOcbwUMAJ5crn8eCO0o,8628
 django_ledger/views/mixins.py,sha256=oURUl42V6QAdrc9y4PBMkEf3ZOUsu3VQztZaRgGVYWQ,17325
 django_ledger/views/purchase_order.py,sha256=c04jB2FOeFJpricFTOjWcIYfTtAQSZBDZfVo6Z3JbEQ,21078
 django_ledger/views/transactions.py,sha256=5taQRGLSMkM_N8paQJ07HMspI_Nl7PawF8OohCiRmao,206
 django_ledger/views/unit.py,sha256=f0Iqc9VihZm8j5KQ2zK7o8vQXInm8QJtawtj72hZzEY,9501
 django_ledger/views/vendor.py,sha256=g0LUy_dugfh2IAwuDk0GeoApn8_XxLlwuU2_9JaEOBo,3457
-django_ledger-0.5.3.0.dist-info/AUTHORS.md,sha256=SRM2cynD89ZfEsL09zrbUVeO17r9zE2ZM7y6ReMqVRo,713
-django_ledger-0.5.3.0.dist-info/LICENSE,sha256=ixuiBLtpoK3iv89l7ylKkg9rs2GzF9ukPH7ynZYzK5s,35148
-django_ledger-0.5.3.0.dist-info/METADATA,sha256=yUP4Beq1TeEX1l8NOmzsBF9X62Va_Wgs-TP516JuTdE,11091
-django_ledger-0.5.3.0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-django_ledger-0.5.3.0.dist-info/top_level.txt,sha256=9_eK5iVhqVOoKaI0VI6m7CcggrTw1523Dn6O1sQ3Arw,26
-django_ledger-0.5.3.0.dist-info/RECORD,,
+django_ledger-0.5.3.1.dist-info/AUTHORS.md,sha256=SRM2cynD89ZfEsL09zrbUVeO17r9zE2ZM7y6ReMqVRo,713
+django_ledger-0.5.3.1.dist-info/LICENSE,sha256=ixuiBLtpoK3iv89l7ylKkg9rs2GzF9ukPH7ynZYzK5s,35148
+django_ledger-0.5.3.1.dist-info/METADATA,sha256=7tlwv-yK5MLYY4v0jD0PJe01GvE4ZkOhHguDpFcOPEE,11045
+django_ledger-0.5.3.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+django_ledger-0.5.3.1.dist-info/top_level.txt,sha256=9_eK5iVhqVOoKaI0VI6m7CcggrTw1523Dn6O1sQ3Arw,26
+django_ledger-0.5.3.1.dist-info/RECORD,,
```

