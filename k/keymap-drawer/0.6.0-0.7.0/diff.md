# Comparing `tmp/keymap_drawer-0.6.0-py3-none-any.whl.zip` & `tmp/keymap_drawer-0.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,31 @@
-Zip file size: 41100 bytes, number of entries: 29
+Zip file size: 46464 bytes, number of entries: 29
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 keymap_drawer/__init__.py
--rw-r--r--  2.0 unx     6809 b- defN 80-Jan-01 00:00 keymap_drawer/__main__.py
--rw-r--r--  2.0 unx     7634 b- defN 80-Jan-01 00:00 keymap_drawer/config.py
--rw-r--r--  2.0 unx    11271 b- defN 80-Jan-01 00:00 keymap_drawer/draw.py
--rw-r--r--  2.0 unx     8818 b- defN 80-Jan-01 00:00 keymap_drawer/keymap.py
--rw-r--r--  2.0 unx    16827 b- defN 80-Jan-01 00:00 keymap_drawer/parse.py
--rw-r--r--  2.0 unx    11843 b- defN 80-Jan-01 00:00 keymap_drawer/physical_layout.py
+-rw-r--r--  2.0 unx     6730 b- defN 80-Jan-01 00:00 keymap_drawer/__main__.py
+-rw-r--r--  2.0 unx     9260 b- defN 80-Jan-01 00:00 keymap_drawer/config.py
+-rw-r--r--  2.0 unx    13163 b- defN 80-Jan-01 00:00 keymap_drawer/draw.py
+-rw-r--r--  2.0 unx     5798 b- defN 80-Jan-01 00:00 keymap_drawer/glyph.py
+-rw-r--r--  2.0 unx     9388 b- defN 80-Jan-01 00:00 keymap_drawer/keymap.py
+-rw-r--r--  2.0 unx    16713 b- defN 80-Jan-01 00:00 keymap_drawer/parse.py
+-rw-r--r--  2.0 unx    12301 b- defN 80-Jan-01 00:00 keymap_drawer/physical_layout.py
+-rw-r--r--  2.0 unx     4183 b- defN 80-Jan-01 00:00 resources/qmk_layouts/adv360.json
 -rw-r--r--  2.0 unx     2114 b- defN 80-Jan-01 00:00 resources/qmk_layouts/berylline.json
 -rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 resources/qmk_layouts/chocofi.json
 -rw-r--r--  2.0 unx     2437 b- defN 80-Jan-01 00:00 resources/qmk_layouts/clog.json
 -rw-r--r--  2.0 unx     3502 b- defN 80-Jan-01 00:00 resources/qmk_layouts/corne_rotated.json
--rw-r--r--  2.0 unx      779 b- defN 80-Jan-01 00:00 resources/qmk_layouts/ergodox_thumb.json
 -rw-r--r--  2.0 unx     3684 b- defN 80-Jan-01 00:00 resources/qmk_layouts/fingerpunch@ffkb.json
 -rw-r--r--  2.0 unx     2153 b- defN 80-Jan-01 00:00 resources/qmk_layouts/fingerpunch@luakeeb.json
--rw-r--r--  2.0 unx     1817 b- defN 80-Jan-01 00:00 resources/qmk_layouts/fingerpunch@sweep36.json
+-rw-r--r--  2.0 unx     3353 b- defN 80-Jan-01 00:00 resources/qmk_layouts/glove80.json
 -rw-r--r--  2.0 unx     9984 b- defN 80-Jan-01 00:00 resources/qmk_layouts/klor.json
 -rw-r--r--  2.0 unx     2537 b- defN 80-Jan-01 00:00 resources/qmk_layouts/klotz.json
--rw-r--r--  2.0 unx     1293 b- defN 80-Jan-01 00:00 resources/qmk_layouts/miryoku.json
 -rw-r--r--  2.0 unx     1783 b- defN 80-Jan-01 00:00 resources/qmk_layouts/osprey.json
 -rw-r--r--  2.0 unx     2466 b- defN 80-Jan-01 00:00 resources/qmk_layouts/paroxysm.json
 -rw-r--r--  2.0 unx     3728 b- defN 80-Jan-01 00:00 resources/qmk_layouts/revxlp.json
 -rw-r--r--  2.0 unx     2838 b- defN 80-Jan-01 00:00 resources/qmk_layouts/rufous.json
 -rw-r--r--  2.0 unx     2803 b- defN 80-Jan-01 00:00 resources/qmk_layouts/totem.json
--rw-r--r--  2.0 unx     6267 b- defN 80-Jan-01 00:00 resources/zmk_keyboard_layouts.yaml
--rw-r--r--  2.0 unx    21555 b- defN 80-Jan-01 00:00 keymap_drawer-0.6.0.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 keymap_drawer-0.6.0.dist-info/WHEEL
--rw-r--r--  2.0 unx     1069 b- defN 80-Jan-01 00:00 keymap_drawer-0.6.0.dist-info/LICENSE
--rw-r--r--  2.0 unx       54 b- defN 80-Jan-01 00:00 keymap_drawer-0.6.0.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     2572 b- defN 16-Jan-01 00:00 keymap_drawer-0.6.0.dist-info/RECORD
-29 files, 140992 bytes uncompressed, 36920 bytes compressed:  73.8%
+-rw-r--r--  2.0 unx     6244 b- defN 80-Jan-01 00:00 resources/zmk_keyboard_layouts.yaml
+-rw-r--r--  2.0 unx    26355 b- defN 80-Jan-01 00:00 keymap_drawer-0.7.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 keymap_drawer-0.7.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx     1069 b- defN 80-Jan-01 00:00 keymap_drawer-0.7.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx       54 b- defN 80-Jan-01 00:00 keymap_drawer-0.7.0.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     2542 b- defN 16-Jan-01 00:00 keymap_drawer-0.7.0.dist-info/RECORD
+29 files, 159537 bytes uncompressed, 42346 bytes compressed:  73.5%
```

## zipnote {}

```diff
@@ -6,56 +6,56 @@
 
 Filename: keymap_drawer/config.py
 Comment: 
 
 Filename: keymap_drawer/draw.py
 Comment: 
 
+Filename: keymap_drawer/glyph.py
+Comment: 
+
 Filename: keymap_drawer/keymap.py
 Comment: 
 
 Filename: keymap_drawer/parse.py
 Comment: 
 
 Filename: keymap_drawer/physical_layout.py
 Comment: 
 
+Filename: resources/qmk_layouts/adv360.json
+Comment: 
+
 Filename: resources/qmk_layouts/berylline.json
 Comment: 
 
 Filename: resources/qmk_layouts/chocofi.json
 Comment: 
 
 Filename: resources/qmk_layouts/clog.json
 Comment: 
 
 Filename: resources/qmk_layouts/corne_rotated.json
 Comment: 
 
-Filename: resources/qmk_layouts/ergodox_thumb.json
-Comment: 
-
 Filename: resources/qmk_layouts/fingerpunch@ffkb.json
 Comment: 
 
 Filename: resources/qmk_layouts/fingerpunch@luakeeb.json
 Comment: 
 
-Filename: resources/qmk_layouts/fingerpunch@sweep36.json
+Filename: resources/qmk_layouts/glove80.json
 Comment: 
 
 Filename: resources/qmk_layouts/klor.json
 Comment: 
 
 Filename: resources/qmk_layouts/klotz.json
 Comment: 
 
-Filename: resources/qmk_layouts/miryoku.json
-Comment: 
-
 Filename: resources/qmk_layouts/osprey.json
 Comment: 
 
 Filename: resources/qmk_layouts/paroxysm.json
 Comment: 
 
 Filename: resources/qmk_layouts/revxlp.json
@@ -66,23 +66,23 @@
 
 Filename: resources/qmk_layouts/totem.json
 Comment: 
 
 Filename: resources/zmk_keyboard_layouts.yaml
 Comment: 
 
-Filename: keymap_drawer-0.6.0.dist-info/METADATA
+Filename: keymap_drawer-0.7.0.dist-info/METADATA
 Comment: 
 
-Filename: keymap_drawer-0.6.0.dist-info/WHEEL
+Filename: keymap_drawer-0.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: keymap_drawer-0.6.0.dist-info/LICENSE
+Filename: keymap_drawer-0.7.0.dist-info/LICENSE
 Comment: 
 
-Filename: keymap_drawer-0.6.0.dist-info/entry_points.txt
+Filename: keymap_drawer-0.7.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: keymap_drawer-0.6.0.dist-info/RECORD
+Filename: keymap_drawer-0.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## keymap_drawer/__main__.py

```diff
@@ -1,30 +1,29 @@
 """
 Given keymap description with layers and combos (in a yaml), and physical
 keyboard layout definition (either via QMK info files or using a parametrized
 ortho layout), print an SVG representing the keymap to standard output.
 """
 import sys
-import argparse
-from importlib.metadata import version
+from argparse import ArgumentParser, FileType, Namespace
 from pathlib import Path
+from importlib.metadata import version
 
 import yaml
 
 from .config import Config, DrawConfig, ParseConfig
 from .keymap import KeymapData
 from .draw import KeymapDrawer
 from .parse import QmkJsonParser, ZmkKeymapParser
 
 
-def draw(args, config: DrawConfig) -> None:
+def draw(args: Namespace, config: DrawConfig) -> None:
     """Draw the keymap in SVG format to stdout."""
-    with sys.stdin.buffer if args.keymap_yaml == "-" else open(args.keymap_yaml, "rb") as f:
-        yaml_data = yaml.safe_load(f)
-        assert "layers" in yaml_data, 'Keymap needs to be specified via the "layers" field in keymap_yaml'
+    yaml_data = yaml.safe_load(args.keymap_yaml)
+    assert "layers" in yaml_data, 'Keymap needs to be specified via the "layers" field in keymap_yaml'
 
     if args.qmk_keyboard or args.qmk_info_json or args.ortho_layout:
         layout = {
             "qmk_keyboard": args.qmk_keyboard,
             "qmk_info_json": args.qmk_info_json,
             "qmk_layout": args.qmk_layout,
             "ortho_layout": args.ortho_layout,
@@ -41,19 +40,18 @@
 
     drawer = KeymapDrawer(
         config=config, out=sys.stdout, layers=yaml_data["layers"], layout=layout, combos=yaml_data.get("combos", [])
     )
     drawer.print_board(draw_layers=args.select_layers, keys_only=args.keys_only, combos_only=args.combos_only)
 
 
-def parse(args, config: ParseConfig) -> None:
+def parse(args: Namespace, config: ParseConfig) -> None:
     """Call the appropriate parser for given args and dump YAML keymap representation to stdout."""
     if args.base_keymap:
-        with open(args.base_keymap, "rb") as f:
-            yaml_data = yaml.safe_load(f)
+        yaml_data = yaml.safe_load(args.base_keymap)
         base = KeymapData(layers=yaml_data["layers"], combos=yaml_data.get("combos", []), layout=None, config=None)
     else:
         base = None
 
     if args.qmk_keymap_json:
         parsed = QmkJsonParser(config, args.columns, base_keymap=base, layer_names=args.layer_names).parse(
             args.qmk_keymap_json
@@ -76,21 +74,22 @@
 
     yaml.representer.SafeRepresenter.add_representer(str, cfg_str_representer)
     yaml.safe_dump(config.dict(), sys.stdout, indent=2, default_flow_style=False)
 
 
 def main() -> None:
     """Parse the configuration and print SVG using KeymapDrawer."""
-    parser = argparse.ArgumentParser(description=__doc__)
+    parser = ArgumentParser(description=__doc__)
     parser.add_argument("-v", "--version", action="version", version=version("keymap-drawer"))
     parser.add_argument(
         "-c",
         "--config",
         help="A YAML file containing settings for parsing and drawing, "
         "default can be dumped using `dump-config` command and to be modified",
+        type=FileType("rt"),
     )
     subparsers = parser.add_subparsers(dest="command", required=True)
 
     draw_p = subparsers.add_parser("draw", help="draw an SVG representation of the keymap")
     info_srcs = draw_p.add_mutually_exclusive_group()
     info_srcs.add_argument(
         "-j",
@@ -120,23 +119,26 @@
     draw_p.add_argument("-s", "--select-layers", help="A list of layer names to draw, draw all by default", nargs="+")
     draw_p.add_argument("--keys-only", help="Only draw keys, not combos on layers", action="store_true")
     draw_p.add_argument("--combos-only", help="Only draw combos, not keys on layers", action="store_true")
     draw_p.add_argument(
         "keymap_yaml",
         help='YAML file (or stdin for "-") containing keymap definition with layers and (optionally) combos, '
         "see README for schema",
+        type=FileType("rt"),
     )
 
     parse_p = subparsers.add_parser(
         "parse", help="parse a QMK/ZMK keymap to YAML representation to stdout, to be used with the `draw` command"
     )
     keymap_srcs = parse_p.add_mutually_exclusive_group(required=True)
-    keymap_srcs.add_argument("-q", "--qmk-keymap-json", help="Path to QMK keymap.json to parse", type=Path)
-    keymap_srcs.add_argument("-z", "--zmk-keymap", help="Path to ZMK *.keymap to parse", type=Path)
-    parse_p.add_argument("-b", "--base-keymap", help="A base keymap YAML to inherit certain properties from", type=Path)
+    keymap_srcs.add_argument("-q", "--qmk-keymap-json", help="Path to QMK keymap.json to parse", type=FileType("rt"))
+    keymap_srcs.add_argument("-z", "--zmk-keymap", help="Path to ZMK *.keymap to parse", type=FileType("rt"))
+    parse_p.add_argument(
+        "-b", "--base-keymap", help="A base keymap YAML to inherit certain properties from", type=FileType("rt")
+    )
     parse_p.add_argument(
         "-l",
         "--layer-names",
         help="List of layer names to override parsed names; its length should match the number of layers",
         nargs="+",
     )
     parse_p.add_argument(
@@ -148,19 +150,15 @@
 
     _ = subparsers.add_parser(
         "dump-config", help="dump default draw and parse config to stdout that can be passed to -c/--config option"
     )
 
     args = parser.parse_args()
 
-    if args.config:
-        with sys.stdin.buffer if args.config == "-" else open(args.config, "rb") as f:
-            config = Config.parse_obj(yaml.safe_load(f))
-    else:
-        config = Config()
+    config = Config.parse_obj(yaml.safe_load(args.config)) if args.config else Config()
 
     match args.command:
         case "draw":
             draw(args, config.draw_config)
         case "parse":
             parse(args, config.parse_config)
         case "dump-config":
```

## keymap_drawer/config.py

```diff
@@ -46,25 +46,29 @@
     append_colon_to_layer_header: bool = True
 
     # padding from edge of cap to top and bottom legends
     small_pad: float = 2.0
 
     svg_style: str = dedent(
         """\
+        /* inherit to force styles through use tags*/
+        svg path {
+            fill: inherit;
+        }
         /* font and background color specifications */
-        svg {
+        svg.keymap {
             font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;
             font-size: 14px;
             font-kerning: normal;
             text-rendering: optimizeLegibility;
             fill: #24292e;
         }
 
         /* default key styling */
-        rect {
+        rect.key {
             fill: #f6f8fa;
             stroke: #c9cccf;
             stroke-width: 1;
         }
 
         /* color accent for combo boxes */
         rect.combo {
@@ -111,23 +115,60 @@
         }
 
         /* styling for hold/shifted label text in combo box */
         text.combo.hold, text.combo.shifted {
             font-size: 8px;
         }
 
+        /* lighter symbol for transparent keys */
+        text.trans {
+            fill: #7b7e81;
+        }
+
         /* styling for combo dendrons */
-        path {
+        path.combo {
             stroke-width: 1;
             stroke: gray;
             fill: none;
         }
+
+        /* Start Tabler Icons Cleanup */
+        /* cannot use height/width with glyphs */
+        .icon-tabler > path {
+            fill: inherit;
+            stroke: inherit;
+        }
+        /* hide tabler's default box */
+        .icon-tabler > path[stroke="none"][fill="none"] {
+            visibility: collapse;
+        }
+        /* End Tabler Icons Cleanup */
         """
     )
 
+    # height in pixels for glyphs in different key fields
+    glyph_tap_size: int = 14
+    glyph_hold_size: int = 12
+    glyph_shifted_size: int = 10
+
+    # mapping of glyph names to be used in key fields to their SVG definitions
+    glyphs: dict[str, str] = {}
+
+    # mapping of sources to (possibly templated) URLs for fetching SVG glyphs
+    # e.g. `$$material:settings$$` will use the value for `material` and replace `{}` with `settings`
+    glyph_urls: dict[str, str] = {
+        "tabler": "https://tabler-icons.io/static/tabler-icons/icons/{}.svg",
+        "mdi": "https://raw.githubusercontent.com/Templarian/MaterialDesign-SVG/master/svg/{}.svg",
+        "mdil": "https://raw.githubusercontent.com/Pictogrammers/MaterialDesignLight/master/svg/{}.svg",
+        "material": "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/{}/default/48px.svg",
+    }
+
+    # use a local filesystem cache on an OS-specific location for downloaded QMK keyboard jsons and SVG glyphs
+    use_local_cache: bool = True
+
 
 class ParseConfig(BaseSettings, env_prefix="KEYMAP_", extra="ignore"):
     """Configuration settings related to parsing QMK/ZMK keymaps."""
 
     # run C preprocessor on ZMK keymaps
     preprocess: bool = True
 
@@ -137,21 +178,20 @@
     # map raw keycode/binding strings as specified and shortcut any further key parsing
     # e.g. {"QK_BOOT": "BOOT", "&bootloader": "BOOT"}
     raw_binding_map: dict[str, str | dict] = {}
 
     # display text to place in hold field for sticky/one-shot keys
     sticky_label: str = "sticky"
 
+    trans_legend: str | dict = {"t": "â–½", "type": "trans"}
+
     # convert QMK keycodes to their display forms, omitting "KC_" prefix on the keys
     qmk_keycode_map: dict[str, str | dict] = {
         # QMK keycodes
         "XXXXXXX": "",
-        "TRANSPARENT": "",
-        "TRNS": "",
-        "_______": "",
         "NO": "",
         "MINUS": "-",
         "MINS": "-",
         "EQUAL": "=",
         "EQL": "=",
         "LEFT_BRACKET": "[",
         "LBRC": "[",
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## keymap_drawer/draw.py

```diff
@@ -1,81 +1,101 @@
 """
 Module that contains the KeymapDrawer class which takes a physical layout,
 keymap with layers and optionally combo definitions, then can draw an SVG
 representation of the keymap using these two.
 """
 from math import copysign
 from html import escape
-from typing import Sequence, TextIO
+from typing import Sequence, TextIO, Literal
 
 from .keymap import KeymapData, ComboSpec, LayoutKey
 from .physical_layout import Point, PhysicalKey
 from .config import DrawConfig
+from .glyph import GlyphHandler
+
+
+LegendType = Literal["tap", "hold", "shifted"]
 
 
 class KeymapDrawer:
     """Class that draws a keyboard representation in SVG."""
 
     def __init__(self, config: DrawConfig, out: TextIO, **kwargs) -> None:
         self.cfg = config
         self.keymap = KeymapData(config=config, **kwargs)
         assert self.keymap.layout is not None, "A PhysicalLayout must be provided for drawing"
         assert self.keymap.config is not None, "A DrawConfig must be provided for drawing"
         self.layout = self.keymap.layout
+        self.glyph_handler = GlyphHandler(self.cfg, self.keymap)
         self.out = out
 
     @staticmethod
+    def _to_class_str(classes: Sequence[str]):
+        return (' class="' + " ".join(c for c in classes if c) + '"') if classes else ""
+
+    @staticmethod
     def _split_text(text: str) -> list[str]:
         # do not split on double spaces, but do split on single
         return [word.replace("\x00", " ") for word in text.replace("  ", "\x00").split()]
 
-    def _draw_rect(self, p: Point, w: float, h: float, cls: Sequence[str]) -> None:
-        class_str = (' class="' + " ".join(c for c in cls if c) + '"') if cls else ""
+    def _draw_rect(self, p: Point, w: float, h: float, classes: Sequence[str]) -> None:
         self.out.write(
             f'<rect rx="{self.cfg.key_rx}" ry="{self.cfg.key_ry}" x="{p.x - w / 2}" y="{p.y - h / 2}" '
-            f'width="{w}" height="{h}"{class_str}/>\n'
+            f'width="{w}" height="{h}"{self._to_class_str(classes)}/>\n'
         )
 
-    def _draw_text(self, p: Point, words: Sequence[str], cls: Sequence[str], shift: float = 0) -> None:
-        if not words or not words[0]:
+    def _draw_text(self, p: Point, word: str, classes: Sequence[str]) -> None:
+        if not word:
             return
+        self.out.write(f'<text x="{p.x}" y="{p.y}"{self._to_class_str(classes)}>{escape(word)}</text>\n')
 
-        class_str = (' class="' + " ".join(c for c in cls if c) + '"') if cls else ""
-        if len(words) == 1:
-            self.out.write(f'<text x="{p.x}" y="{p.y}"{class_str}>{escape(words[0])}</text>\n')
-            return
-        self.out.write(f'<text x="{p.x}" y="{p.y}"{class_str}>\n')
+    def _draw_textblock(self, p: Point, words: Sequence[str], classes: Sequence[str], shift: float = 0) -> None:
+        self.out.write(f'<text x="{p.x}" y="{p.y}"{self._to_class_str(classes)}>\n')
         dy_0 = (len(words) - 1) * (self.cfg.line_spacing * (1 + shift) / 2)
         self.out.write(f'<tspan x="{p.x}" dy="-{dy_0}em">{escape(words[0])}</tspan>')
         for word in words[1:]:
             self.out.write(f'<tspan x="{p.x}" dy="{self.cfg.line_spacing}em">{escape(word)}</tspan>')
         self.out.write("</text>\n")
 
+    def _draw_glyph(self, p: Point, name: str, legend_type: LegendType, classes: Sequence[str]) -> None:
+        width, height, d_y = self.glyph_handler.get_glyph_dimensions(name, legend_type)
+
+        classes = [*classes, "glyph", name]
+        self.out.write(
+            f'<use href="#{name}" x="{p.x - (width / 2)}" y="{p.y - d_y}" '
+            f'height="{height}" width="{width}"{self._to_class_str(classes)}/>\n'
+        )
+
     def _draw_arc_dendron(self, p_1: Point, p_2: Point, x_first: bool, shorten: float) -> None:
+        diff = p_2 - p_1
+        if (x_first and abs(diff.x) < self.cfg.arc_radius) or (not x_first and abs(diff.y) < self.cfg.arc_radius):
+            self._draw_line_dendron(p_1, p_2, shorten)
+            return
+
         start = f"M{p_1.x},{p_1.y}"
-        arc_x = copysign(self.cfg.arc_radius, p_2.x - p_1.x)
-        arc_y = copysign(self.cfg.arc_radius, p_2.y - p_1.y)
-        clockwise = (p_2.x > p_1.x) ^ (p_2.y > p_1.y)
+        arc_x = copysign(self.cfg.arc_radius, diff.x)
+        arc_y = copysign(self.cfg.arc_radius, diff.y)
+        clockwise = (diff.x > 0) ^ (diff.y > 0)
         if x_first:
-            line_1 = f"h{self.cfg.arc_scale * (p_2.x - p_1.x) - arc_x}"
-            line_2 = f"v{p_2.y - p_1.y - arc_y - copysign(shorten, p_2.y - p_1.y)}"
+            line_1 = f"h{self.cfg.arc_scale * diff.x - arc_x}"
+            line_2 = f"v{diff.y - arc_y - copysign(shorten, diff.y)}"
             clockwise = not clockwise
         else:
-            line_1 = f"v{self.cfg.arc_scale * (p_2.y - p_1.y) - arc_y}"
-            line_2 = f"h{p_2.x - p_1.x - arc_x - copysign(shorten, p_2.x - p_1.x)}"
+            line_1 = f"v{self.cfg.arc_scale * diff.y - arc_y}"
+            line_2 = f"h{diff.x - arc_x - copysign(shorten, diff.x)}"
         arc = f"a{self.cfg.arc_radius},{self.cfg.arc_radius} 0 0 {int(clockwise)} {arc_x},{arc_y}"
-        self.out.write(f'<path d="{start} {line_1} {arc} {line_2}"/>\n')
+        self.out.write(f'<path d="{start} {line_1} {arc} {line_2}" class="combo"/>\n')
 
     def _draw_line_dendron(self, p_1: Point, p_2: Point, shorten: float) -> None:
         start = f"M{p_1.x},{p_1.y}"
         diff = p_2 - p_1
         if shorten and shorten < (magn := abs(diff)):
-            diff = Point((1 - shorten / magn) * diff.x, (1 - shorten / magn) * diff.y)
+            diff = (1 - shorten / magn) * diff
         line = f"l{diff.x},{diff.y}"
-        self.out.write(f'<path d="{start} {line}"/>\n')
+        self.out.write(f'<path d="{start} {line}" class="combo"/>\n')
 
     def print_key(self, p_0: Point, p_key: PhysicalKey, l_key: LayoutKey) -> None:
         """
         Given anchor coordinates p_0, print SVG code for a rectangle with text representing
         the key, which is described by its physical representation (p_key) and what it does in
         the given layer (l_key).
         """
@@ -83,51 +103,78 @@
             p_0 + p_key.pos,
             p_key.width,
             p_key.height,
             p_key.rotation,
         )
         if r != 0:
             self.out.write(f'<g transform="rotate({r}, {p.x}, {p.y})">\n')
-        self._draw_rect(p, w - 2 * self.cfg.inner_pad_w, h - 2 * self.cfg.inner_pad_h, cls=[l_key.type])
+        self._draw_rect(p, w - 2 * self.cfg.inner_pad_w, h - 2 * self.cfg.inner_pad_h, classes=[l_key.type, "key"])
 
         tap_words = self._split_text(l_key.tap)
 
         # auto-adjust vertical alignment up/down if there are two lines and either hold/shifted is present
-        tap_p = Point(p.x, p.y)
         shift = 0
         if len(tap_words) == 2:
             if l_key.shifted and not l_key.hold:  # shift down
                 shift = -1
             elif l_key.hold and not l_key.shifted:  # shift up
                 shift = 1
-        self._draw_text(tap_p, tap_words, cls=[l_key.type, "tap"], shift=shift)
 
-        self._draw_text(
-            p + Point(0, h / 2 - self.cfg.inner_pad_h - self.cfg.small_pad), [l_key.hold], cls=[l_key.type, "hold"]
+        self._draw_legend(p, tap_words, key_type=l_key.type, legend_type="tap", shift=shift)
+        self._draw_legend(
+            p + Point(0, h / 2 - self.cfg.inner_pad_h - self.cfg.small_pad),
+            [l_key.hold],
+            key_type=l_key.type,
+            legend_type="hold",
         )
-        self._draw_text(
+        self._draw_legend(
             p - Point(0, h / 2 - self.cfg.inner_pad_h - self.cfg.small_pad),
             [l_key.shifted],
-            cls=[l_key.type, "shifted"],
+            key_type=l_key.type,
+            legend_type="shifted",
         )
+
         if r != 0:
             self.out.write("</g>\n")
 
+    def _draw_legend(  # pylint: disable=too-many-arguments
+        self, p: Point, words: Sequence[str], key_type: str, legend_type: LegendType, shift: float = 0
+    ):
+        if not words:
+            return
+
+        classes = [key_type, legend_type]
+
+        if len(words) == 1:
+            if glyph := self.glyph_handler.legend_is_glyph(words[0]):
+                self._draw_glyph(p, glyph, legend_type, classes)
+                return
+
+            self._draw_text(p, words[0], classes)
+            return
+
+        self._draw_textblock(p, words, classes, shift)
+
     def print_combo(self, p_0: Point, combo: ComboSpec) -> None:
         """
         Given anchor coordinates p_0, print SVG code for a rectangle with text representing
         a combo specification, which contains the key positions that trigger it and what it does
         when triggered. The position of the rectangle depends on the alignment specified,
         along with whether dendrons are drawn going to each key position from the combo.
         """
         p_keys = [self.layout.keys[p] for p in combo.key_positions]
 
         # find center of combo box
         p = p_0.copy()
         p_mid = (1 / len(p_keys)) * sum((k.pos for k in p_keys), start=Point(0, 0))
+        if combo.slide is not None:  # find two keys furthest from the midpoint, interpolate between their positions
+            sorted_keys = sorted(p_keys, key=lambda k: (-abs(k.pos - p_mid), k.pos.x, k.pos.y))
+            start, end = sorted_keys[0:2]
+            p_mid = (1 - combo.slide) / 2 * start.pos + (1 + combo.slide) / 2 * end.pos
+
         match combo.align:
             case "mid":
                 p += p_mid
             case "top":
                 p += Point(
                     p_mid.x,
                     min(k.pos.y - k.height / 2 for k in p_keys)
@@ -169,23 +216,28 @@
                         self._draw_arc_dendron(p, p_0 + k.pos, False, offset)
                 case "mid":
                     for k in p_keys:
                         if combo.dendron is True or abs(p_0 + k.pos - p) >= k.width - 1:
                             self._draw_line_dendron(p, p_0 + k.pos, k.width / 3)
 
         # draw combo box with text
-        self._draw_rect(p, self.cfg.combo_w, self.cfg.combo_h, cls=[combo.type])
-        self._draw_text(p, self._split_text(combo.key.tap), cls=[combo.type])
-        self._draw_text(
-            p + Point(0, self.cfg.combo_h / 2 - self.cfg.small_pad), [combo.key.hold], cls=[combo.type, "hold"]
+        self._draw_rect(p, self.cfg.combo_w, self.cfg.combo_h, classes=[combo.type])
+
+        self._draw_legend(p, self._split_text(combo.key.tap), key_type=combo.type, legend_type="tap")
+        self._draw_legend(
+            p + Point(0, self.cfg.combo_h / 2 - self.cfg.small_pad),
+            [combo.key.hold],
+            key_type=combo.type,
+            legend_type="hold",
         )
-        self._draw_text(
+        self._draw_legend(
             p - Point(0, self.cfg.combo_h / 2 - self.cfg.small_pad),
             [combo.key.shifted],
-            cls=[combo.type, "shifted"],
+            key_type=combo.type,
+            legend_type="shifted",
         )
 
     def print_layer(
         self, p_0: Point, layer_keys: Sequence[LayoutKey], combos: Sequence[ComboSpec], empty_layer: bool = False
     ) -> None:
         """
         Given anchor coordinates p_0, print SVG code for keys and combos for a given layer.
@@ -219,34 +271,34 @@
         board_w = self.layout.width + 2 * self.cfg.outer_pad_w
         board_h = (
             len(layers) * self.layout.height
             + (len(layers) + 1) * self.cfg.outer_pad_h
             + sum(top_offset + bot_offset for top_offset, bot_offset in offsets_per_layer.values())
         )
         self.out.write(
-            f'<svg width="{board_w}" height="{board_h}" viewBox="0 0 {board_w} {board_h}" '
+            f'<svg width="{board_w}" height="{board_h}" viewBox="0 0 {board_w} {board_h}" class="keymap" '
             'xmlns="http://www.w3.org/2000/svg">\n'
         )
+
+        self.out.write(self.glyph_handler.get_glyph_defs())
+
         self.out.write(f"<style>{self.cfg.svg_style}</style>\n")
 
         p = Point(self.cfg.outer_pad_w, 0.0)
         for name, layer_keys in layers.items():
             # per-layer class group
             self.out.write(f'<g class="layer-{name}">\n')
 
             # draw layer name
             layer_header = name
             if self.cfg.append_colon_to_layer_header:
                 layer_header += ":"
-            self._draw_text(p + Point(0, self.cfg.outer_pad_h / 2), [layer_header], cls=["label"])
-
-            # get offsets added by combo alignments
-            combo_offset_top, combo_offset_bot = offsets_per_layer[name]
+            self._draw_text(p + Point(0, self.cfg.outer_pad_h / 2), layer_header, classes=["label"])
 
-            # draw keys and combos
-            p += Point(0, self.cfg.outer_pad_h + combo_offset_top)
+            # get offsets added by combo alignments, draw keys and combos
+            p += Point(0, self.cfg.outer_pad_h + offsets_per_layer[name][0])
             self.print_layer(p, layer_keys, combos_per_layer[name], empty_layer=combos_only)
-            p += Point(0, self.layout.height + combo_offset_bot)
+            p += Point(0, self.layout.height + offsets_per_layer[name][1])
 
             self.out.write("</g>\n")
 
         self.out.write("</svg>\n")
```

## keymap_drawer/keymap.py

```diff
@@ -53,14 +53,15 @@
 
     key_positions: Sequence[int] = Field(alias="p")
     key: LayoutKey = Field(alias="k")
     layers: Sequence[str] = Field(alias="l", default=[])
     align: Literal["mid", "top", "bottom", "left", "right"] = Field(alias="a", default="mid")
     offset: float = Field(alias="o", default=0.0)
     dendron: bool | None = Field(alias="d", default=None)
+    slide: float | None = Field(alias="s", default=None)
     type: str = "combo"
 
     @classmethod
     def normalize_fields(cls, spec_dict: dict) -> dict:
         """Normalize spec_dict so that each field uses its alias and key is parsed to LayoutKey."""
         for name, field in cls.__fields__.items():
             if name in spec_dict:
@@ -70,14 +71,27 @@
         return spec_dict
 
     @validator("key", pre=True)
     def get_key(cls, val) -> LayoutKey:
         """Parse each key from its key spec."""
         return val if isinstance(val, LayoutKey) else LayoutKey.from_key_spec(val)
 
+    @validator("key_positions")
+    def validate_positions(cls, val) -> Sequence[str]:
+        """Make sure each combo has at least two positions."""
+        assert len(val) >= 2, f"Need at least two key positions for combo but got {val}"
+        return val
+
+    @validator("slide")
+    def validate_slide(cls, val) -> float:
+        """Ensure slide is between -1 and 1."""
+        if val is not None:
+            assert -1.0 <= val <= 1.0, f"Slide value needs to be in [-1, 1] but got {val}"
+        return val
+
 
 class KeymapData(BaseModel):
     """Represents all data pertaining to a keymap, including layers, combos and physical layout."""
 
     layers: Mapping[str, Sequence[LayoutKey]]
     combos: Sequence[ComboSpec] = []
```

## keymap_drawer/parse.py

```diff
@@ -1,15 +1,15 @@
 """Module to parse QMK/ZMK keymaps into KeymapData and then dump them to dict."""
 import re
 import json
 from io import StringIO, TextIOWrapper
 from pathlib import Path
 from abc import ABC
 from itertools import chain
-from typing import Sequence, BinaryIO
+from typing import Sequence
 
 import yaml
 import pyparsing as pp
 from pcpp.preprocessor import Preprocessor, OutputDirective, Action  # type: ignore
 
 from .keymap import LayoutKey, ComboSpec, KeymapData
 from .config import ParseConfig
@@ -53,33 +53,23 @@
             self.layer_activated_from[to_layer] |= self.layer_activated_from.get(from_layer, set())
 
     def add_held_keys(self, layers: dict[str, list[LayoutKey]]) -> dict[str, list[LayoutKey]]:
         """Add "held" specifiers to keys that we previously determined were held to activate a given layer."""
         assert self.layer_names is not None
         for layer_index, activating_keys in self.layer_activated_from.items():
             for key in activating_keys:
-                layers[self.layer_names[layer_index]][key].type = "held"
+                layers[self.layer_names[layer_index]][key] = LayoutKey(type="held")
         return layers
 
-    def _parse(self, in_buf: BinaryIO, file_name: str | None = None) -> tuple[dict, KeymapData]:
+    def _parse(self, in_str: str, file_name: str | None = None) -> tuple[dict, KeymapData]:
         raise NotImplementedError
 
-    def parse(self, in_arg: Path | BinaryIO, file_name: str | None = None) -> dict:
-        """Wrapper to call parser on a file handle, given a handle or a file path."""
-        match in_arg:
-            # TODO: Figure out why BinaryIO doesn't match open file handle `_io.BufferedReader` or
-            # UploadedFile returned by streamlit's file_uploader widget
-            # case BinaryIO():
-            #     return self._parse(in_arg)
-            case Path():
-                with open(in_arg, "rb") as f:
-                    layout, keymap_data = self._parse(f, str(in_arg))
-            case _:
-                # raise ValueError(f"Unknown input argument {in_arg} with type {type(in_arg)} for parsing")
-                layout, keymap_data = self._parse(in_arg, file_name)
+    def parse(self, in_buf: TextIOWrapper) -> dict:
+        """Wrapper to call parser on a file handle and do post-processing after firmware-specific parsing."""
+        layout, keymap_data = self._parse(in_buf.read(), in_buf.name)
 
         if self.base_keymap is not None:
             keymap_data.rebase(self.base_keymap)
 
         keymap_dump = keymap_data.dump(self.columns)
 
         if layout:
@@ -87,14 +77,15 @@
         return keymap_dump
 
 
 class QmkJsonParser(KeymapParser):
     """Parser for json-format QMK keymaps, like Configurator exports or `qmk c2json` outputs."""
 
     _prefix_re = re.compile(r"\bKC_")
+    _trans_re = re.compile(r"TRANSPARENT|TRNS|_______")
     _mo_re = re.compile(r"MO\((\d+)\)")
     _mts_re = re.compile(r"([A-Z_]+)_T\((\S+)\)")
     _mtl_re = re.compile(r"MT\((\S+), *(\S+)\)")
     _lt_re = re.compile(r"LT\((\d+), *(\S+)\)")
     _osm_re = re.compile(r"OSM\(MOD_(\S+)\)")
     _osl_re = re.compile(r"OSL\((\d+)\)")
 
@@ -109,42 +100,47 @@
         assert self.layer_names is not None
 
         def mapped(key: str) -> LayoutKey:
             return LayoutKey.from_key_spec(self.cfg.qmk_keycode_map.get(key, key.replace("_", " ")))
 
         key_str = self._prefix_re.sub("", key_str)
 
-        if m := self._mo_re.fullmatch(key_str):
+        if m := self._trans_re.fullmatch(key_str):  # transparent
+            return LayoutKey.from_key_spec(self.cfg.trans_legend)
+        if m := self._mo_re.fullmatch(key_str):  # momentary layer
             to_layer = int(m.group(1).strip())
             self.update_layer_activated_from(current_layer, to_layer, key_positions)
             return LayoutKey(tap=self.layer_names[to_layer])
-        if m := self._mts_re.fullmatch(key_str):
+        if m := self._mts_re.fullmatch(key_str):  # short mod-tap syntax
             tap_key = mapped(m.group(2).strip())
             return LayoutKey(tap=tap_key.tap, hold=m.group(1), shifted=tap_key.shifted)
-        if m := self._mtl_re.fullmatch(key_str):
+        if m := self._mtl_re.fullmatch(key_str):  # long mod-tap syntax
             tap_key = mapped(m.group(2).strip())
             return LayoutKey(tap=tap_key.tap, hold=m.group(1).strip(), shifted=tap_key.shifted)
-        if m := self._lt_re.fullmatch(key_str):
+        if m := self._lt_re.fullmatch(key_str):  # layer-tap
             to_layer = int(m.group(1).strip())
             self.update_layer_activated_from(current_layer, to_layer, key_positions)
             tap_key = mapped(m.group(2).strip())
             return LayoutKey(tap=tap_key.tap, hold=self.layer_names[to_layer], shifted=tap_key.shifted)
-        if m := self._osm_re.fullmatch(key_str):
+        if m := self._osm_re.fullmatch(key_str):  # one-shot mod
             tap_key = mapped(m.group(1).strip())
             return LayoutKey(tap=tap_key.tap, hold=self.cfg.sticky_label, shifted=tap_key.shifted)
-        if m := self._osl_re.fullmatch(key_str):
+        if m := self._osl_re.fullmatch(key_str):  # one-shot layer
             to_layer = int(m.group(1).strip())
             self.update_layer_activated_from(current_layer, to_layer, key_positions)
             return LayoutKey(tap=self.layer_names[to_layer], hold=self.cfg.sticky_label)
         return mapped(key_str)
 
-    def _parse(self, in_buf: BinaryIO, file_name: str | None = None) -> tuple[dict, KeymapData]:
-        """Parse a JSON keymap with its file handle and return the layout spec and KeymapData to be dumped to YAML."""
+    def _parse(self, in_str: str, file_name: str | None = None) -> tuple[dict, KeymapData]:
+        """
+        Parse a JSON keymap with its file content and path (unused), then return the layout spec and KeymapData
+        to be dumped to YAML.
+        """
 
-        raw = json.load(in_buf)
+        raw = json.loads(in_str)
 
         layout = {}
         if "keyboard" in raw:
             layout["qmk_keyboard"] = raw["keyboard"]
         if "layout" in raw:
             layout["qmk_layout"] = raw["layout"]
 
@@ -207,16 +203,18 @@
                 )
             )
             if no_shifted:
                 mapped.shifted = ""
             return mapped
 
         match binding.split():
-            case ["&none"] | ["&trans"]:
+            case ["&none"]:
                 return LayoutKey()
+            case ["&trans"]:
+                return LayoutKey.from_key_spec(self.cfg.trans_legend)
             case [ref]:
                 return LayoutKey(tap=ref)
             case ["&kp", par]:
                 return mapped(par)
             case ["&sk", par]:
                 l_key = mapped(par)
                 return LayoutKey(tap=l_key.tap, hold=self.cfg.sticky_label, shifted=l_key.shifted)
@@ -234,30 +232,29 @@
                     self.update_layer_activated_from(current_layer, int(hold_par), key_positions)
                 except (ValueError, IndexError):  # not a layer-tap, so maybe a keycode?
                     hold = mapped(hold_par).tap
                 tap_key = mapped(tap_par)
                 return LayoutKey(tap=tap_key.tap, hold=hold, shifted=tap_key.shifted)
         return LayoutKey(tap=binding)
 
-    def _get_prepped(self, in_buf: BinaryIO) -> str:
-        wrapper = TextIOWrapper(in_buf, encoding="utf-8")
+    def _get_prepped(self, in_str: str, file_name: str | None = None) -> str:
         if self.cfg.preprocess:
 
             def include_handler(*args):
                 raise OutputDirective(Action.IgnoreAndPassThrough)
 
             preprocessor = Preprocessor()
             preprocessor.line_directive = None
             preprocessor.on_include_not_found = include_handler
-            preprocessor.parse(wrapper)
+            preprocessor.parse(in_str, source=file_name)
             with StringIO() as f_out:
                 preprocessor.write(f_out)
                 prepped = f_out.getvalue()
         else:
-            prepped = wrapper.read()
+            prepped = in_str
         return re.sub(r"^\s*#.*?$", "", prepped)
 
     def _find_nodes_with_name(
         self, parsed: pp.ParseResults, node_name: str | None = None
     ) -> list[tuple[str, pp.ParseResults]]:
         found_nodes = []
         for elt_p, elt_n in zip(parsed[:-1], parsed[1:]):
@@ -332,17 +329,19 @@
                 # see if combo had additional properties specified in the config, if so merge them in
                 cfg_combo = ComboSpec.normalize_fields(self.cfg.zmk_combos.get(name, {}))
                 combos.append(ComboSpec(**(combo | cfg_combo)))
             except (AttributeError, ValueError):
                 continue
         return combos
 
-    def _parse(self, in_buf: BinaryIO, file_name: str | None = None) -> tuple[dict, KeymapData]:
-        """Parse a ZMK keymap with its file handle and return the layout spec and KeymapData to be dumped to YAML."""
-        prepped = self._get_prepped(in_buf)
+    def _parse(self, in_str: str, file_name: str | None = None) -> tuple[dict, KeymapData]:
+        """
+        Parse a ZMK keymap with its content and path and return the layout spec and KeymapData to be dumped to YAML.
+        """
+        prepped = self._get_prepped(in_str, file_name)
         parsed = [
             node
             for node in (
                 pp.nested_expr("{", "};")
                 .ignore("//" + pp.SkipTo(pp.lineEnd))
                 .ignore(pp.c_style_comment)
                 .parse_string("{ " + self._nodelabel_re.sub(r"\1:\2 {", prepped) + " };")[0]
```

## keymap_drawer/physical_layout.py

```diff
@@ -9,20 +9,22 @@
 from pathlib import Path
 from functools import cached_property, lru_cache
 from typing import Sequence, Literal
 from urllib.request import urlopen
 from urllib.error import HTTPError
 
 from pydantic import BaseModel, root_validator
+from platformdirs import user_cache_dir
 
 from .config import DrawConfig
 
 
 QMK_LAYOUTS_PATH = Path(__file__).parent.parent / "resources" / "qmk_layouts"
 QMK_METADATA_URL = "https://keyboards.qmk.fm/v1/keyboards/{keyboard}/info.json"
+CACHE_LAYOUTS_PATH = Path(user_cache_dir("keymap-drawer", False)) / "qmk_layouts"
 
 
 @dataclass(frozen=True)
 class Point:
     """Simple class representing a 2d point."""
 
     x: float
@@ -57,15 +59,15 @@
     width: float
     height: float
     rotation: float = 0  # CW if positive
     rotation_pos: Point | None = None  # pos (key center) by default
     bounding_width: float = 0.0
     bounding_height: float = 0.0
 
-    def __post_init__(self):
+    def __post_init__(self) -> None:
         if self.rotation:
             # recalculate key center after rotation
             if self.rotation_pos is not None:
                 self.pos = self._rotate_point(self.rotation_pos, self.pos, self.rotation)
 
             # calculate bounding box dimensions
             rotated_corners = [
@@ -129,15 +131,15 @@
     if len([arg for arg in (qmk_keyboard, qmk_info_json, ortho_layout) if arg is not None]) != 1:
         raise ValueError(
             'Please provide exactly one of "qmk_keyboard", "qmk_info_json" or "ortho_layout" specs for physical layout'
         )
 
     if qmk_keyboard or qmk_info_json:
         if qmk_keyboard:
-            qmk_info = get_qmk_info(qmk_keyboard)
+            qmk_info = _get_qmk_info(qmk_keyboard, config.use_local_cache)
         else:  # qmk_info_json
             assert qmk_info_json is not None
             with open(qmk_info_json, "rb") as f:
                 qmk_info = json.load(f)
 
         if isinstance(qmk_info, list):
             assert qmk_layout is None, "Cannot use qmk_layout with a list-format QMK spec"
@@ -286,25 +288,36 @@
                 rotation_pos=None if k.rx is None or k.ry is None else key_size * Point(k.rx - x_min, k.ry - y_min),
             )
             for k in self.layout
         ]
 
 
 @lru_cache(maxsize=128)
-def get_qmk_info(qmk_keyboard: str, save_local_copy: bool = False):
-    """Get a QMK info.json file from either self-maintained folder of layouts or from QMK keyboards metadata API."""
+def _get_qmk_info(qmk_keyboard: str, use_local_cache: bool = False):
+    """
+    Get a QMK info.json file from either self-maintained folder of layouts,
+    local file cache if enabled, or from QMK keyboards metadata API.
+    """
     local_path = QMK_LAYOUTS_PATH / f"{qmk_keyboard.replace('/', '@')}.json"
+    cache_path = CACHE_LAYOUTS_PATH / f"{qmk_keyboard.replace('/', '@')}.json"
+
     if local_path.is_file():
         with open(local_path, "rb") as f:
             return json.load(f)
+
+    if use_local_cache and cache_path.is_file():
+        with open(cache_path, "rb") as f:
+            return json.load(f)
+
     try:
         with urlopen(QMK_METADATA_URL.format(keyboard=qmk_keyboard)) as f:
             info = json.load(f)["keyboards"][qmk_keyboard]
-            if save_local_copy:
-                with open(local_path, "w", encoding="utf-8") as f_out:
-                    json.dump({"layouts": info["layouts"]}, f_out)
+        if use_local_cache:
+            cache_path.parent.mkdir(parents=True, exist_ok=True)
+            with open(cache_path, "w", encoding="utf-8") as f_out:
+                json.dump({"layouts": info["layouts"]}, f_out)
         return info
     except HTTPError as exc:
         raise ValueError(
             f"QMK keyboard '{qmk_keyboard}' not found, please make sure you specify an existing keyboard "
             "(hint: check from https://config.qmk.fm)"
         ) from exc
```

## resources/zmk_keyboard_layouts.yaml

```diff
@@ -69,34 +69,36 @@
 tidbit: {qmk_keyboard: nullbitsco/tidbit}
 two_percent_milk: {ortho_layout: {split: false, rows: 2, columns: 1}}
 waterfowl: {qmk_keyboard: waterfowl}
 zmk_uno: null
 zodiark: {qmk_keyboard: aleblazer/zodiark}
 
 # Custom boards and shields -- partially following https://github.com/manna-harbour/miryoku/discussions/81
-adv360: {qmk_keyboard: ergodox_ez/base, qmk_layout: LAYOUT_ergodox_pretty}
-adv360pro: {qmk_keyboard: ergodox_ez/base, qmk_layout: LAYOUT_ergodox_pretty}
+adv360: {qmk_keyboard: adv360}
+adv360pro: {qmk_keyboard: adv360}
 ahokore: {qmk_keyboard: obosob/arch_36}
 ahokore: {qmk_keyboard: obosob/arch_36}
 arch36: {qmk_keyboard: obosob/arch_36}
 basbousa: {qmk_keyboard: clog}
 battoota: {qmk_keyboard: berylline}
 berylline: {qmk_keyboard: berylline}
 ble_chiffre: {ortho_layout: {split: true, rows: 3, columns: 5, thumbs: 2}}
 breeze: {qmk_keyboard: afternoonlabs/breeze/rev1}
 bt65: {qmk_keyboard: novelkeys/nk65}
 chocofi: {qmk_keyboard: chocofi}
 chocv: {qmk_keyboard: chocv}
 clog_v2: {qmk_keyboard: clog}
+dao: {qmk_keyboard: jorne/rev1}
 dilemma: {qmk_keyboard: bastardkb/dilemma/3x5_2/assembled}
 draculad: {qmk_keyboard: draculad}
 draculady: {qmk_keyboard: obosob/arch_36}
 ergotravel: {qmk_keyboard: ergotravel/rev1}
 ffkb: {qmk_keyboard: fingerpunch/ffkb}
 gatoraid40: {ortho_layout: {split: true, rows: 3, columns: 6, thumbs: 3, drop_pinky: true}}
+glove80: {qmk_keyboard: glove80}
 hakea: {qmk_keyboard: sofle/rev1}
 hhkb: {qmk_keyboard: hhkb/ansi/32u4}
 hillside46: {qmk_keyboard: hillside/46/0_1}
 hillside48: {qmk_keyboard: hillside/48/0_1}
 hillside52: {qmk_keyboard: hillside/52/0_1}
 horizon: {qmk_keyboard: horizon}
 humla: {qmk_keyboard: obosob/arch_36}
```

## Comparing `keymap_drawer-0.6.0.dist-info/METADATA` & `keymap_drawer-0.7.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,44 +1,48 @@
 Metadata-Version: 2.1
 Name: keymap-drawer
-Version: 0.6.0
+Version: 0.7.0
 Summary: A module and CLI tool to help parse and draw keyboard layouts.
 Home-page: https://github.com/caksoylar/keymap-drawer
 License: MIT
 Author: Cem Aksoylar
 Author-email: caksoylar@gmail.com
 Requires-Python: >=3.10,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Requires-Dist: pcpp (>=1.30,<2.0)
-Requires-Dist: pydantic (>=1.10.2,<2.0.0)
+Requires-Dist: platformdirs (>=3.5.1,<4.0.0)
+Requires-Dist: pydantic (>=1.10.7,<2.0.0)
 Requires-Dist: pyparsing (>=3.0.9,<4.0.0)
 Requires-Dist: pyyaml (>=6.0,<7.0)
 Project-URL: Bug Tracker, https://github.com/caksoylar/keymap-drawer/issues
 Project-URL: Repository, https://github.com/caksoylar/keymap-drawer
 Description-Content-Type: text/markdown
 
 # `keymap-drawer`
 
+[![PyPI version](https://img.shields.io/pypi/v/keymap-drawer.svg)](https://pypi.org/project/keymap-drawer/)
+
 Parse QMK & ZMK keymaps and draw them in vector graphics (SVG) format, with support for visualizing hold-taps and combos that are commonly used with smaller keyboards.
 
 Available as a [command-line tool](#command-line-tool-installation) or a [web application](https://caksoylar.github.io/keymap-drawer).
 
-![Example keymap](https://caksoylar.github.io/keymap-drawer/3x5.rot.svg)
+[![Example keymap](https://caksoylar.github.io/keymap-drawer/showcase.svg)](examples/showcase.yaml)
 
 ## Features
 
 - Draw keymap representations consisting of multiple layers, hold-tap keys and combos
   - Uses a human-editable YAML format for specifying the keymap
   - Non-adjacent or 3+ key combos can be visualized by specifying its positioning relative to the keys, with automatically drawn dendrons to keys
 - Bootstrap the YAML representation by automatically parsing QMK or ZMK keymap files
 - Arbitrary physical keyboard layouts (with rotated keys!) supported, along with parametrized ortho layouts
 - Both parsing and drawing are customizable with a config file, see ["Customization" section](#customization)
+- Custom glyph support: render custom svg icons and not just unicode text
 
 See examples in [the live web demo](https://caksoylar.github.io/keymap-drawer) for example inputs and outputs.
 
 Compared to to visual editors like [KLE](http://www.keyboard-layout-editor.com/), `keymap-drawer` takes a more programmatic approach.
 It also decouples the physical keyboard layout from the keymap (i.e., layer and combo definitions) and provides the tooling to bootstrap it quickly from existing firmware configuration.
 
 ## Usage
@@ -155,14 +159,79 @@
 
 ```sh
 KEYMAP_raw_binding_map='{"&bootloader": "BOOT"}' keymap parse -z zmk-config/config/cradio.keymap >cradio.yaml
 ```
 
 Drawing parameters that are specified in the `draw_config` field can also be overridden in [the keymap YAML](KEYMAP_SPEC.md#draw_config).
 
+## Custom Glyphs
+
+Custom glyphs can be defined in the `draw_config` block of the keymap config.
+After a glyph is defined it can be used in key fields via the glyph name surrounded by `$$`, e.g. `$$vol_up$$`.
+The provided svg must specify a `viewBox`, positional or dimensional properties will be calculated by `keymap-drawer`.
+The height of the svg is bound by the config properties `glyph_{tap,hold,shifted}_size` and width will maintain the aspect ratio.
+To allow for customization, glyphs are assigned CSS classes `glyph` and `<glyph_name>`.
+
+Example:
+```yaml
+draw_config:
+  # specify the size to bound the vertical dimension of your glyph, below are defaults
+  glyph_tap_size: 14
+  glyph_hold_size: 12
+  glyph_shifted_size: 10
+  glyphs:  # mapping of glyph name to be used to svg definition
+    vol_up: |
+      <svg viewBox="2 3 34 33">
+        <path style="stroke: black; fill: black;" d="M23.41,25.25a1,1,0,0,1-.54-1.85,6.21,6.21,0,0,0-.19-10.65,1,1,0,1,1,1-1.73,8.21,8.21,0,0,1,.24,14.06A1,1,0,0,1,23.41,25.25Z"/>
+        <path style="stroke: black; fill: black;" d="M25.62,31.18a1,1,0,0,1-.45-1.89A12.44,12.44,0,0,0,25,6.89a1,1,0,1,1,.87-1.8,14.44,14.44,0,0,1,.24,26A1,1,0,0,1,25.62,31.18Z"/>
+        <path style="stroke: black; fill: black;" d="M18.33,4,9.07,12h-6a1,1,0,0,0-1,1v9.92a1,1,0,0,0,1,1H8.88l9.46,8.24A1,1,0,0,0,20,31.43V4.72A1,1,0,0,0,18.33,4Z"/>
+      </svg>
+layers:
+  Media:
+    - ["", "$$vol_up$$", "", "", ""]
+...
+```
+
+You can also use the `$$source:id$$` notation for [certain sources](keymap_drawer/config.py#L158) to automatically fetch
+the SVGs without having to define them manually in the `glyphs` field, e.g. [`$$tabler:volume$$`](https://tabler-icons.io/i/volume).
+The following `source` values are currently supported:
+- `tabler`: [Tabler Icons](https://tabler-icons.io/) (icon name as `id`)
+- `mdi`: [Pictogrammers Material Design Icons](https://pictogrammers.com/library/mdi/) (icon name as `id`)
+- `mdil`: [Pictogrammers Material Design Icons Light](https://pictogrammers.com/library/mdil/) (icon name as `id`)
+- `material`: [Google Material Symbols](https://fonts.google.com/icons) (use value in "Android" tab as `id`)
+
+Fetched SVGs will be [cached by default](keymap_drawer/config.py#L166) to speed up future runs.
+
+## Setting up an automated drawing workflow
+
+If you use a [ZMK config repo](https://zmk.dev/docs/user-setup), you can set up an automated workflow to parse your keymaps, then draw and commit SVG outputs to your repo.
+To do that you can add a new workflow to your repo at `.github/workflows/draw-keymaps.yml` that refers to the reusable `keymap-drawer` [workflow](.github/workflows/draw-zmk.yml):
+
+```yaml
+# Example for using the keymap-drawer ZMK user config workflow
+name: Draw ZMK keymaps
+on:
+  workflow_dispatch:  # can be triggered manually
+  push:               # automatically run on changes to following paths
+    paths:
+      - 'config/*.keymap'
+      - 'config/*.dtsi'
+      # - 'config/boards/*/*/*.keymap'
+
+jobs:
+  draw:
+    uses: caksoylar/keymap-drawer/.github/workflows/draw-zmk.yml@main
+    with:
+      keymap_patterns: "config/*.keymap"        # path to the keymaps to parse
+      config_path: "keymap_drawer.config.yaml"  # config file, ignored if not exists
+      output_folder: "svg"                      # path to save produced SVGs
+      parse_args: ""  # map of extra args to pass to `keymap parse`, e.g. "corne:'-l Def Lwr Rse' cradio:''"
+      draw_args: ""   # map of extra args to pass to `keymap draw`, e.g. "corne:'-k corne_rotated' cradio:'-k paroxysm'"
+```
+
 ## Development
 
 This project requires Python 3.10+ and uses [Poetry](https://python-poetry.org/) for packaging.
 
 To get started, [install Poetry](https://python-poetry.org/docs/#installation), clone this repo, then install dependencies with the `poetry` command:
 
 ```sh
@@ -184,18 +253,18 @@
 - [@leiserfg's ZMK parser](https://github.com/leiserfg/zmk-config/tree/master/parser)
 - [Keymapviz](https://github.com/yskoht/keymapviz)
 
 # Keymap YAML specification
 
 This page documents the YAML-format keymap representation that is output by `keymap parse` and used by `keymap draw`.
 
-At the root, three key values are expected, which are detailed in respective sections. A typical keymap will have the following structure:
+At the root, four fields can be specified which are detailed in respective sections. A typical keymap will have the following structure:
 
 ```yaml
-layout:      # physical layout specs, optional
+layout:      # physical layout specs, optional if used in CLI
   ...
 layers:      # ordered mapping of layer name to contents
   layer_1:   # list of (lists of) key specs
     - [Q, W, ...]
     ...
   layer_2:
     ...
@@ -235,87 +304,111 @@
 
 Following physical layout parameters can be specified either in the command line or under this field definition as key-value pairs:
 
 - **`qmk_keyboard`** (equivalent to `-k`/`--qmk-keyboard` on the command line):
   Specifies the keyboard name to use with QMK `info.json` format layout definition, retrieved from following sources in order of preference:
   - `<keyboard>.json` (with `/`'s in `<keyboard>` replaced by `@`) under [`resources/qmk_layouts`](/resources/qmk_layouts/), if it exists
   - [QMK keyboard metadata API](https://docs.qmk.fm/#/configurator_architecture?id=keyboard-metadata) that [QMK Configurator](https://config.qmk.fm) also uses
+
+  _Example:_ `layout: {qmk_keyboard: crkbd/rev1}`
 - **`qmk_info_json`** (equivalent to `-j`/`--qmk-info-json` on the command line):
   Specifies the path to a local QMK format `info.json` file to use
+
+  _Example:_ `layout: {qmk_info_json: my_special_layout.json}`
 - **`qmk_layout`** (equivalent to `-l`/`--qmk-layout` on the command line):
   Specifies the layout macro to be used for the QMK keyboard, defaults to first one specified if not used --
   should be used alongside one of the above two options
+
+  _Example:_ `layout: {qmk_keyboard: crkbd/rev1, qmk_layout: LAYOUT_split_3x5_3}`
 - **`ortho_layout`** (equivalent to `-o`/`--ortho-layout` on the command line):
   Specifies a mapping of parameters to values to generate an ortholinear physical layout, with schema:
 
   | field name   | type                     | default value | description                                                                                              |
   | ------------ | ------------------------ | ------------- | -------------------------------------------------------------------------------------------------------- |
   | `split`      | `bool`                   | `False`       | whether the layout is a split keyboard or not, affects a few other options below                         |
   | `rows`       | `int`                    | required      | how many rows are in the keyboard, excluding the thumb row if split                                      |
   | `columns`    | `int`                    | required      | how many columns are in the keyboard, only applies to one half if split                                  |
   | `thumbs`     | `int \| "MIT" \| "2x2u"` | `0`           | the number thumb keys per half if split; for non-splits can only take special values `MIT` or `2x2u`[^2] |
   | `drop_pinky` | `bool`                   | `False`       | whether the pinky (outermost) columns have one fewer key, N/A for non-splits                             |
   | `drop_inner` | `bool`                   | `False`       | whether the inner index (innermost) columns have one fewer key, N/A for non-splits                       |
 
+  _Example:_ `layout: {ortho_layout: {split: true, rows: 3, columns: 5, thumbs: 3}}`
+
 [^2]: Corresponding to bottom row arrangements of a single `2u` key, or two neighboring `2u` keys, respectively.
 
 **Hint**: You can use the [QMK Configurator](https://config.qmk.fm/) to search for `qmk_keyboard` and `qmk_layout` values, and preview the physical layout.
 
 > **Note**
 >
 > If these parameters are specified in both command line and under the `layout` section, the former will take precedence.
 
 ## `layers`
 
 This field is an ordered mapping of layer names to a list of `LayoutKey` specs that represent the keys on that layer.
 A `LayoutKey` can be defined with either a string value or with a mapping with the following fields:
 
-| field name (alias) | type  | default value | description                                                                                                                                                                                                                        |
-| ------------------ | ----- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| `tap` (`t`)        | `str` | `""`          | the tap action of a key, drawn on the center of the key; spaces will be converted to line breaks[^3]                                                                                                                               |
-| `hold` (`h`)       | `str` | `""`          | the hold action of a key, drawn on the bottom of the key                                                                                                                                                                           |
-| `shifted` (`s`)    | `str` | `""`          | the "shifted" action of a key, drawn on the top of the key                                                                                                                                                                         |
-| `type`             | `str` | `""`          | the styling of the key that corresponds to the [SVG class](keymap_drawer/config.py#L62)[^4]. predefined types are `held` (a red shading to denote held down keys) and `ghost` (a gray shading to denote optional keys in a layout) |
+| field name (alias) | type  | default value | description                                                                                                                                                                                                                                                                  |
+| ------------------ | ----- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `tap` (`t`)        | `str` | `""`          | the tap action of a key, drawn on the center of the key; spaces will be converted to line breaks[^3]                                                                                                                                                                         |
+| `hold` (`h`)       | `str` | `""`          | the hold action of a key, drawn on the bottom of the key                                                                                                                                                                                                                     |
+| `shifted` (`s`)    | `str` | `""`          | the "shifted" action of a key, drawn on the top of the key                                                                                                                                                                                                                   |
+| `type`             | `str` | `""`          | the styling of the key that corresponds to the [SVG class](keymap_drawer/config.py#L51)[^4]. predefined types are `held` (a red shading to denote held down keys), `ghost` (a gray shading to denote optional keys in a layout), `trans` (lighter text for transparent keys) |
 
 [^3]: You can prevent line breaks by using double spaces `"  "` to denote a single non-breaking space.
 [^4]: Text styling can be overridden in the SVG config using the `"tap"`, `"hold"` and `"shifted"` classes if desired.
 
 Using a string value such as `"A"` for a key spec is equivalent to defining a mapping with only the tap field, i.e., `{tap: "A"}`.
 It is meant to be used as a shortcut for keys that do not need `hold` or `type` fields.
 
 `layers` field also flattens any lists that are contained in its value: This allows you to semantically divide keys to "rows," if you prefer to do so.
 The two layers in the following example are functionally identical:
 
 ```yaml
 layers:
-  flat_layer: ["7", "8", "9", "4", "5", "6", "1", "2", "3", { t: "0", h: Fn }]
+  flat_layer: ["7", "8", "9", "4", "5", "6", "1", "2", "3", {t: "0", h: Fn}]
   nested_layer:
     - ["7", "8", "9"]
     - ["4", "5", "6"]
     - ["1", "2", "3"]
-    - { t: "0", h: Fn }
+    - {t: "0", h: Fn}
 ```
 
 ## `combos`
 
 This is an optional field that contains a list of combo specs, each of which is a mapping that can have the following fields:
 
 | field name (alias)    | type                                              | default value | description                                                                                                                                                                       |
 | --------------------- | ------------------------------------------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 | `key_positions` (`p`) | `list[int]`                                       | required      | list of key indices that trigger the combo[^5]                                                                                                                                    |
 | `key` (`k`)           | `LayoutKey`[^6]                                   | required      | key produced by the combo when triggered, `type` field will be ignored                                                                                                            |
 | `layers` (`l`)        | `list[str]`                                       | `[]`[^7]      | list of layers the combo can trigger on, specified using layer names in `layers` field                                                                                            |
 | `align` (`a`)         | `"mid" \| "top" \| "bottom" \| "left" \| "right"` | `"mid"`       | where to draw the combo: `mid` draws on the mid-point of triggering keys' center coordinates, or to the `top`/`bottom`/`left`/`right` of the triggering keys                      |
 | `offset` (`o`)        | `float`                                           | `0.0`         | additional offset to `top`/`bottom`/`left`/`right` positioning, specified in units of key width/height: useful for combos that would otherwise overlap                            |
 | `dendron` (`d`)       | `null \| bool`                                    | `null`        | whether to draw dendrons going from combo to triggering key coordinates, default is to draw for non-`mid` alignments and draw for `mid` if key coordinates are far from the combo |
-| `type`                | `str`                                             | `"combo"`     | the styling of the key that corresponds to the [SVG class](keymap_drawer/config.py#L62), see `LayoutKey` definition above                                                         |
+| `slide` (`s`)         | `null \| float (-1 <= val <= 1)`                  | `null`        | slide the combo box along an axis between keys -- can be used for moving `top`/`bottom` combo boxes left/right, `left`/`right` boxes up/down, or `mid` combos between two keys    |
+| `type`                | `str`                                             | `"combo"`     | the styling of the key that corresponds to the [SVG class](keymap_drawer/config.py#L51), see `LayoutKey` definition above                                                         |
 
 [^5]: Key indices start from `0` on the first key position and increase by columns and then rows, corresponding to their ordering in the `layers` field. This matches the `key-positions` property in ZMK combo definitions.
 [^6]: Just like for keys in a layer under the `layers` field, `key` field can be specified with a string value as a shortcut, or a mapping (where the `type` field will be ignored).
 [^7]: The default value of empty list corresponds to all layers in the keymap, similar to the `layers` property in ZMK.
 
+_Example:_
+```yaml
+combos:
+  - {p: [0, 1], k: Tab, l: [Qwerty]}
+  - {p: [1, 2], k: Esc, l: [Qwerty]}
+```
+
 ## `draw_config`
 
 This optional field lets you override [config parameters](README.md#customization) for SVG drawing.
 This way you can specify drawing configuration for a specific layout and store in the keymap specification.
 It is a mapping from field names in [`DrawConfig` class](keymap_drawer/config.py) to values.
 
+_Example:_
+```yaml
+draw_config:
+  key_h: 60
+  combo_h: 22
+  combo_w: 24
+```
+
```

## Comparing `keymap_drawer-0.6.0.dist-info/LICENSE` & `keymap_drawer-0.7.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `keymap_drawer-0.6.0.dist-info/RECORD` & `keymap_drawer-0.7.0.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 keymap_drawer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-keymap_drawer/__main__.py,sha256=ZQN1zxXaa5KV1OyOCvT524VXLP5lnqkas6YALmwdezQ,6809
-keymap_drawer/config.py,sha256=nZGKEhtPmRlUU4miYrNxRZLg3D7Zy4PhSUgmTZYOt5Y,7634
-keymap_drawer/draw.py,sha256=GkSBGnBa10nvFvq_gAQ2IIMsUJe4Ca2HWs1ea84KcM8,11271
-keymap_drawer/keymap.py,sha256=ttdugI_DX8_0TvxhRGyvikAUumDvU7Oj4MG1ITI472c,8818
-keymap_drawer/parse.py,sha256=UlZmFs22i5-usb3X-jV3ANqduPxI0JvUEETcHxRFmPM,16827
-keymap_drawer/physical_layout.py,sha256=pZJvqYuVsZmhX8C90g4i20foBL1uaEfyRT3lMx0WCvw,11843
+keymap_drawer/__main__.py,sha256=-PvloduMyLgXI5sFVOWUlAyckZ7DGbUDjBxbYFepVx8,6730
+keymap_drawer/config.py,sha256=YGZLdRNo4pWLirYOiFdvPmSjlYdMQhKLnKfAXmkvOSk,9260
+keymap_drawer/draw.py,sha256=pJFKogqoc2Lvt47BHwMleIeC43is3sbiELcxXiN80vA,13163
+keymap_drawer/glyph.py,sha256=bLDtb_Zcl6fHMCxJ6JGcgogcXhb-U84fkEHDckDvR1s,5798
+keymap_drawer/keymap.py,sha256=saEQG30NgVftS7cax60aHmx9i1WHiEm4RZdm1p0yGSk,9388
+keymap_drawer/parse.py,sha256=GZn-UN_5qkYm9prz_FV1kgfd-RtN0qI_0H0yqdZNx-Q,16713
+keymap_drawer/physical_layout.py,sha256=xKtFg3p9DjVBURHdA0KpU6vPKFr3gkxmaDc0cjoo1v0,12301
+resources/qmk_layouts/adv360.json,sha256=MM5xOXcn9-O4hzei6RPJoFhLbqz86fEqczdqGU6N2uE,4183
 resources/qmk_layouts/berylline.json,sha256=lsTJzCcQ78TeYUYoBa67fAb4cm6_phrwL9eHphw4qq4,2114
 resources/qmk_layouts/chocofi.json,sha256=Lsayi_fcsljEGGmQwmI_KLUf7snLy_qEqSSVbFcpEkQ,2267
 resources/qmk_layouts/clog.json,sha256=wzkTRyevr0OkZoFNJkWRQ8APpKQ3S5cBiuwdxSnTRt8,2437
 resources/qmk_layouts/corne_rotated.json,sha256=8hTZZSuP4C2p9ywDtnW4o8ThNC9Zw0ue9qwGX1aaOXk,3502
-resources/qmk_layouts/ergodox_thumb.json,sha256=CLufx7i-t2v2xXZ4_dR9-ymPZlQVjII2aogeE201fuc,779
 resources/qmk_layouts/fingerpunch@ffkb.json,sha256=toAtmnP65nnEGE-alZUGShf5E-l58vvl3nipRBBh9hQ,3684
 resources/qmk_layouts/fingerpunch@luakeeb.json,sha256=-kfdKkkZKYZgaippjtyGY1fDDsq_is0j4fJwabY2jVg,2153
-resources/qmk_layouts/fingerpunch@sweep36.json,sha256=gv2q0UFXr5P9ARyKJdkoLQ3UxeJKftl7lp5m3kuCe9s,1817
+resources/qmk_layouts/glove80.json,sha256=nVaOqX5UofUcPIstYu29pT1vPyqyNpV8cXcX4e0b8Dk,3353
 resources/qmk_layouts/klor.json,sha256=nOaBAd6RzOW2KIo_ejmNo_czH0X4NFqTyZphrjtdiHU,9984
 resources/qmk_layouts/klotz.json,sha256=jV-tpL1FixKxk78_EnW4UvfricUYsFfFbWf-j1SeY7Y,2537
-resources/qmk_layouts/miryoku.json,sha256=ykjHtI2xuWNk6d6WswHDzxaTyrhSE1P_WW76wTG6B-w,1293
 resources/qmk_layouts/osprey.json,sha256=_2qw3uVKeuZNybUEhWpcy0U831lldj1LfH6szXeh_j4,1783
 resources/qmk_layouts/paroxysm.json,sha256=y17689V0dqnDhmDgxlzw1kPnNaQub-GHgrsa4-kEV_8,2466
 resources/qmk_layouts/revxlp.json,sha256=FRFgeD6PAQAwDg1gVEZPJl7-tPdTFv7HSQ7Pc-62hgI,3728
 resources/qmk_layouts/rufous.json,sha256=6VtvTikJtgEYx0xfkSTT9_KaLdW5TfmoFoaz0uf5GYQ,2838
 resources/qmk_layouts/totem.json,sha256=HXKwNwjT9lByzFhqlAFhxhhp_SYerOsTasJwUppCh4U,2803
-resources/zmk_keyboard_layouts.yaml,sha256=fdqZu_OjuaYXYNR4zrF6SGTkapMjYCFhsut8m_pVb94,6267
-keymap_drawer-0.6.0.dist-info/METADATA,sha256=sSg7SI58jJ2tYEjwsA3uXDCXNnx8K9TxTXxt_ZJssVo,21555
-keymap_drawer-0.6.0.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
-keymap_drawer-0.6.0.dist-info/LICENSE,sha256=ym_5D56d6k2MroMU8y9ZDt1ZUI4H7PYgbfa87rNFCaM,1069
-keymap_drawer-0.6.0.dist-info/entry_points.txt,sha256=kog7wHfRs-vFQWhh8V3H-Ra4UPbW1nINE9VHJZ1aK2w,54
-keymap_drawer-0.6.0.dist-info/RECORD,,
+resources/zmk_keyboard_layouts.yaml,sha256=jC_CzZWmyIXWAIxSER877imSqI0u_0trMzxBLQDIsL0,6244
+keymap_drawer-0.7.0.dist-info/METADATA,sha256=k7UEMv-0Ro4wtmmzhNhcVB5xI_0-u2oxhgldHh08XYM,26355
+keymap_drawer-0.7.0.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
+keymap_drawer-0.7.0.dist-info/LICENSE,sha256=ym_5D56d6k2MroMU8y9ZDt1ZUI4H7PYgbfa87rNFCaM,1069
+keymap_drawer-0.7.0.dist-info/entry_points.txt,sha256=kog7wHfRs-vFQWhh8V3H-Ra4UPbW1nINE9VHJZ1aK2w,54
+keymap_drawer-0.7.0.dist-info/RECORD,,
```

