# Comparing `tmp/krptn-0.6.0-pp39-pypy39_pp73-win_amd64.whl.zip` & `tmp/krptn-0.6.1-pp39-pypy39_pp73-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 3504848 bytes, number of entries: 28
--rw-rw-rw-  2.0 fat   141824 b- defN 23-May-15 11:05 __CryptoLib.pypy39-pp73-win_amd64.pyd
--rw-rw-rw-  2.0 fat      182 b- defN 23-May-15 11:00 kr-openssl-config/fipsmodule.cnf
--rw-rw-rw-  2.0 fat    12682 b- defN 23-May-15 10:58 kr-openssl-config/openssl.cnf
--rw-rw-rw-  2.0 fat  6094336 b- defN 23-May-15 10:58 kr-openssl-install/bin/libcrypto-3-x64.dll
--rw-rw-rw-  2.0 fat   777728 b- defN 23-May-15 10:58 kr-openssl-install/bin/libssl-3-x64.dll
--rw-rw-rw-  2.0 fat   719360 b- defN 23-May-15 10:58 kr-openssl-install/bin/openssl.exe
--rw-rw-rw-  2.0 fat  2889728 b- defN 23-May-15 11:00 kr-openssl-install/lib/ossl-modules/fips.dll
--rw-rw-rw-  2.0 fat     1063 b- defN 23-May-15 10:42 krypton/__init__.py
--rw-rw-rw-  2.0 fat      587 b- defN 23-May-15 10:42 krypton/__main__.py
--rw-rw-rw-  2.0 fat    11287 b- defN 23-May-15 10:42 krypton/_load.py
--rw-rw-rw-  2.0 fat     6180 b- defN 23-May-15 10:42 krypton/base.py
--rw-rw-rw-  2.0 fat     8599 b- defN 23-May-15 10:42 krypton/basic.py
--rw-rw-rw-  2.0 fat       86 b- defN 23-May-15 10:42 krypton/auth/__init__.py
--rw-rw-rw-  2.0 fat     1079 b- defN 23-May-15 10:42 krypton/auth/_utils.py
--rw-rw-rw-  2.0 fat     6755 b- defN 23-May-15 10:42 krypton/auth/factors.py
--rw-rw-rw-  2.0 fat      102 b- defN 23-May-15 10:42 krypton/auth/django/__init__.py
--rw-rw-rw-  2.0 fat      980 b- defN 23-May-15 10:42 krypton/auth/django/middleware.py
--rw-rw-rw-  2.0 fat      403 b- defN 23-May-15 10:42 krypton/auth/django/users.py
--rw-rw-rw-  2.0 fat      120 b- defN 23-May-15 10:42 krypton/auth/users/__init__.py
--rw-rw-rw-  2.0 fat     6199 b- defN 23-May-15 10:42 krypton/auth/users/bases.py
--rw-rw-rw-  2.0 fat    12530 b- defN 23-May-15 10:42 krypton/auth/users/userModel.py
--rw-rw-rw-  2.0 fat     9028 b- defN 23-May-15 10:42 krypton/auth/users/userModelBaseAuth.py
--rw-rw-rw-  2.0 fat     5503 b- defN 23-May-15 10:42 krypton/auth/users/userModelMFAAuth.py
--rw-rw-rw-  2.0 fat    11558 b- defN 23-May-15 11:05 krptn-0.6.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3772 b- defN 23-May-15 11:05 krptn-0.6.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      107 b- defN 23-May-15 11:05 krptn-0.6.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       20 b- defN 23-May-15 11:05 krptn-0.6.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2364 b- defN 23-May-15 11:05 krptn-0.6.0.dist-info/RECORD
-28 files, 10724162 bytes uncompressed, 3501064 bytes compressed:  67.4%
+Zip file size: 3504937 bytes, number of entries: 28
+-rw-rw-rw-  2.0 fat   141824 b- defN 23-May-16 15:54 __CryptoLib.pypy39-pp73-win_amd64.pyd
+-rw-rw-rw-  2.0 fat      182 b- defN 23-May-16 15:49 kr-openssl-config/fipsmodule.cnf
+-rw-rw-rw-  2.0 fat    12682 b- defN 23-May-16 15:46 kr-openssl-config/openssl.cnf
+-rw-rw-rw-  2.0 fat  6094336 b- defN 23-May-16 15:46 kr-openssl-install/bin/libcrypto-3-x64.dll
+-rw-rw-rw-  2.0 fat   777728 b- defN 23-May-16 15:46 kr-openssl-install/bin/libssl-3-x64.dll
+-rw-rw-rw-  2.0 fat   719360 b- defN 23-May-16 15:46 kr-openssl-install/bin/openssl.exe
+-rw-rw-rw-  2.0 fat  2889728 b- defN 23-May-16 15:49 kr-openssl-install/lib/ossl-modules/fips.dll
+-rw-rw-rw-  2.0 fat     1071 b- defN 23-May-16 15:28 krypton/__init__.py
+-rw-rw-rw-  2.0 fat      592 b- defN 23-May-16 15:28 krypton/__main__.py
+-rw-rw-rw-  2.0 fat    11348 b- defN 23-May-16 15:28 krypton/_load.py
+-rw-rw-rw-  2.0 fat     6180 b- defN 23-May-16 15:28 krypton/base.py
+-rw-rw-rw-  2.0 fat     8650 b- defN 23-May-16 15:28 krypton/basic.py
+-rw-rw-rw-  2.0 fat       86 b- defN 23-May-16 15:28 krypton/auth/__init__.py
+-rw-rw-rw-  2.0 fat     1079 b- defN 23-May-16 15:28 krypton/auth/_utils.py
+-rw-rw-rw-  2.0 fat     6755 b- defN 23-May-16 15:28 krypton/auth/factors.py
+-rw-rw-rw-  2.0 fat      102 b- defN 23-May-16 15:28 krypton/auth/django/__init__.py
+-rw-rw-rw-  2.0 fat      980 b- defN 23-May-16 15:28 krypton/auth/django/middleware.py
+-rw-rw-rw-  2.0 fat      403 b- defN 23-May-16 15:28 krypton/auth/django/users.py
+-rw-rw-rw-  2.0 fat      120 b- defN 23-May-16 15:28 krypton/auth/users/__init__.py
+-rw-rw-rw-  2.0 fat     6212 b- defN 23-May-16 15:28 krypton/auth/users/bases.py
+-rw-rw-rw-  2.0 fat    12547 b- defN 23-May-16 15:28 krypton/auth/users/userModel.py
+-rw-rw-rw-  2.0 fat     9272 b- defN 23-May-16 15:28 krypton/auth/users/userModelBaseAuth.py
+-rw-rw-rw-  2.0 fat     5791 b- defN 23-May-16 15:28 krypton/auth/users/userModelMFAAuth.py
+-rw-rw-rw-  2.0 fat    11558 b- defN 23-May-16 15:54 krptn-0.6.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     3772 b- defN 23-May-16 15:54 krptn-0.6.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      107 b- defN 23-May-16 15:54 krptn-0.6.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       20 b- defN 23-May-16 15:53 krptn-0.6.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2364 b- defN 23-May-16 15:54 krptn-0.6.1.dist-info/RECORD
+28 files, 10724849 bytes uncompressed, 3501153 bytes compressed:  67.4%
```

## zipnote {}

```diff
@@ -63,23 +63,23 @@
 
 Filename: krypton/auth/users/userModelBaseAuth.py
 Comment: 
 
 Filename: krypton/auth/users/userModelMFAAuth.py
 Comment: 
 
-Filename: krptn-0.6.0.dist-info/LICENSE
+Filename: krptn-0.6.1.dist-info/LICENSE
 Comment: 
 
-Filename: krptn-0.6.0.dist-info/METADATA
+Filename: krptn-0.6.1.dist-info/METADATA
 Comment: 
 
-Filename: krptn-0.6.0.dist-info/WHEEL
+Filename: krptn-0.6.1.dist-info/WHEEL
 Comment: 
 
-Filename: krptn-0.6.0.dist-info/top_level.txt
+Filename: krptn-0.6.1.dist-info/top_level.txt
 Comment: 
 
-Filename: krptn-0.6.0.dist-info/RECORD
+Filename: krptn-0.6.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## kr-openssl-config/fipsmodule.cnf

```diff
@@ -1,5 +1,5 @@
 [fips_sect]
 activate = 1
 conditional-errors = 1
 security-checks = 1
-module-mac = DD:66:50:65:5D:93:F2:E9:D9:9C:E9:5C:BC:20:4B:F0:7C:1A:CE:60:84:27:55:C3:D1:EC:89:D0:CF:97:6E:24
+module-mac = A1:2A:04:79:6B:6D:51:E4:EB:35:9F:40:B2:2C:78:55:7D:FD:B7:B6:14:15:AC:48:F9:EB:AA:86:9A:54:F8:29
```

## kr-openssl-install/bin/libcrypto-3-x64.dll

### objdump

```diff
@@ -4,15 +4,15 @@
 start address 0x0000000180001258
 
 Characteristics 0x2022
 	executable
 	large address aware
 	DLL
 
-Time/Date		Mon May 15 10:49:19 2023
+Time/Date		Tue May 16 15:36:05 2023
 Magic			020b	(PE32+)
 MajorLinkerVersion	14
 MinorLinkerVersion	34
 SizeOfCode		000000000044d400
 SizeOfInitializedData	0000000000185a00
 SizeOfUninitializedData	0000000000000000
 AddressOfEntryPoint	0000000000001258
@@ -158486,15 +158486,15 @@
 	reloc    4 offset   40 [5c8040] DIR64
 	reloc    5 offset   60 [5c8060] DIR64
 
 There is a debug directory in .rdata at 0x18051b270
 
 Type                Size     Rva      Offset
   2        CodeView 00000049 0051df1c 0051c71c
-(format RSDS signature e98f76bc15c949f988862f962e51459e age 1 pdb D:\a\krypton\krypton\openssl\libcrypto-3-x64.pdb)
+(format RSDS signature 5af1b52b3a0245eab6c9732576bd5465 age 1 pdb D:\a\krypton\krypton\openssl\libcrypto-3-x64.pdb)
  12         Feature 00000014 0051df68 0051c768
 
 The .rsrc Resource Directory section:
 000  Type Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 010   Entry: ID: 0x000010, Value: 0x80000018
 018    Name Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 028     Entry: ID: 0x000001, Value: 0x80000030
@@ -2171334,22 +2171334,24 @@
    1804abfad:	add    %al,(%rax)
    1804abfaf:	add    %dh,(%rbx)
    1804abfb1:	cs xor %ebp,(%rsi)
    1804abfb4:	xor    %al,(%rax)
    1804abfb6:	add    %al,(%rax)
    1804abfb8:	(bad)
    1804abfba:	imul   $0x203a6e6f,0x20(%rsp,%rsi,2),%ebp
-   1804abfc2:	rex.WRB outsl %ds:(%rsi),(%dx)
-   1804abfc4:	outsb  %ds:(%rsi),(%dx)
+   1804abfc2:	push   %rsp
+   1804abfc3:	jne    0x1804ac02a
    1804abfc5:	and    %cl,0x61(%rbp)
    1804abfc8:	jns    0x1804abfea
-   1804abfca:	xor    %esi,0x3a303120(%rip)        # 0x1ba7af0f0
-   1804abfd0:	xor    $0x36,%al
-   1804abfd2:	cmp    (%rbx),%dh
-   1804abfd4:	xor    $0x32303220,%eax
+   1804abfca:	xor    %esi,(%rsi)
+   1804abfcc:	and    %dh,(%rcx)
+   1804abfce:	xor    $0x3a33333a,%eax
+   1804abfd3:	xor    %esi,(%rdx)
+   1804abfd5:	and    %dh,(%rdx)
+   1804abfd7:	xor    %dh,(%rdx)
    1804abfd9:	xor    (%rax),%esp
    1804abfdb:	push   %rbp
    1804abfdc:	push   %rsp
    1804abfdd:	rex.XB add %al,(%r8)
 	...
    1804abfe8:	jo     0x1804ac056
    1804abfea:	(bad)
@@ -2313802,50 +2313804,44 @@
    18051b220:	push   %rax
    18051b221:	sbbb   $0x0,0x1(%rax,%rax,4)
    18051b226:	add    %al,(%rax)
    18051b228:	(bad)
    18051b229:	sbbb   $0x0,0x1(%rax,%rax,4)
 	...
    18051b272:	add    %al,(%rax)
-   18051b274:	(bad)
-   18051b275:	(bad)
-   18051b276:	(bad)
-   18051b277:	add    %al,%fs:(%rax)
+   18051b274:	in     $0xa2,%eax
+   18051b276:	movsxd 0x0(%rax,%rax,1),%esp
    18051b27a:	add    %al,(%rax)
    18051b27c:	add    (%rax),%al
    18051b27e:	add    %al,(%rax)
    18051b280:	rex.WB add %al,(%r8)
    18051b283:	add    %bl,(%rdi,%rbx,8)
    18051b286:	push   %rcx
    18051b287:	add    %bl,(%rdi,%rax,8)
    18051b28a:	push   %rcx
    18051b28b:	add    %al,(%rax)
    18051b28d:	add    %al,(%rax)
-   18051b28f:	add    %ch,(%rdi)
-   18051b291:	(bad)
-   18051b292:	(bad)
-   18051b293:	add    %al,%fs:(%rax)
-   18051b296:	add    %al,(%rax)
-   18051b298:	or     $0x0,%al
+   18051b28f:	add    %ah,%ch
+   18051b291:	movabs %al,0xc000000006463
    18051b29a:	add    %al,(%rax)
    18051b29c:	adc    $0x0,%al
    18051b29e:	add    %al,(%rax)
    18051b2a0:	push   $0x680051df
    18051b2a5:	(bad)
    18051b2a6:	push   %rcx
 	...
    18051df1b:	add    %dl,0x53(%rdx)
    18051df1e:	rex.R push %rbx
-   18051df20:	mov    $0xc9e98f76,%esp
-   18051df25:	adc    $0x868849f9,%eax
-   18051df2a:	(bad)
-   18051df2b:	xchg   %eax,%esi
-   18051df2c:	cs push %rcx
-   18051df2e:	rex.RB sahf
-   18051df30:	add    %eax,(%rax)
+   18051df20:	sub    0x3a025af1(%rbp),%esi
+   18051df26:	(bad)
+   18051df27:	rex.RB mov $0xc9,%r14b
+   18051df2a:	jae    0x18051df51
+   18051df2c:	jbe    0x18051deeb
+   18051df2e:	push   %rsp
+   18051df2f:	add    %eax,%gs:(%rax)
    18051df32:	add    %al,(%rax)
    18051df34:	cmp    0x5c(%rcx,%riz,2),%r11b
    18051df39:	imul   $0x70,0x79(%rdx),%esi
    18051df3d:	je     0x18051dfae
    18051df3f:	outsb  %ds:(%rsi),(%dx)
    18051df40:	pop    %rsp
    18051df41:	imul   $0x70,0x79(%rdx),%esi
```

## kr-openssl-install/bin/libssl-3-x64.dll

### objdump

```diff
@@ -4,15 +4,15 @@
 start address 0x000000018000104b
 
 Characteristics 0x2022
 	executable
 	large address aware
 	DLL
 
-Time/Date		Mon May 15 10:58:16 2023
+Time/Date		Tue May 16 15:46:19 2023
 Magic			020b	(PE32+)
 MajorLinkerVersion	14
 MinorLinkerVersion	34
 SizeOfCode		0000000000083400
 SizeOfInitializedData	000000000003ae00
 SizeOfUninitializedData	0000000000000000
 AddressOfEntryPoint	000000000000104b
@@ -19923,15 +19923,15 @@
 	reloc    4 offset   40 [bf040] DIR64
 	reloc    5 offset   60 [bf060] DIR64
 
 There is a debug directory in .rdata at 0x18009e550
 
 Type                Size     Rva      Offset
   2        CodeView 00000046 0009f31c 0009db1c
-(format RSDS signature 455830a1716b4a9193cdd720dbd8ecec age 2 pdb D:\a\krypton\krypton\openssl\libssl-3-x64.pdb)
+(format RSDS signature 1e762951cfd640a28ef21edf995a4a31 age 2 pdb D:\a\krypton\krypton\openssl\libssl-3-x64.pdb)
  12         Feature 00000014 0009f364 0009db64
 
 The .rsrc Resource Directory section:
 000  Type Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 010   Entry: ID: 0x000010, Value: 0x80000018
 018    Name Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 028     Entry: ID: 0x000001, Value: 0x80000030
@@ -292870,46 +292870,48 @@
    18009e4f8:	rex
    18009e4f9:	lock or 0x1(%rax),%eax
    18009e500:	push   %rax
    18009e501:	lock or 0x1(%rax),%eax
    18009e508:	(bad)
    18009e509:	lock or 0x1(%rax),%eax
 	...
-   18009e554:	rex.W adc %spl,0x64(%rdx)
-   18009e558:	add    %al,(%rax)
+   18009e554:	rex.WXB movsq %ds:(%rsi),%es:(%rdi)
+   18009e556:	movsxd 0x0(%rax,%rax,1),%esp
    18009e55a:	add    %al,(%rax)
    18009e55c:	add    (%rax),%al
    18009e55e:	add    %al,(%rax)
    18009e560:	rex.RX add %r8b,(%rax)
    18009e563:	add    %bl,(%rbx,%rsi,8)
    18009e566:	or     %eax,(%rax)
    18009e568:	sbb    $0xdb,%al
    18009e56a:	or     %eax,(%rax)
    18009e56c:	add    %al,(%rax)
    18009e56e:	add    %al,(%rax)
-   18009e570:	rex.W adc %spl,0x64(%rdx)
-   18009e574:	add    %al,(%rax)
+   18009e570:	rex.WXB movsq %ds:(%rsi),%es:(%rdi)
+   18009e572:	movsxd 0x0(%rax,%rax,1),%esp
    18009e576:	add    %al,(%rax)
    18009e578:	or     $0x0,%al
    18009e57a:	add    %al,(%rax)
    18009e57c:	adc    $0x0,%al
    18009e57e:	add    %al,(%rax)
    18009e580:	repz or %eax,%fs:(%rax)
    18009e584:	fisttpl %fs:(%rcx)
 	...
    18009f31b:	add    %dl,0x53(%rdx)
    18009f31e:	rex.R push %rbx
-   18009f320:	movabs 0x934a91716b455830,%eax
-   18009f329:	int    $0xd7
-   18009f32b:	and    %bl,%bl
-   18009f32d:	fsubr  %st(4),%st
-   18009f32f:	in     (%dx),%al
-   18009f330:	add    (%rax),%al
-   18009f332:	add    %al,(%rax)
-   18009f334:	cmp    0x5c(%rcx,%riz,2),%r11b
+   18009f320:	push   %rcx
+   18009f321:	sub    %esi,0x1e(%rsi)
+   18009f324:	(bad)
+   18009f325:	iret
+   18009f326:	movabs %al,0x4a5a99df1ef28e40
+   18009f32f:	xor    %eax,(%rdx)
+   18009f331:	add    %al,(%rax)
+   18009f333:	add    %al,0x5c(%rdx,%rdi,1)
+   18009f337:	(bad)
+   18009f338:	pop    %rsp
    18009f339:	imul   $0x70,0x79(%rdx),%esi
    18009f33d:	je     0x18009f3ae
    18009f33f:	outsb  %ds:(%rsi),(%dx)
    18009f340:	pop    %rsp
    18009f341:	imul   $0x70,0x79(%rdx),%esi
    18009f345:	je     0x18009f3b6
    18009f347:	outsb  %ds:(%rsi),(%dx)
```

## kr-openssl-install/bin/openssl.exe

### objdump

```diff
@@ -3,15 +3,15 @@
 HAS_RELOC, EXEC_P, HAS_LINENO, HAS_DEBUG, HAS_LOCALS, D_PAGED
 start address 0x000000014005d52c
 
 Characteristics 0x22
 	executable
 	large address aware
 
-Time/Date		Mon May 15 10:58:23 2023
+Time/Date		Tue May 16 15:46:26 2023
 Magic			020b	(PE32+)
 MajorLinkerVersion	14
 MinorLinkerVersion	34
 SizeOfCode		000000000005d000
 SizeOfInitializedData	0000000000053e00
 SizeOfUninitializedData	0000000000000000
 AddressOfEntryPoint	000000000005d52c
@@ -17426,15 +17426,15 @@
 	reloc   34 offset  250 [ab250] DIR64
 	reloc   35 offset  260 [ab260] DIR64
 
 There is a debug directory in .rdata at 0x140092a50
 
 Type                Size     Rva      Offset
   2        CodeView 00000046 00092e30 00092230
-(format RSDS signature bdd19c9369cb4a90b21570dae2c2d229 age 2 pdb D:\a\krypton\krypton\openssl\apps\openssl.pdb)
+(format RSDS signature 92089addfbe6431dbdaf17edb24653cb age 2 pdb D:\a\krypton\krypton\openssl\apps\openssl.pdb)
  12         Feature 00000014 00092e78 00092278
  13         CoffGrp 00000294 00092e8c 0009228c
 
 The .rsrc Resource Directory section:
 000  Type Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 010   Entry: ID: 0x000010, Value: 0x80000018
 018    Name Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
@@ -196292,42 +196292,43 @@
    140092a3e:	add    %al,(%rax)
    140092a40:	cwtl
    140092a41:	adc    (%rsi),%eax
    140092a43:	rex add %eax,(%rax)
    140092a46:	add    %al,(%rax)
    140092a48:	movabs 0x1400613,%al
    140092a51:	add    %al,(%rax)
-   140092a53:	add    %cl,0x10(%rdi)
-   140092a56:	(bad)
-   140092a57:	add    %al,%fs:(%rax)
+   140092a53:	add    %dl,-0x5b(%rdx)
+   140092a56:	movsxd 0x0(%rax,%rax,1),%esp
    140092a5a:	add    %al,(%rax)
    140092a5c:	add    (%rax),%al
    140092a5e:	add    %al,(%rax)
    140092a60:	rex.RX add %r8b,(%rax)
    140092a63:	add    %dh,(%rax)
    140092a65:	cs or  %eax,(%rax)
    140092a68:	xor    %ah,(%rdx)
    140092a6a:	or     %eax,(%rax)
    140092a6c:	add    %al,(%rax)
    140092a6e:	add    %al,(%rax)
-   140092a70:	rex.WRXB adc %r12b,0x64(%r10)
-   140092a74:	add    %al,(%rax)
+   140092a70:	push   %rdx
+   140092a71:	movsl  %ds:(%rsi),%es:(%rdi)
+   140092a72:	movsxd 0x0(%rax,%rax,1),%esp
    140092a76:	add    %al,(%rax)
    140092a78:	or     $0x0,%al
    140092a7a:	add    %al,(%rax)
    140092a7c:	adc    $0x0,%al
    140092a7e:	add    %al,(%rax)
    140092a80:	js     0x140092ab0
    140092a82:	or     %eax,(%rax)
    140092a84:	js     0x140092aa8
    140092a86:	or     %eax,(%rax)
    140092a88:	add    %al,(%rax)
    140092a8a:	add    %al,(%rax)
-   140092a8c:	rex.WRXB adc %r12b,0x64(%r10)
-   140092a90:	add    %al,(%rax)
+   140092a8c:	push   %rdx
+   140092a8d:	movsl  %ds:(%rsi),%es:(%rdi)
+   140092a8e:	movsxd 0x0(%rax,%rax,1),%esp
    140092a92:	add    %al,(%rax)
    140092a94:	or     $0x94000000,%eax
    140092a99:	add    (%rax),%al
    140092a9b:	add    %cl,0x228c0009(%rsi,%rbp,1)
    140092aa2:	or     %eax,(%rax)
 	...
    140092b00:	sbb    %al,(%rax)
@@ -196655,21 +196656,20 @@
    140092e16:	add    $0x5cf1c00,%eax
    140092e1b:	add    %al,-0x2fd00000(%rax,%rax,1)
    140092e22:	add    $0xcb000,%eax
    140092e27:	add    %ah,%dh
    140092e29:	fldl   0x3600(%rip)        # 0x14009642f
    140092e2f:	add    %dl,0x53(%rdx)
    140092e32:	rex.R push %rbx
-   140092e34:	xchg   %eax,%ebx
-   140092e35:	pushf
-   140092e36:	sarl   0x4a9069cb(%rbp)
-   140092e3c:	mov    $0x15,%dl
-   140092e3e:	jo     0x140092e1a
-   140092e40:	loop   0x140092e04
-   140092e42:	shrb   %cl,(%rcx)
+   140092e34:	fstpl  -0x4196df8(%rdx)
+   140092e3a:	sbb    $0x17afbd43,%eax
+   140092e3f:	in     (%dx),%eax
+   140092e40:	mov    $0x46,%dl
+   140092e42:	push   %rbx
+   140092e43:	lret
    140092e44:	add    (%rax),%al
    140092e46:	add    %al,(%rax)
    140092e48:	cmp    0x5c(%rcx,%riz,2),%r11b
    140092e4d:	imul   $0x70,0x79(%rdx),%esi
    140092e51:	je     0x140092ec2
    140092e53:	outsb  %ds:(%rsi),(%dx)
    140092e54:	pop    %rsp
```

## kr-openssl-install/lib/ossl-modules/fips.dll

### objdump

```diff
@@ -4,15 +4,15 @@
 start address 0x00000001800010b9
 
 Characteristics 0x2022
 	executable
 	large address aware
 	DLL
 
-Time/Date		Mon May 15 10:55:16 2023
+Time/Date		Tue May 16 15:43:08 2023
 Magic			020b	(PE32+)
 MajorLinkerVersion	14
 MinorLinkerVersion	34
 SizeOfCode		0000000000258800
 SizeOfInitializedData	0000000000069e00
 SizeOfUninitializedData	0000000000000000
 AddressOfEntryPoint	00000000000010b9
@@ -40734,15 +40734,15 @@
 	reloc    4 offset   40 [2c1040] DIR64
 	reloc    5 offset   60 [2c1060] DIR64
 
 There is a debug directory in .rdata at 0x180298070
 
 Type                Size     Rva      Offset
   2        CodeView 00000048 00298c1c 0029781c
-(format RSDS signature 462af2fbc12a49168b13f2b03096b0d6 age 1 pdb D:\a\krypton\krypton\openssl\providers\fips.pdb)
+(format RSDS signature 2e24b923a9924eb2896c284a607ee0a5 age 1 pdb D:\a\krypton\krypton\openssl\providers\fips.pdb)
  12         Feature 00000014 00298c64 00297864
 
 The .rsrc Resource Directory section:
 000  Type Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 010   Entry: ID: 0x000010, Value: 0x80000018
 018    Name Table: Char: 0, Time: 00000000, Ver: 0/0, Num Names: 0, IDs: 1
 028     Entry: ID: 0x000001, Value: 0x80000030
@@ -1110533,45 +1110533,41 @@
    180298024:	add    %eax,(%rax)
    180298026:	add    %al,(%rax)
    180298028:	(bad)
    180298029:	adc    %ch,(%rax,%rax,4)
    18029802c:	add    %eax,(%rax)
 	...
    180298072:	add    %al,(%rax)
-   180298074:	xchg   %eax,%esp
-   180298075:	punpckldq 0x0(%rax,%rax,1),%mm4
-   18029807a:	add    %al,(%rax)
-   18029807c:	add    (%rax),%al
-   18029807e:	add    %al,(%rax)
-   180298080:	rex.W add %al,(%rax)
-   180298083:	add    %bl,(%rsp,%rcx,4)
+   180298074:	mov    %fs,0x64(%rbx,%riz,2)
+   18029807b:	add    %al,(%rdx)
+   18029807d:	add    %al,(%rax)
+   18029807f:	add    %cl,0x0(%rax)
+   180298082:	add    %al,(%rax)
+   180298084:	sbb    $0x8c,%al
    180298086:	sub    %eax,(%rax)
    180298088:	sbb    $0x78,%al
    18029808a:	sub    %eax,(%rax)
    18029808c:	add    %al,(%rax)
    18029808e:	add    %al,(%rax)
-   180298090:	xchg   %eax,%esp
-   180298091:	punpckldq 0x0(%rax,%rax,1),%mm4
-   180298096:	add    %al,(%rax)
-   180298098:	or     $0x0,%al
+   180298090:	mov    %fs,0x64(%rbx,%riz,2)
+   180298097:	add    %cl,(%rax,%rax,1)
    18029809a:	add    %al,(%rax)
    18029809c:	adc    $0x0,%al
    18029809e:	add    %al,(%rax)
    1802980a0:	mov    %gs,%fs:(%rcx)
    1802980a3:	add    %ah,0x29(%rax,%rdi,2)
 	...
    180298c1b:	add    %dl,0x53(%rdx)
    180298c1e:	rex.R push %rbx
-   180298c20:	sti
-   180298c21:	repnz sub 0x2a(%rsi),%al
-   180298c25:	rcll   $0x49,(%rsi)
-   180298c28:	mov    (%rbx),%edx
-   180298c2a:	repnz mov $0x30,%al
-   180298c2d:	xchg   %eax,%esi
-   180298c2e:	mov    $0xd6,%al
+   180298c20:	and    -0x566dd1dc(%rcx),%edi
+   180298c26:	mov    $0x4e,%dl
+   180298c28:	mov    %ebp,0x4a(%rax,%rbp,1)
+   180298c2c:	(bad)
+   180298c2d:	jle    0x180298c0f
+   180298c2f:	movsl  %ds:(%rsi),%es:(%rdi)
    180298c30:	add    %eax,(%rax)
    180298c32:	add    %al,(%rax)
    180298c34:	cmp    0x5c(%rcx,%riz,2),%r11b
    180298c39:	imul   $0x70,0x79(%rdx),%esi
    180298c3d:	je     0x180298cae
    180298c3f:	outsb  %ds:(%rsi),(%dx)
    180298c40:	pop    %rsp
```

## krypton/__init__.py

```diff
@@ -18,9 +18,10 @@
 ignore = ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
     '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__',
     '__init__', '__init_subclass__', '__le__', '__lt__', '__module__',
     '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
     '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
 search = 5
 
-print("Krptn has been initialized and loaded. In case you run into any problems, please read our "
+print("Krptn has been initialized and loaded. In case you run into any problems, "
+    "please read our "
     "common issues guide: https://docs.krptn.dev/README-FAQ.html.")
```

## krypton/__main__.py

```diff
@@ -6,10 +6,11 @@
     Base.metadata.drop_all(configs._cryptoDbEngine)
     Base.metadata.drop_all(configs._altKeyDbEngine)
     Base.metadata.drop_all(configs._userDbEngine)
     print("Cleaning Database completed!")
 
 parser = argparse.ArgumentParser(description='Krptn CLI')
 parser.add_argument('--clean', dest='doAction', const=cleanDatabase, nargs='?',
-    default=lambda: 'Not cleaning Krptn database', help='Clean Krptn\'s default database (.krptn-data)')
+    default=lambda: 'Not cleaning Krptn database',
+    help='Clean Krptn\'s default database (.krptn-data)')
 args = parser.parse_args(sys.argv[1:])
 args.doAction()
```

## krypton/_load.py

```diff
@@ -11,32 +11,35 @@
 import subprocess
 import importlib.metadata
 from sqlalchemy import DateTime, Text, create_engine, Column, Integer, LargeBinary, select, Boolean
 from sqlalchemy.orm import declarative_base, Session, sessionmaker
 
 __version__ = importlib.metadata.version("krptn")
 
-print("Hey there! Welcome from Krptn. We are setting up some things for you. In case you run into any problems, please read our "
+print("Hey there! Welcome from Krptn. We are setting up some things for you. "
+    "In case you run into any problems, please read our "
     "common issues guide: https://docs.krptn.dev/README-FAQ.html. "
     "It is more complete than you think!")
 
 SITE_PACKAGE = pathlib.Path(__file__).parent.parent.as_posix()
 USER_DIR = pathlib.Path.home()
 
 OPENSSL_CONFIG = pathlib.Path(SITE_PACKAGE, "kr-openssl-config").as_posix()
 OPENSSL_CONFIG_FILE = pathlib.Path(OPENSSL_CONFIG, "openssl.cnf").as_posix()
 OPENSSL_BIN = os.path.join(SITE_PACKAGE, "kr-openssl-install/bin")
-OPENSSL_EXE = os.path.join(OPENSSL_BIN, "openssl.exe" if sys.platform == "win32" else "openssl")
+OPENSSL_EXE = os.path.join(OPENSSL_BIN, "openssl.exe"
+                           if sys.platform == "win32" else "openssl")
 OSSL_LIB = os.path.join(SITE_PACKAGE, "kr-openssl-install/lib")
 RELATIVE_OSSL_MOD = "kr-openssl-install/lib/ossl-modules"
 if not pathlib.Path(OSSL_LIB).exists() and sys.platform == "linux":
     RELATIVE_OSSL_MOD = "kr-openssl-install/lib64/ossl-modules"
     OSSL_LIB = os.path.join(SITE_PACKAGE, "kr-openssl-install/lib64")
 OPENSSL_MODULES = pathlib.Path(SITE_PACKAGE, RELATIVE_OSSL_MOD).as_posix()
-OPENSSL_FIPS_MODULE = os.path.join(OPENSSL_MODULES, "fips.dll" if sys.platform == "win32" \
+OPENSSL_FIPS_MODULE = os.path.join(OPENSSL_MODULES, "fips.dll" 
+    if sys.platform == "win32"
     else ("fips.so" if sys.platform == "linux" else "fips.dylib"))
 OPENSSL_FIPS_CONF = os.path.join(OPENSSL_CONFIG, "fipsmodule.cnf")
 
 KR_DATA = pathlib.Path(pathlib.Path.home(), ".krptn-data/")
 if not KR_DATA.exists():
     os.mkdir(KR_DATA.as_posix())
 try:
@@ -325,12 +328,15 @@
         c.commit()
         c.close()
         self._userDbEngine = engine
         self._userDB = sessionmaker(engine, autoflush=True)
 
 configs = ConfigTemp()
 
-configs.SQLDefaultCryptoDBpath = "sqlite+pysqlite:///"+os.path.join(USER_DIR, ".krptn-data/crypto.db")
-configs.SQLDefaultKeyDBpath = "sqlite+pysqlite:///"+os.path.join(USER_DIR, ".krptn-data/altKMS.db")
-configs.SQLDefaultUserDBpath = "sqlite+pysqlite:///"+os.path.join(USER_DIR, ".krptn-data/users.db")
+configs.SQLDefaultCryptoDBpath = "sqlite+pysqlite:///"\
+    +os.path.join(USER_DIR, ".krptn-data/crypto.db")
+configs.SQLDefaultKeyDBpath = "sqlite+pysqlite:///"\
+    +os.path.join(USER_DIR, ".krptn-data/altKMS.db")
+configs.SQLDefaultUserDBpath = "sqlite+pysqlite:///"\
+    +os.path.join(USER_DIR, ".krptn-data/users.db")
 
 #configs.SQLDefaultUserDBpath = "mssql+pyodbc://localhost/userDB?driver=ODBC+Driver+18+for+SQL+Server&encrypt=no"
```

## krypton/basic.py

```diff
@@ -1,19 +1,19 @@
 """
 Basic security related classes.
 """
+from .base import restEncrypt, restDecrypt, zeromem, PBKDF2
 from datetime import datetime
 import os
 from typing import ByteString
 from sqlalchemy import select, func
 from sqlalchemy.orm import Session, scoped_session
 from . import configs, base, DBschemas
 SQLDefaultCryptoDBpath:Session = configs.SQLDefaultCryptoDBpath
 SQLDefaultKeyDBpath:Session = configs.SQLDefaultKeyDBpath
-from .base import restEncrypt, restDecrypt, zeromem, PBKDF2
 
 class KeyManagementError(Exception):
     """Error in Key Management System
 
     For example, compliance issues
 
     Arguments:
@@ -91,25 +91,26 @@
             ValueError: If an unsupported cipher is used
 
             ValueError: Wrong passwords were provided or the key was tampered with
 
         Returns:
             The key as python bytes
         """
-        stmt = select(DBschemas.KeysTable).where(DBschemas.KeysTable.name == name).limit(1)
+        stmt = select(DBschemas.KeysTable).where(DBschemas.KeysTable.name == name)\
+            .limit(1)
         key:DBschemas.KeysTable = self.c.scalar(stmt)
         if key is None:
             raise ValueError("Such key does not exist")
         if datetime.now().year - key.year >= configs.defaultCryptoperiod and not force:
             raise KeyManagementError("This key has expired. Please add force to the argument to retrieve it anyway.")
         if key.cipher != configs.defaultAlgorithm:
             raise ValueError("Unsupported Cipher")
         r = self._decipher(key.key, pwd, key.salt, key.saltIter)
         splited = r.split(b"$")
-        if splited[1] != name.encode() or splited[2] != str(key.year).encode(): ## Problem
+        if splited[1] != name.encode() or splited[2] != str(key.year).encode():
             raise ValueError("Wrong passwords have been provided or the database has been tampered with.")
         result = base.base64decode(splited[0])
         zeromem(r)
         zeromem(splited[0])
         return result
 
     def createNewKey(self, name:str, pwd:ByteString=None) -> str:
@@ -131,15 +132,16 @@
         stmt = select(DBschemas.KeysTable).where(DBschemas.KeysTable.name == "name")
         a = True
         try:
             self.c.scalars(stmt).one()
         except:
             a=False
         finally:
-            if a: raise KeyError("Such a name already exists")
+            if a:
+                raise KeyError("Such a name already exists")
         k = os.urandom(32)
         s = os.urandom(12)
         rebased = base.base64encode(k)
         editedRebased = rebased+f"${name}${year}"
         ek = self._cipher(editedRebased, pwd, s, configs.defaultIterations)
         zeromem(rebased)
         zeromem(editedRebased)
@@ -162,15 +164,16 @@
         Arguments:
             name -- Name of the Key
 
         Keyword Arguments:
             pwd -- Password (default: {None})
         """
         zeromem(self.getKey(name, pwd, True))
-        stmt = select(DBschemas.KeysTable).where(DBschemas.KeysTable.name == name).limit(1)
+        stmt = select(DBschemas.KeysTable).where(DBschemas.KeysTable.name == name)\
+            .limit(1)
         key:DBschemas.KeysTable = self.c.scalar(stmt)
         self.c.delete(key)
         self.c.flush()
         self.c.commit()
         return
     
     def __del__(self):
@@ -226,15 +229,16 @@
             num -- Integer returned from secureCreate
 
             pwd -- Password set in secureCreate
 
         Returns:
             Plaintext data
         """
-        stmt = select(DBschemas.CryptoTable).where(DBschemas.CryptoTable.id ==num).limit(1)
+        stmt = select(DBschemas.CryptoTable).where(DBschemas.CryptoTable.id ==num)\
+            .limit(1)
         ctext = self.c.scalar(stmt)
         reset = False
         try:
             key = self.getKey(str(num), pwd)
         except KeyManagementError:
             reset = True
             key = self.getKey(str(num), pwd, True)
```

## krypton/auth/users/bases.py

```diff
@@ -133,15 +133,16 @@
     def deleteData(self, name:str) -> None:
         """Delete key-value pair set by setData
 
         Arguments:
             name -- The key to remove
         """
     @abstractmethod
-    def decryptWithUserKey(self, data:ByteString, salt:bytes=None, sender=None) -> bytes:
+    def decryptWithUserKey(self,
+                           data:ByteString, salt:bytes=None, sender=None) -> bytes:
         """Decrypt data with user's key
 
         Arguments:
             data -- Ciphertext
 
             salt -- Salt
 
@@ -155,18 +156,18 @@
     def encryptWithUserKey(self, data:ByteString, otherUsers:list[str]) -> bytes:
         """Encrypt data with user's key
 
         Arguments:
             data -- Plaintext
 
         Keyword Arguments:
-            otherUsers -- List of user names of people who can decrypt it  (default: {None})
+            otherUsers -- List of user nameswho can decrypt it  (default: {None})
 
         Returns:
-            List of tuples of form (user name, ciphertext, salt), which needs to be provided so that user name's user can decrypt it.
+            List of tuples of form (user name, ciphertext, salt), check: https://docs.krptn.dev/README-USER-AUTH.html#encryption.
         """
     @abstractmethod
     def generateNewKeys(self, pwd:str):
         """Regenerate Encryption keys
 
         Arguments:
             pwd -- Password
```

## krypton/auth/users/userModel.py

```diff
@@ -14,19 +14,19 @@
 from sqlalchemy.orm import scoped_session
 from sqlalchemy.exc import PendingRollbackError
 from .. import factors
 from ... import DBschemas, configs
 from ... import base
 from .userModelBaseAuth import AuthUser
 from .userModelMFAAuth import MFAUser
-from .bases import UserError, userExistRequired, user
+from .bases import userExistRequired, user
 
 class standardUser(AuthUser, MFAUser, user):
     """User Model for Krypton
-    Please pass None to __init__ to create a new user, after that call saveNewUser with required args.
+    Check documentation.
     """
     userName:str
     _key:bytes
     _privKey:bytes
     salt:bytes
     sessionKey:bytes
     saved:bool
@@ -37,25 +37,27 @@
     def __init__(self, userName:str=None, userID:int=None) -> None:
         super().__init__()
         self.backupAESKeys = []
         self.backupKeys = []
         self.loggedin = False
         self.FIDORequired = False
         self.c = scoped_session(configs.SQLDefaultUserDBpath)
+        self.saved = False
         if userID is None and userName is None:
-            self.saved = False
             return
         if userName is not None:
-            stmt = select(DBschemas.UserTable.id).where(DBschemas.UserTable.name == userName)
+            stmt = select(DBschemas.UserTable.id)\
+                .where(DBschemas.UserTable.name == userName)
             self.id = self.c.scalar(stmt)
             self.userName = userName
             if self.id is None:
                 return
         else: # that is userID is not None
-            stmt = select(DBschemas.UserTable.name).where(DBschemas.UserTable.id == userID).limit(1)
+            stmt = select(DBschemas.UserTable.name)\
+                .where(DBschemas.UserTable.id == userID).limit(1)
             self.userName = self.c.scalar(stmt)
             self.id = userID
             if self.userName is None:
                 return
         self.saved = True
 
     @userExistRequired
@@ -90,15 +92,16 @@
 
         Raises:
             ValueError: if decryption fails, or if a value is not set
 
         Returns:
             The value
         """
-        stmt = select(DBschemas.UserData.value).where(and_(DBschemas.UserData.name == name,
+        stmt = select(DBschemas.UserData.value).where(and_(
+            DBschemas.UserData.name == name,
             DBschemas.UserData.Uid == self.id))
         result = self.c.scalar(stmt)
         if result is None:
             raise ValueError("No such data saved.")
         try:
             text = base.restDecrypt(result, self._key)
         except ValueError:
@@ -127,15 +130,16 @@
         stmt = delete(DBschemas.UserData).where(and_(DBschemas.UserData.name == name,
             DBschemas.UserData.Uid == self.id))
         self.c.execute(stmt)
         self.c.flush()
         self.c.commit()
 
     @userExistRequired
-    def decryptWithUserKey(self, data:ByteString, salt:bytes=None, sender=None) -> bytes:
+    def decryptWithUserKey(self, 
+                    data:ByteString, salt:bytes=None, sender=None) -> bytes:
         """Decrypt data with user's key
 
         Arguments:
             data -- Ciphertext
 
             salt -- Salt
 
@@ -160,63 +164,66 @@
                     text = base.restDecrypt(data, key)
                 except ValueError:
                     retry = True
                 if not retry:
                     break
             return text
         if not isinstance(sender, int):
-            stmt = select(DBschemas.UserTable.id).where(DBschemas.UserTable.name == sender)
+            stmt = select(DBschemas.UserTable.id).where(
+                DBschemas.UserTable.name == sender)
             Uid = self.c.scalar(stmt)
         else:
             Uid = sender
         keys = base.getSharedKey(self._privKey, Uid, salt)
         try:
             for key in keys:
                 retry = False
                 try:
                     text = base.restDecrypt(data, key)
                 except ValueError:
                     retry = True
                 base.zeromem(key)
                 if not retry:
                     break
-        except ValueError: pass
+        except ValueError:
+            pass
         for privKey in self.backupKeys:
             keys = base.getSharedKey(privKey, Uid, salt)
             retry = False
             for key in keys:
                 try:
                     text = base.restDecrypt(data, key)
                 except ValueError:
                     retry = True
                 base.zeromem(key)
                 if not retry:
                     break
             if not retry:
                 break
-        try: return text
+        try:
+            return text
         except NameError as exc:
             raise ValueError("Unable to decrypt the ciphertext") from exc
 
     @userExistRequired
     def encryptWithUserKey(self,
         data:ByteString,
         otherUsers:list[int]=None) -> list[tuple[str, bytes, bytes]]:
         """Encrypt data with user's key
 
         Arguments:
             data -- Plaintext
 
         Keyword Arguments:
-            otherUsers -- List of user names of people who can decrypt it  (default: {None})
+            otherUsers -- List of user names who can decrypt it (default: {None})
 
         Returns:
             If otherUsers is None: ciphertext.
 
-            If otherUsers is not None: list of tuples of form (user name, ciphertext, salt), which needs to be provided so that username's user can decrypt it.
+            If otherUsers is not None: list of tuples (check https://docs.krptn.dev/README-USER-AUTH.html#encryption).
         """
         # pylint: disable=expression-not-assigned
         if otherUsers is None:
             ctext =  base.restEncrypt(data, self._key)
             return ctext
         salts = [os.urandom(12) for i in otherUsers]
         AESKeys = []
@@ -271,30 +278,32 @@
 
         Raises:
             ValueError: if decryption fails or requested data does not exist
 
         Returns:
             Decrypted data
         """
-        stmt = select(DBschemas.UserShareTable).where(and_(DBschemas.UserShareTable.name == name,
+        stmt = select(DBschemas.UserShareTable).where(and_(
+            DBschemas.UserShareTable.name == name,
             DBschemas.UserShareTable.shareUid == self.id))
         row:DBschemas.UserShareTable = self.c.scalar(stmt)
         if row is None:
             raise ValueError("Such data does not exist.")
         return self.decryptWithUserKey(row.value, row.salt, row.sender)
 
     @userExistRequired
     def shareDelete(self, name:str) -> None:
         """shareDelete Delete data set by shareSet
 
         Arguments:
             name -- Name of the data
         """
         assert isinstance(name, str)
-        self.c.execute(delete(DBschemas.UserShareTable).where(and_(DBschemas.UserShareTable.name == name,
+        self.c.execute(delete(DBschemas.UserShareTable)\
+            .where(and_(DBschemas.UserShareTable.name == name,
             DBschemas.UserShareTable.sender == self.id)))
         self.c.flush()
         self.c.commit()
 
     @userExistRequired
     def generateNewKeys(self, pwd:str):
         """Regenerate Encryption keys
@@ -305,15 +314,16 @@
         # Generate new Keys and add old keys to backup
         backups = self.getData("_backupAESKeys")
         self.backupAESKeys:list[bytes] = pickle.loads(backups)
         base.zeromem(backups)
         self.backupAESKeys.append(self._key)
 
         tag = factors.password.getAuth(pwd)
-        stmt = update(DBschemas.UserTable).where(DBschemas.UserTable.name == self.userName).\
+        stmt = update(DBschemas.UserTable)\
+            .where(DBschemas.UserTable.name == self.userName).\
             values(pwdAuthToken = tag)
         self.c.execute(stmt)
         self.c.flush()
         self.c.commit()
         self._key = factors.password.auth(tag, pwd)
 
         backups = pickle.dumps(self.backupAESKeys)
```

## krypton/auth/users/userModelBaseAuth.py

```diff
@@ -35,18 +35,20 @@
             """_finishAuthError Prevent timing attacks
             """
             factors.password.auth(base.base64encode(os.urandom(32)), pwd)
         if not self.saved:
             _finishAuthError()
             raise UserError("This user does not exist.")
         authTag:DBschemas.UserTable = self.c.scalar(
-            select(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id).limit(1)
+            select(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id)
+            .limit(1)
         )
         if authTag.fidoID != b"*":
-            if fido is None or factors.fido.authenticate_verify(authTag.fidoChallenge, authTag.fidoPub, fido) is False:
+            if fido is None or factors.fido.authenticate_verify(authTag.fidoChallenge,
+                                                        authTag.fidoPub, fido) is False:
                 self.FIDORequired = True
                 self.logFailure()
                 _finishAuthError()
                 raise UserError("Failed to verify FIDO credentials.")
         if authTag.pwdAuthToken is None:
             self.logFailure()
             _finishAuthError()
@@ -64,40 +66,43 @@
                 raise UserError("Wrong MFA Token")
         restoreKey = os.urandom(32)
         self.sessionKey = base.restEncrypt(self._key, restoreKey)
         token = DBschemas.SessionKeys(
             Uid = self.id,
             key = self.sessionKey,
             iss = datetime.datetime.now(),
-            exp = datetime.datetime.now() + datetime.timedelta(minutes=configs.defaultSessionPeriod)
+            exp = (datetime.datetime.now() +
+                   datetime.timedelta(minutes=configs.defaultSessionPeriod))
         )
         self.c.add(token)
         self.c.flush()
         self.loggedin = True
         time = int(self.getData("_accountKeysCreation").decode())
         if (datetime.datetime.now().year - time) >= 2:
             self.generateNewKeys(pwd)
         self.reload()
         self.c.flush()
         encoded = base.base64encode(restoreKey)
         base.zeromem(restoreKey)
         row = DBschemas.Logs(time=datetime.datetime.now(),
-            exp=datetime.datetime.now() + datetime.timedelta(minutes=configs.defaultLogRetentionPeriod),
+            exp=(datetime.datetime.now() +
+                 datetime.timedelta(minutes=configs.defaultLogRetentionPeriod)),
             success=True,
             userId = self.id)
         self.c.add(row)
         self.c.flush()
         self.c.commit()
         return encoded
     
     def logFailure(self):
         """logFailure Log a login failure
         """
         row = DBschemas.Logs(time=datetime.datetime.now(),
-            exp=datetime.datetime.now() + datetime.timedelta(minutes=configs.defaultLogRetentionPeriod),
+            exp=(datetime.datetime.now()
+                 + datetime.timedelta(minutes=configs.defaultLogRetentionPeriod)),
             success=False,
             userId = self.id)
         self.c.add(row)
         self.c.flush()
         self.c.commit()
     
     @userExistRequired
@@ -111,31 +116,38 @@
 
     @userExistRequired
     def logout(self):
         """logout Logout the user and delete the current Session
         """
         base.zeromem(self._key)
         base.zeromem(self._privKey)
-        stmt = delete(DBschemas.SessionKeys).where(DBschemas.SessionKeys.key == self.sessionKey)
+        stmt = delete(DBschemas.SessionKeys)\
+            .where(DBschemas.SessionKeys.key == self.sessionKey)
         self.c.execute(stmt)
         self.c.flush()
         self.c.commit()
         self.c.expunge_all()
         self.loggedin = False
 
     @userExistRequired
     def delete(self):
         """Delete a user
         """
         _utils.cleanUpSessions(self.c, self.id)
-        self.c.execute(delete(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id))
-        self.c.execute(delete(DBschemas.PubKeyTable).where(DBschemas.PubKeyTable.Uid == self.id))
-        self.c.execute(delete(DBschemas.UserData).where(DBschemas.UserData.Uid == self.id))
-        self.c.execute(delete(DBschemas.UserShareTable).where(DBschemas.UserShareTable.sender == self.id))
-        self.c.execute(delete(DBschemas.PWDReset).where(DBschemas.PWDReset.Uid == self.id))
+        self.c.execute(
+            delete(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id))
+        self.c.execute(
+            delete(DBschemas.PubKeyTable).where(DBschemas.PubKeyTable.Uid == self.id))
+        self.c.execute(
+            delete(DBschemas.UserData).where(DBschemas.UserData.Uid == self.id))
+        self.c.execute(
+            delete(DBschemas.UserShareTable).where(
+                DBschemas.UserShareTable.sender == self.id))
+        self.c.execute(
+            delete(DBschemas.PWDReset).where(DBschemas.PWDReset.Uid == self.id))
         self.c.flush()
         self.c.commit()
         base.zeromem(self._key)
         base.zeromem(self._privKey)
 
     def restoreSession(self, key):
         """Resume sessoin from key
@@ -172,20 +184,21 @@
             name -- User Name
 
             pwd -- Password
 
         Raises:
             ValueError: If user is already saved
         """
-        assert isinstance(name, str) # No need to assert pwd as it will be done in C++ layer
+        assert isinstance(name, str) # No need to assert pwd as it will be done in C++
         if len(name) >= 450:
             raise ValueError("User name must be less then 450 characters.")
         if self.saved:
             raise ValueError("This user is already saved.")
-        s = self.c.scalar(select(DBschemas.UserTable).where(DBschemas.UserTable.name == name))
+        s = self.c.scalar(select(DBschemas.UserTable).where(
+            DBschemas.UserTable.name == name))
         if s is not None:
             raise ValueError("This user is already exists.")
         self.userName = name
         stmt = select(func.max(DBschemas.UserTable.id))
         self.id = self.c.scalar(stmt) + 1
         keys = base.createECCKey()
         self._privKey = keys[0]
```

## krypton/auth/users/userModelMFAAuth.py

```diff
@@ -4,29 +4,30 @@
 #pylint: disable=attribute-defined-outside-init
 #pylint: disable=abstract-method
 import os
 from sqlalchemy import select, delete, update
 
 from .. import factors
 from ... import DBschemas, configs, base
-from .bases import userExistRequired, user
+from .bases import userExistRequired, user, UserError
 
 class MFAUser(user):
     """MFA for Krypton Users
     """
     @userExistRequired
     def enablePWDReset(self) -> list[str]:
         """Enable PWD Reset
 
         Returns:
             The recovery codes that unlock the account
         """
         # pylint: disable=invalid-name
         PKeys = [base.genOTP() for i in range(10)]
-        self.c.execute(delete(DBschemas.PWDReset).where(DBschemas.PWDReset.Uid == self.id))
+        self.c.execute(delete(DBschemas.PWDReset)\
+                       .where(DBschemas.PWDReset.Uid == self.id))
         for PKey in PKeys:
             salt = os.urandom(32)
             key = base.PBKDF2(PKey, salt, configs.defaultPasswordResetIterations, 32)
             skey = base.restEncrypt(self._key, key)
             base.zeromem(key)
             row = DBschemas.PWDReset(
                 Uid = self.id,
@@ -48,25 +49,27 @@
             key -- The recovery code
 
             newPWD -- The new PWD
 
         Raises:
             ValueError: if the reset fails
         """
-        rows = self.c.execute(select(DBschemas.PWDReset).where(DBschemas.PWDReset.Uid == self.id)).scalars().all()
+        rows = self.c.execute(select(DBschemas.PWDReset)\
+                .where(DBschemas.PWDReset.Uid == self.id)).scalars().all()
         reset = False
         for row in rows:
             krKey = base.PBKDF2(key, row.salt, row.iter, 32)
             try:
                 self._key = base.restDecrypt(row.key, krKey)
             except ValueError:
                 continue
             base.zeromem(krKey)
             self.loggedin = True
-            self.c.execute(delete(DBschemas.PWDReset).where(DBschemas.PWDReset.id == row.id))
+            self.c.execute(delete(DBschemas.PWDReset)\
+                           .where(DBschemas.PWDReset.id == row.id))
             self.c.flush()
             self.generateNewKeys(newPWD)
             token = self.login(newPWD)
             reset = True
             break
         if not reset:
             base.sleepOutOfGIL()
@@ -74,39 +77,42 @@
         self.c.commit()
         return token
 
     @userExistRequired
     def disablePWDReset(self):
         """Disbale PWD and revoke all codes
         """
-        self.c.execute(delete(DBschemas.PWDReset).where(DBschemas.PWDReset.Uid == self.id))
+        self.c.execute(delete(DBschemas.PWDReset)\
+                       .where(DBschemas.PWDReset.Uid == self.id))
         self.c.flush()
         self.c.commit()
 
     @userExistRequired
     def enableMFA(self):
         """Enable TOTP MFA
 
         Returns:
             base32 encoded shared secret, QR code string
         """
         secret, base32Secret, string = factors.totp.createTOTP(self.userName)
-        stmt = update(DBschemas.UserTable).where(DBschemas.UserTable.name == self.userName).\
+        stmt = update(DBschemas.UserTable)\
+            .where(DBschemas.UserTable.name == self.userName).\
             values(mfa = base.restEncrypt(secret, self._key))
         self.c.execute(stmt)
         self.c.flush()
         self.c.commit()
         base.zeromem(secret)
         return base32Secret, string
 
     @userExistRequired
     def disableMFA(self):
         """Disable TOTP based MFA
         """
-        stmt = update(DBschemas.UserTable).where(DBschemas.UserTable.name == self.userName).\
+        stmt = update(DBschemas.UserTable)\
+            .where(DBschemas.UserTable.name == self.userName).\
             values(mfa = b"*")
         self.c.execute(stmt)
         self.c.flush()
         self.c.commit()
 
     @userExistRequired
     def beginFIDOSetup(self):
@@ -122,37 +128,43 @@
 
         Arguments:
             repsonse -- The response from the client
         """
         challenge = self.getData("_tempFIDORegisterChallenge")
         self.deleteData("_tempFIDORegisterChallenge")
         credID, credKey = factors.fido.register_verification(response, challenge)
-        self.c.execute(update(DBschemas.UserTable).where(DBschemas.UserTable.name == self.userName).\
+        self.c.execute(update(DBschemas.UserTable)\
+            .where(DBschemas.UserTable.name == self.userName).\
             values(fidoPub=credKey, fidoID=credID))
         self.c.flush()
         self.c.commit()
 
     @userExistRequired
     def removeFIDO(self):
         """Remove the FIDO Auth from Server
         """
-        self.c.execute(update(DBschemas.UserTable).where(DBschemas.UserTable.name == self.userName).\
+        self.c.execute(update(DBschemas.UserTable)\
+            .where(DBschemas.UserTable.name == self.userName).\
             values(fidoPub=b"*", fidoID=b"*"))
         self.c.flush()
         self.c.commit()
 
     def getFIDOOptions(self):
         """Obtain FIDO options before Auth
 
         Returns:
             Fido Options as string, { "error": "No keys availble" } if FIDO is not setup
         """
-        stmt = select(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id).limit(1)
+        if not self.saved:
+            raise UserError("This user does not exist.")
+        stmt = select(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id)\
+            .limit(1)
         authTag:DBschemas.UserTable = self.c.scalar(stmt)
         if authTag.fidoID == b"*":
             return '{ "error": "No keys availble" }'
         options, challenge = factors.fido.authenticate(authTag.fidoID)
-        self.c.execute(update(DBschemas.UserTable).where(DBschemas.UserTable.id == self.id).\
+        self.c.execute(update(DBschemas.UserTable)\
+            .where(DBschemas.UserTable.id == self.id).\
             values(fidoChallenge = challenge))
         self.c.flush()
         self.c.commit()
         return options
```

## Comparing `krptn-0.6.0.dist-info/LICENSE` & `krptn-0.6.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `krptn-0.6.0.dist-info/METADATA` & `krptn-0.6.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: krptn
-Version: 0.6.0
+Version: 0.6.1
 Summary: Zero Knowledge security for Python
 Author-email: Krptn Project <contact@krptn.dev>
 Project-URL: Homepage, https://www.krptn.dev/
 Project-URL: Documentation, https://docs.krptn.dev/
 Project-URL: GitHub, https://github.com/krptn/krypton/
 Project-URL: Bug Tracker, https://github.com/krptn/krypton/issues
 Classifier: License :: OSI Approved :: Apache Software License
```

## Comparing `krptn-0.6.0.dist-info/RECORD` & `krptn-0.6.1.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-__CryptoLib.pypy39-pp73-win_amd64.pyd,sha256=fFyuhDlGFQ5_utzuM-zX6yb19gZhNx5Omc0Ac9ZpzFk,141824
-kr-openssl-config/fipsmodule.cnf,sha256=BWKtE6C-2yKOFoVWJNNet6BcY4uSYTcqDBSoJBRBqRw,182
+__CryptoLib.pypy39-pp73-win_amd64.pyd,sha256=F3ScChue4IBL_e4x-bTiHtMxZDGBOtEMp4IlbW85C3k,141824
+kr-openssl-config/fipsmodule.cnf,sha256=MBDYnRkwA0gormZ8kICKGDnmpspds-qW116E4mi3U2c,182
 kr-openssl-config/openssl.cnf,sha256=Mt0Xk-cLxxXWfquPH8VwWqxkRHgc2P4AO6RPCy8yLhY,12682
-kr-openssl-install/bin/libcrypto-3-x64.dll,sha256=CDMQoOs3QHU14HCwsFHgOdy0E3QO5LvnptsbCW9Sves,6094336
-kr-openssl-install/bin/libssl-3-x64.dll,sha256=U8xiNL942c7UWkWQD_mROmrdZJlvV5d8S_dfvjd0CZc,777728
-kr-openssl-install/bin/openssl.exe,sha256=mmPiS4mDvFfYdnwMXyJAeqWt9wwM0kR_CIuWHPOydZ4,719360
-kr-openssl-install/lib/ossl-modules/fips.dll,sha256=u3mn7_yfAS9szAG561tdmfQjbS7vEhS0sDWkS255FBI,2889728
-krypton/__init__.py,sha256=KF9fMbP0rPsWBExeNa-IgM4Rwq8vjZEUyTGU7QhlX1M,1063
-krypton/__main__.py,sha256=pfpbGJS8Xfwpg3p6IjcR89_-6gfDXlMq8Klv8u2jYeY,587
-krypton/_load.py,sha256=ZLTtX5pYCYqudI1Gf0viSsoyUcGVzywtewKm_teudVk,11287
+kr-openssl-install/bin/libcrypto-3-x64.dll,sha256=gfhGiPRWvTaTEK6sLyKl-1tvJbwq0Pc21HG6vZ-TsqU,6094336
+kr-openssl-install/bin/libssl-3-x64.dll,sha256=7pPTX54v16WpeR7C13CkaRku3cqCvN71N_cMC7MC3_o,777728
+kr-openssl-install/bin/openssl.exe,sha256=Dr0cYMuBrHvEdS6molhbx3qVxYKLRsPOLeVCrLqqWpA,719360
+kr-openssl-install/lib/ossl-modules/fips.dll,sha256=wHpWrhYtnbg-sEbio_JWd_MZZgwVQl33BY9DLmJ2qWM,2889728
+krypton/__init__.py,sha256=_0_iFDLU604gf10_aoqtz4SxTdP4ePJA8NlD0w5Na_I,1071
+krypton/__main__.py,sha256=5hGHzpB7J4wOvNlXp7z04oQqAETxrKJnzRxbSb5NtdE,592
+krypton/_load.py,sha256=FqDPUV2Kvb2Y-yuRz2AilFyUaw8BB37lcV1m7nP9HHE,11348
 krypton/base.py,sha256=aK7dsHZ3DvHJXVo4iYQHYQfP3Gxusk3lDnBB5EhM1DM,6180
-krypton/basic.py,sha256=Kzjdzvntn4vr4-46t3eQlsdmhiP1l6mq-IY3NQR2BS0,8599
+krypton/basic.py,sha256=6tQlIwemi1omm_ks2nNRHIZe5wLkt0IvxFC4ruZvRms,8650
 krypton/auth/__init__.py,sha256=U-KKc4bC7JNVyHYsTUrpMFsQSnLlf8OIxfUeIEN_OAs,86
 krypton/auth/_utils.py,sha256=AN2GWmlJBRAOO80JQrQgzZqg5WREg42Mr6U2Q9FXhZ8,1079
 krypton/auth/factors.py,sha256=VbpK7o7caV3o73oP6ursKbQvmqo8e4zdQuJVCaMmI-g,6755
 krypton/auth/django/__init__.py,sha256=Y5VH-xqNN7LAJ1WZrQ9ZOw4tvcYSM39exXwe6y4mKVY,102
 krypton/auth/django/middleware.py,sha256=p3MrHOlHUsswQqNb63wWuJIksCpce4F68ECF8C1AJ0M,980
 krypton/auth/django/users.py,sha256=6jL1o1iLpQr1r5Qsqh_DoXhYRGMDzwcupayjGwMNcm8,403
 krypton/auth/users/__init__.py,sha256=cQ4mgQcBIY4jZ4XzmcqU3KmE10HZnRy-qc2HtUn8wlo,120
-krypton/auth/users/bases.py,sha256=t24TYxFDHSQQcNVpj2moYyUH8bWu327PoOTZ0YjW_tg,6199
-krypton/auth/users/userModel.py,sha256=-SFN5yuu-tOqk7xgzGM8ha8Xp3xCmzdzJ6BRG22wrI0,12530
-krypton/auth/users/userModelBaseAuth.py,sha256=0dndcoP_uscQ-pKxUej10z944_Juuc68YSsmuO1MiCA,9028
-krypton/auth/users/userModelMFAAuth.py,sha256=Y8HphCscJiF7dS-PeN2_18i1aZp4rRoVX6vg6LMAO-E,5503
-krptn-0.6.0.dist-info/LICENSE,sha256=HrhfyXIkWY2tGFK11kg7vPCqhgh5DcxleloqdhrpyMY,11558
-krptn-0.6.0.dist-info/METADATA,sha256=QZ1dBalUVQz7mxv3NcAyytOIeRi0gJmvmY4llnmXIA8,3772
-krptn-0.6.0.dist-info/WHEEL,sha256=QQY0XPJVcbNrDwRnZBTwtxGbMWJnHaWRpMJLfPEPCFM,107
-krptn-0.6.0.dist-info/top_level.txt,sha256=olpP7PmKL5tJv6HTVjfD9GkBBg2bky8AsKwE1yBwDi8,20
-krptn-0.6.0.dist-info/RECORD,,
+krypton/auth/users/bases.py,sha256=Es83Z9LsbFag5ga1wYbS7En9g50FDc8HNw_2rvFXvUc,6212
+krypton/auth/users/userModel.py,sha256=4Q3EKRk34A7Vh_o293rF9v-r2h8yxIEoSiolVsVFHco,12547
+krypton/auth/users/userModelBaseAuth.py,sha256=JJ4lL01gQdzPRQMmPvUmoCD8r8oeBwjZuuFQAxJAxYo,9272
+krypton/auth/users/userModelMFAAuth.py,sha256=Ub3M5JVpTyqFwppuo3zkG0mgtXlyAbCSdXYkJZtvrF8,5791
+krptn-0.6.1.dist-info/LICENSE,sha256=HrhfyXIkWY2tGFK11kg7vPCqhgh5DcxleloqdhrpyMY,11558
+krptn-0.6.1.dist-info/METADATA,sha256=0gU-yqV8HKOHn-FqZJuJAGWV_PCMYS-lwlI9RDJd4MY,3772
+krptn-0.6.1.dist-info/WHEEL,sha256=QQY0XPJVcbNrDwRnZBTwtxGbMWJnHaWRpMJLfPEPCFM,107
+krptn-0.6.1.dist-info/top_level.txt,sha256=olpP7PmKL5tJv6HTVjfD9GkBBg2bky8AsKwE1yBwDi8,20
+krptn-0.6.1.dist-info/RECORD,,
```

